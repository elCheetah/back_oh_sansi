
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Areas
 * 
 */
export type Areas = $Result.DefaultSelection<Prisma.$AreasPayload>
/**
 * Model ConfigMedallas
 * 
 */
export type ConfigMedallas = $Result.DefaultSelection<Prisma.$ConfigMedallasPayload>
/**
 * Model Evaluaciones
 * 
 */
export type Evaluaciones = $Result.DefaultSelection<Prisma.$EvaluacionesPayload>
/**
 * Model Fases
 * 
 */
export type Fases = $Result.DefaultSelection<Prisma.$FasesPayload>
/**
 * Model Logs
 * 
 */
export type Logs = $Result.DefaultSelection<Prisma.$LogsPayload>
/**
 * Model MiembrosEquipo
 * 
 */
export type MiembrosEquipo = $Result.DefaultSelection<Prisma.$MiembrosEquipoPayload>
/**
 * Model Niveles
 * 
 */
export type Niveles = $Result.DefaultSelection<Prisma.$NivelesPayload>
/**
 * Model Olimpistas
 * 
 */
export type Olimpistas = $Result.DefaultSelection<Prisma.$OlimpistasPayload>
/**
 * Model Participacion
 * 
 */
export type Participacion = $Result.DefaultSelection<Prisma.$ParticipacionPayload>
/**
 * Model Reportes
 * 
 */
export type Reportes = $Result.DefaultSelection<Prisma.$ReportesPayload>
/**
 * Model Roles
 * 
 */
export type Roles = $Result.DefaultSelection<Prisma.$RolesPayload>
/**
 * Model Tutores
 * 
 */
export type Tutores = $Result.DefaultSelection<Prisma.$TutoresPayload>
/**
 * Model UsuarioRol
 * 
 */
export type UsuarioRol = $Result.DefaultSelection<Prisma.$UsuarioRolPayload>
/**
 * Model Usuarios
 * 
 */
export type Usuarios = $Result.DefaultSelection<Prisma.$UsuariosPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const EstadoFase: {
  PENDIENTE: 'PENDIENTE',
  EN_EJECUCION: 'EN_EJECUCION',
  EN_REVISION: 'EN_REVISION',
  FINALIZADA: 'FINALIZADA',
  CANCELADA: 'CANCELADA',
  ARCHIVADA: 'ARCHIVADA'
};

export type EstadoFase = (typeof EstadoFase)[keyof typeof EstadoFase]


export const RolEquipo: {
  LIDER: 'LIDER',
  PARTICIPANTE: 'PARTICIPANTE'
};

export type RolEquipo = (typeof RolEquipo)[keyof typeof RolEquipo]


export const TipoDocumento: {
  CI: 'CI',
  PASAPORTE: 'PASAPORTE',
  CARNET_EXTRANJERO: 'CARNET_EXTRANJERO',
  CERTIFICADO_NACIMIENTO: 'CERTIFICADO_NACIMIENTO'
};

export type TipoDocumento = (typeof TipoDocumento)[keyof typeof TipoDocumento]


export const Sexo: {
  MASCULINO: 'MASCULINO',
  FEMENINO: 'FEMENINO',
  OTRO: 'OTRO'
};

export type Sexo = (typeof Sexo)[keyof typeof Sexo]


export const EstadoParticipacion: {
  CLASIFICADO: 'CLASIFICADO',
  NO_CLASIFICADO: 'NO_CLASIFICADO',
  DESCALIFICADO: 'DESCALIFICADO'
};

export type EstadoParticipacion = (typeof EstadoParticipacion)[keyof typeof EstadoParticipacion]


export const TipoParticipacion: {
  INDIVIDUAL: 'INDIVIDUAL',
  EQUIPO: 'EQUIPO'
};

export type TipoParticipacion = (typeof TipoParticipacion)[keyof typeof TipoParticipacion]

}

export type EstadoFase = $Enums.EstadoFase

export const EstadoFase: typeof $Enums.EstadoFase

export type RolEquipo = $Enums.RolEquipo

export const RolEquipo: typeof $Enums.RolEquipo

export type TipoDocumento = $Enums.TipoDocumento

export const TipoDocumento: typeof $Enums.TipoDocumento

export type Sexo = $Enums.Sexo

export const Sexo: typeof $Enums.Sexo

export type EstadoParticipacion = $Enums.EstadoParticipacion

export const EstadoParticipacion: typeof $Enums.EstadoParticipacion

export type TipoParticipacion = $Enums.TipoParticipacion

export const TipoParticipacion: typeof $Enums.TipoParticipacion

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Areas
 * const areas = await prisma.areas.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Areas
   * const areas = await prisma.areas.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.areas`: Exposes CRUD operations for the **Areas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Areas
    * const areas = await prisma.areas.findMany()
    * ```
    */
  get areas(): Prisma.AreasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.configMedallas`: Exposes CRUD operations for the **ConfigMedallas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ConfigMedallas
    * const configMedallas = await prisma.configMedallas.findMany()
    * ```
    */
  get configMedallas(): Prisma.ConfigMedallasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.evaluaciones`: Exposes CRUD operations for the **Evaluaciones** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Evaluaciones
    * const evaluaciones = await prisma.evaluaciones.findMany()
    * ```
    */
  get evaluaciones(): Prisma.EvaluacionesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fases`: Exposes CRUD operations for the **Fases** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fases
    * const fases = await prisma.fases.findMany()
    * ```
    */
  get fases(): Prisma.FasesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.logs`: Exposes CRUD operations for the **Logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.logs.findMany()
    * ```
    */
  get logs(): Prisma.LogsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.miembrosEquipo`: Exposes CRUD operations for the **MiembrosEquipo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MiembrosEquipos
    * const miembrosEquipos = await prisma.miembrosEquipo.findMany()
    * ```
    */
  get miembrosEquipo(): Prisma.MiembrosEquipoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.niveles`: Exposes CRUD operations for the **Niveles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Niveles
    * const niveles = await prisma.niveles.findMany()
    * ```
    */
  get niveles(): Prisma.NivelesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.olimpistas`: Exposes CRUD operations for the **Olimpistas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Olimpistas
    * const olimpistas = await prisma.olimpistas.findMany()
    * ```
    */
  get olimpistas(): Prisma.OlimpistasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.participacion`: Exposes CRUD operations for the **Participacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Participacions
    * const participacions = await prisma.participacion.findMany()
    * ```
    */
  get participacion(): Prisma.ParticipacionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reportes`: Exposes CRUD operations for the **Reportes** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reportes
    * const reportes = await prisma.reportes.findMany()
    * ```
    */
  get reportes(): Prisma.ReportesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **Roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.RolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tutores`: Exposes CRUD operations for the **Tutores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tutores
    * const tutores = await prisma.tutores.findMany()
    * ```
    */
  get tutores(): Prisma.TutoresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarioRol`: Exposes CRUD operations for the **UsuarioRol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsuarioRols
    * const usuarioRols = await prisma.usuarioRol.findMany()
    * ```
    */
  get usuarioRol(): Prisma.UsuarioRolDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usuarios`: Exposes CRUD operations for the **Usuarios** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuarios.findMany()
    * ```
    */
  get usuarios(): Prisma.UsuariosDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.16.2
   * Query Engine version: 1c57fdcd7e44b29b9313256c76699e91c3ac3c43
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Areas: 'Areas',
    ConfigMedallas: 'ConfigMedallas',
    Evaluaciones: 'Evaluaciones',
    Fases: 'Fases',
    Logs: 'Logs',
    MiembrosEquipo: 'MiembrosEquipo',
    Niveles: 'Niveles',
    Olimpistas: 'Olimpistas',
    Participacion: 'Participacion',
    Reportes: 'Reportes',
    Roles: 'Roles',
    Tutores: 'Tutores',
    UsuarioRol: 'UsuarioRol',
    Usuarios: 'Usuarios'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "areas" | "configMedallas" | "evaluaciones" | "fases" | "logs" | "miembrosEquipo" | "niveles" | "olimpistas" | "participacion" | "reportes" | "roles" | "tutores" | "usuarioRol" | "usuarios"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Areas: {
        payload: Prisma.$AreasPayload<ExtArgs>
        fields: Prisma.AreasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AreasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AreasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>
          }
          findFirst: {
            args: Prisma.AreasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AreasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>
          }
          findMany: {
            args: Prisma.AreasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>[]
          }
          create: {
            args: Prisma.AreasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>
          }
          createMany: {
            args: Prisma.AreasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AreasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>[]
          }
          delete: {
            args: Prisma.AreasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>
          }
          update: {
            args: Prisma.AreasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>
          }
          deleteMany: {
            args: Prisma.AreasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AreasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AreasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>[]
          }
          upsert: {
            args: Prisma.AreasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AreasPayload>
          }
          aggregate: {
            args: Prisma.AreasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAreas>
          }
          groupBy: {
            args: Prisma.AreasGroupByArgs<ExtArgs>
            result: $Utils.Optional<AreasGroupByOutputType>[]
          }
          count: {
            args: Prisma.AreasCountArgs<ExtArgs>
            result: $Utils.Optional<AreasCountAggregateOutputType> | number
          }
        }
      }
      ConfigMedallas: {
        payload: Prisma.$ConfigMedallasPayload<ExtArgs>
        fields: Prisma.ConfigMedallasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfigMedallasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfigMedallasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>
          }
          findFirst: {
            args: Prisma.ConfigMedallasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfigMedallasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>
          }
          findMany: {
            args: Prisma.ConfigMedallasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>[]
          }
          create: {
            args: Prisma.ConfigMedallasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>
          }
          createMany: {
            args: Prisma.ConfigMedallasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfigMedallasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>[]
          }
          delete: {
            args: Prisma.ConfigMedallasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>
          }
          update: {
            args: Prisma.ConfigMedallasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>
          }
          deleteMany: {
            args: Prisma.ConfigMedallasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfigMedallasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConfigMedallasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>[]
          }
          upsert: {
            args: Prisma.ConfigMedallasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfigMedallasPayload>
          }
          aggregate: {
            args: Prisma.ConfigMedallasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfigMedallas>
          }
          groupBy: {
            args: Prisma.ConfigMedallasGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfigMedallasGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfigMedallasCountArgs<ExtArgs>
            result: $Utils.Optional<ConfigMedallasCountAggregateOutputType> | number
          }
        }
      }
      Evaluaciones: {
        payload: Prisma.$EvaluacionesPayload<ExtArgs>
        fields: Prisma.EvaluacionesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EvaluacionesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EvaluacionesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>
          }
          findFirst: {
            args: Prisma.EvaluacionesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EvaluacionesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>
          }
          findMany: {
            args: Prisma.EvaluacionesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>[]
          }
          create: {
            args: Prisma.EvaluacionesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>
          }
          createMany: {
            args: Prisma.EvaluacionesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EvaluacionesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>[]
          }
          delete: {
            args: Prisma.EvaluacionesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>
          }
          update: {
            args: Prisma.EvaluacionesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>
          }
          deleteMany: {
            args: Prisma.EvaluacionesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EvaluacionesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EvaluacionesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>[]
          }
          upsert: {
            args: Prisma.EvaluacionesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EvaluacionesPayload>
          }
          aggregate: {
            args: Prisma.EvaluacionesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvaluaciones>
          }
          groupBy: {
            args: Prisma.EvaluacionesGroupByArgs<ExtArgs>
            result: $Utils.Optional<EvaluacionesGroupByOutputType>[]
          }
          count: {
            args: Prisma.EvaluacionesCountArgs<ExtArgs>
            result: $Utils.Optional<EvaluacionesCountAggregateOutputType> | number
          }
        }
      }
      Fases: {
        payload: Prisma.$FasesPayload<ExtArgs>
        fields: Prisma.FasesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FasesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FasesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>
          }
          findFirst: {
            args: Prisma.FasesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FasesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>
          }
          findMany: {
            args: Prisma.FasesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>[]
          }
          create: {
            args: Prisma.FasesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>
          }
          createMany: {
            args: Prisma.FasesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FasesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>[]
          }
          delete: {
            args: Prisma.FasesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>
          }
          update: {
            args: Prisma.FasesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>
          }
          deleteMany: {
            args: Prisma.FasesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FasesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FasesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>[]
          }
          upsert: {
            args: Prisma.FasesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FasesPayload>
          }
          aggregate: {
            args: Prisma.FasesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFases>
          }
          groupBy: {
            args: Prisma.FasesGroupByArgs<ExtArgs>
            result: $Utils.Optional<FasesGroupByOutputType>[]
          }
          count: {
            args: Prisma.FasesCountArgs<ExtArgs>
            result: $Utils.Optional<FasesCountAggregateOutputType> | number
          }
        }
      }
      Logs: {
        payload: Prisma.$LogsPayload<ExtArgs>
        fields: Prisma.LogsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LogsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LogsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findFirst: {
            args: Prisma.LogsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LogsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          findMany: {
            args: Prisma.LogsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          create: {
            args: Prisma.LogsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          createMany: {
            args: Prisma.LogsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LogsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          delete: {
            args: Prisma.LogsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          update: {
            args: Prisma.LogsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          deleteMany: {
            args: Prisma.LogsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LogsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LogsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>[]
          }
          upsert: {
            args: Prisma.LogsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LogsPayload>
          }
          aggregate: {
            args: Prisma.LogsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLogs>
          }
          groupBy: {
            args: Prisma.LogsGroupByArgs<ExtArgs>
            result: $Utils.Optional<LogsGroupByOutputType>[]
          }
          count: {
            args: Prisma.LogsCountArgs<ExtArgs>
            result: $Utils.Optional<LogsCountAggregateOutputType> | number
          }
        }
      }
      MiembrosEquipo: {
        payload: Prisma.$MiembrosEquipoPayload<ExtArgs>
        fields: Prisma.MiembrosEquipoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MiembrosEquipoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MiembrosEquipoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>
          }
          findFirst: {
            args: Prisma.MiembrosEquipoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MiembrosEquipoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>
          }
          findMany: {
            args: Prisma.MiembrosEquipoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>[]
          }
          create: {
            args: Prisma.MiembrosEquipoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>
          }
          createMany: {
            args: Prisma.MiembrosEquipoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MiembrosEquipoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>[]
          }
          delete: {
            args: Prisma.MiembrosEquipoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>
          }
          update: {
            args: Prisma.MiembrosEquipoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>
          }
          deleteMany: {
            args: Prisma.MiembrosEquipoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MiembrosEquipoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MiembrosEquipoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>[]
          }
          upsert: {
            args: Prisma.MiembrosEquipoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MiembrosEquipoPayload>
          }
          aggregate: {
            args: Prisma.MiembrosEquipoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMiembrosEquipo>
          }
          groupBy: {
            args: Prisma.MiembrosEquipoGroupByArgs<ExtArgs>
            result: $Utils.Optional<MiembrosEquipoGroupByOutputType>[]
          }
          count: {
            args: Prisma.MiembrosEquipoCountArgs<ExtArgs>
            result: $Utils.Optional<MiembrosEquipoCountAggregateOutputType> | number
          }
        }
      }
      Niveles: {
        payload: Prisma.$NivelesPayload<ExtArgs>
        fields: Prisma.NivelesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NivelesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NivelesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>
          }
          findFirst: {
            args: Prisma.NivelesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NivelesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>
          }
          findMany: {
            args: Prisma.NivelesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>[]
          }
          create: {
            args: Prisma.NivelesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>
          }
          createMany: {
            args: Prisma.NivelesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NivelesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>[]
          }
          delete: {
            args: Prisma.NivelesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>
          }
          update: {
            args: Prisma.NivelesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>
          }
          deleteMany: {
            args: Prisma.NivelesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NivelesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NivelesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>[]
          }
          upsert: {
            args: Prisma.NivelesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NivelesPayload>
          }
          aggregate: {
            args: Prisma.NivelesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNiveles>
          }
          groupBy: {
            args: Prisma.NivelesGroupByArgs<ExtArgs>
            result: $Utils.Optional<NivelesGroupByOutputType>[]
          }
          count: {
            args: Prisma.NivelesCountArgs<ExtArgs>
            result: $Utils.Optional<NivelesCountAggregateOutputType> | number
          }
        }
      }
      Olimpistas: {
        payload: Prisma.$OlimpistasPayload<ExtArgs>
        fields: Prisma.OlimpistasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OlimpistasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OlimpistasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>
          }
          findFirst: {
            args: Prisma.OlimpistasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OlimpistasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>
          }
          findMany: {
            args: Prisma.OlimpistasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>[]
          }
          create: {
            args: Prisma.OlimpistasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>
          }
          createMany: {
            args: Prisma.OlimpistasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OlimpistasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>[]
          }
          delete: {
            args: Prisma.OlimpistasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>
          }
          update: {
            args: Prisma.OlimpistasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>
          }
          deleteMany: {
            args: Prisma.OlimpistasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OlimpistasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OlimpistasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>[]
          }
          upsert: {
            args: Prisma.OlimpistasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OlimpistasPayload>
          }
          aggregate: {
            args: Prisma.OlimpistasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOlimpistas>
          }
          groupBy: {
            args: Prisma.OlimpistasGroupByArgs<ExtArgs>
            result: $Utils.Optional<OlimpistasGroupByOutputType>[]
          }
          count: {
            args: Prisma.OlimpistasCountArgs<ExtArgs>
            result: $Utils.Optional<OlimpistasCountAggregateOutputType> | number
          }
        }
      }
      Participacion: {
        payload: Prisma.$ParticipacionPayload<ExtArgs>
        fields: Prisma.ParticipacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ParticipacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ParticipacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>
          }
          findFirst: {
            args: Prisma.ParticipacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ParticipacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>
          }
          findMany: {
            args: Prisma.ParticipacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>[]
          }
          create: {
            args: Prisma.ParticipacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>
          }
          createMany: {
            args: Prisma.ParticipacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ParticipacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>[]
          }
          delete: {
            args: Prisma.ParticipacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>
          }
          update: {
            args: Prisma.ParticipacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>
          }
          deleteMany: {
            args: Prisma.ParticipacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ParticipacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ParticipacionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>[]
          }
          upsert: {
            args: Prisma.ParticipacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ParticipacionPayload>
          }
          aggregate: {
            args: Prisma.ParticipacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateParticipacion>
          }
          groupBy: {
            args: Prisma.ParticipacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ParticipacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ParticipacionCountArgs<ExtArgs>
            result: $Utils.Optional<ParticipacionCountAggregateOutputType> | number
          }
        }
      }
      Reportes: {
        payload: Prisma.$ReportesPayload<ExtArgs>
        fields: Prisma.ReportesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReportesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReportesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>
          }
          findFirst: {
            args: Prisma.ReportesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReportesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>
          }
          findMany: {
            args: Prisma.ReportesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>[]
          }
          create: {
            args: Prisma.ReportesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>
          }
          createMany: {
            args: Prisma.ReportesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReportesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>[]
          }
          delete: {
            args: Prisma.ReportesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>
          }
          update: {
            args: Prisma.ReportesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>
          }
          deleteMany: {
            args: Prisma.ReportesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReportesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReportesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>[]
          }
          upsert: {
            args: Prisma.ReportesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReportesPayload>
          }
          aggregate: {
            args: Prisma.ReportesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReportes>
          }
          groupBy: {
            args: Prisma.ReportesGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReportesGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReportesCountArgs<ExtArgs>
            result: $Utils.Optional<ReportesCountAggregateOutputType> | number
          }
        }
      }
      Roles: {
        payload: Prisma.$RolesPayload<ExtArgs>
        fields: Prisma.RolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findFirst: {
            args: Prisma.RolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          findMany: {
            args: Prisma.RolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          create: {
            args: Prisma.RolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          createMany: {
            args: Prisma.RolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RolesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          delete: {
            args: Prisma.RolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          update: {
            args: Prisma.RolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          deleteMany: {
            args: Prisma.RolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RolesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>[]
          }
          upsert: {
            args: Prisma.RolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.RolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.RolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      Tutores: {
        payload: Prisma.$TutoresPayload<ExtArgs>
        fields: Prisma.TutoresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TutoresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TutoresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>
          }
          findFirst: {
            args: Prisma.TutoresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TutoresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>
          }
          findMany: {
            args: Prisma.TutoresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>[]
          }
          create: {
            args: Prisma.TutoresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>
          }
          createMany: {
            args: Prisma.TutoresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TutoresCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>[]
          }
          delete: {
            args: Prisma.TutoresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>
          }
          update: {
            args: Prisma.TutoresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>
          }
          deleteMany: {
            args: Prisma.TutoresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TutoresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TutoresUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>[]
          }
          upsert: {
            args: Prisma.TutoresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TutoresPayload>
          }
          aggregate: {
            args: Prisma.TutoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTutores>
          }
          groupBy: {
            args: Prisma.TutoresGroupByArgs<ExtArgs>
            result: $Utils.Optional<TutoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.TutoresCountArgs<ExtArgs>
            result: $Utils.Optional<TutoresCountAggregateOutputType> | number
          }
        }
      }
      UsuarioRol: {
        payload: Prisma.$UsuarioRolPayload<ExtArgs>
        fields: Prisma.UsuarioRolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioRolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioRolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          findFirst: {
            args: Prisma.UsuarioRolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioRolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          findMany: {
            args: Prisma.UsuarioRolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>[]
          }
          create: {
            args: Prisma.UsuarioRolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          createMany: {
            args: Prisma.UsuarioRolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioRolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>[]
          }
          delete: {
            args: Prisma.UsuarioRolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          update: {
            args: Prisma.UsuarioRolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioRolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioRolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuarioRolUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>[]
          }
          upsert: {
            args: Prisma.UsuarioRolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioRolPayload>
          }
          aggregate: {
            args: Prisma.UsuarioRolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarioRol>
          }
          groupBy: {
            args: Prisma.UsuarioRolGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioRolGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioRolCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioRolCountAggregateOutputType> | number
          }
        }
      }
      Usuarios: {
        payload: Prisma.$UsuariosPayload<ExtArgs>
        fields: Prisma.UsuariosFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuariosFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuariosFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findFirst: {
            args: Prisma.UsuariosFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuariosFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          findMany: {
            args: Prisma.UsuariosFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          create: {
            args: Prisma.UsuariosCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          createMany: {
            args: Prisma.UsuariosCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuariosCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          delete: {
            args: Prisma.UsuariosDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          update: {
            args: Prisma.UsuariosUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          deleteMany: {
            args: Prisma.UsuariosDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuariosUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsuariosUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>[]
          }
          upsert: {
            args: Prisma.UsuariosUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuariosPayload>
          }
          aggregate: {
            args: Prisma.UsuariosAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuarios>
          }
          groupBy: {
            args: Prisma.UsuariosGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuariosGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuariosCountArgs<ExtArgs>
            result: $Utils.Optional<UsuariosCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory | null
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    areas?: AreasOmit
    configMedallas?: ConfigMedallasOmit
    evaluaciones?: EvaluacionesOmit
    fases?: FasesOmit
    logs?: LogsOmit
    miembrosEquipo?: MiembrosEquipoOmit
    niveles?: NivelesOmit
    olimpistas?: OlimpistasOmit
    participacion?: ParticipacionOmit
    reportes?: ReportesOmit
    roles?: RolesOmit
    tutores?: TutoresOmit
    usuarioRol?: UsuarioRolOmit
    usuarios?: UsuariosOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AreasCountOutputType
   */

  export type AreasCountOutputType = {
    config_medallas: number
    participacion: number
  }

  export type AreasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config_medallas?: boolean | AreasCountOutputTypeCountConfig_medallasArgs
    participacion?: boolean | AreasCountOutputTypeCountParticipacionArgs
  }

  // Custom InputTypes
  /**
   * AreasCountOutputType without action
   */
  export type AreasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AreasCountOutputType
     */
    select?: AreasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AreasCountOutputType without action
   */
  export type AreasCountOutputTypeCountConfig_medallasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigMedallasWhereInput
  }

  /**
   * AreasCountOutputType without action
   */
  export type AreasCountOutputTypeCountParticipacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacionWhereInput
  }


  /**
   * Count Type FasesCountOutputType
   */

  export type FasesCountOutputType = {
    evaluaciones: number
  }

  export type FasesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluaciones?: boolean | FasesCountOutputTypeCountEvaluacionesArgs
  }

  // Custom InputTypes
  /**
   * FasesCountOutputType without action
   */
  export type FasesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FasesCountOutputType
     */
    select?: FasesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FasesCountOutputType without action
   */
  export type FasesCountOutputTypeCountEvaluacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionesWhereInput
  }


  /**
   * Count Type NivelesCountOutputType
   */

  export type NivelesCountOutputType = {
    participacion: number
    ConfigMedallas: number
  }

  export type NivelesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacion?: boolean | NivelesCountOutputTypeCountParticipacionArgs
    ConfigMedallas?: boolean | NivelesCountOutputTypeCountConfigMedallasArgs
  }

  // Custom InputTypes
  /**
   * NivelesCountOutputType without action
   */
  export type NivelesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NivelesCountOutputType
     */
    select?: NivelesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NivelesCountOutputType without action
   */
  export type NivelesCountOutputTypeCountParticipacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacionWhereInput
  }

  /**
   * NivelesCountOutputType without action
   */
  export type NivelesCountOutputTypeCountConfigMedallasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigMedallasWhereInput
  }


  /**
   * Count Type OlimpistasCountOutputType
   */

  export type OlimpistasCountOutputType = {
    participacion: number
    miembros_equipo: number
  }

  export type OlimpistasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacion?: boolean | OlimpistasCountOutputTypeCountParticipacionArgs
    miembros_equipo?: boolean | OlimpistasCountOutputTypeCountMiembros_equipoArgs
  }

  // Custom InputTypes
  /**
   * OlimpistasCountOutputType without action
   */
  export type OlimpistasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OlimpistasCountOutputType
     */
    select?: OlimpistasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OlimpistasCountOutputType without action
   */
  export type OlimpistasCountOutputTypeCountParticipacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacionWhereInput
  }

  /**
   * OlimpistasCountOutputType without action
   */
  export type OlimpistasCountOutputTypeCountMiembros_equipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiembrosEquipoWhereInput
  }


  /**
   * Count Type ParticipacionCountOutputType
   */

  export type ParticipacionCountOutputType = {
    evaluaciones: number
  }

  export type ParticipacionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluaciones?: boolean | ParticipacionCountOutputTypeCountEvaluacionesArgs
  }

  // Custom InputTypes
  /**
   * ParticipacionCountOutputType without action
   */
  export type ParticipacionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ParticipacionCountOutputType
     */
    select?: ParticipacionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ParticipacionCountOutputType without action
   */
  export type ParticipacionCountOutputTypeCountEvaluacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionesWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    usuario_rol: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario_rol?: boolean | RolesCountOutputTypeCountUsuario_rolArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountUsuario_rolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioRolWhereInput
  }


  /**
   * Count Type TutoresCountOutputType
   */

  export type TutoresCountOutputType = {
    olimpistas: number
  }

  export type TutoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpistas?: boolean | TutoresCountOutputTypeCountOlimpistasArgs
  }

  // Custom InputTypes
  /**
   * TutoresCountOutputType without action
   */
  export type TutoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TutoresCountOutputType
     */
    select?: TutoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TutoresCountOutputType without action
   */
  export type TutoresCountOutputTypeCountOlimpistasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OlimpistasWhereInput
  }


  /**
   * Count Type UsuariosCountOutputType
   */

  export type UsuariosCountOutputType = {
    evaluaciones: number
    logs: number
    reportes: number
    usuario_rol: number
  }

  export type UsuariosCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluaciones?: boolean | UsuariosCountOutputTypeCountEvaluacionesArgs
    logs?: boolean | UsuariosCountOutputTypeCountLogsArgs
    reportes?: boolean | UsuariosCountOutputTypeCountReportesArgs
    usuario_rol?: boolean | UsuariosCountOutputTypeCountUsuario_rolArgs
  }

  // Custom InputTypes
  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuariosCountOutputType
     */
    select?: UsuariosCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountEvaluacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionesWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountReportesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportesWhereInput
  }

  /**
   * UsuariosCountOutputType without action
   */
  export type UsuariosCountOutputTypeCountUsuario_rolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioRolWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Areas
   */

  export type AggregateAreas = {
    _count: AreasCountAggregateOutputType | null
    _avg: AreasAvgAggregateOutputType | null
    _sum: AreasSumAggregateOutputType | null
    _min: AreasMinAggregateOutputType | null
    _max: AreasMaxAggregateOutputType | null
  }

  export type AreasAvgAggregateOutputType = {
    id: number | null
  }

  export type AreasSumAggregateOutputType = {
    id: number | null
  }

  export type AreasMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    estado: boolean | null
  }

  export type AreasMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    estado: boolean | null
  }

  export type AreasCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    descripcion: number
    estado: number
    _all: number
  }


  export type AreasAvgAggregateInputType = {
    id?: true
  }

  export type AreasSumAggregateInputType = {
    id?: true
  }

  export type AreasMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    estado?: true
  }

  export type AreasMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    estado?: true
  }

  export type AreasCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    estado?: true
    _all?: true
  }

  export type AreasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to aggregate.
     */
    where?: AreasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreasOrderByWithRelationInput | AreasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AreasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Areas
    **/
    _count?: true | AreasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AreasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AreasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AreasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AreasMaxAggregateInputType
  }

  export type GetAreasAggregateType<T extends AreasAggregateArgs> = {
        [P in keyof T & keyof AggregateAreas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAreas[P]>
      : GetScalarType<T[P], AggregateAreas[P]>
  }




  export type AreasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AreasWhereInput
    orderBy?: AreasOrderByWithAggregationInput | AreasOrderByWithAggregationInput[]
    by: AreasScalarFieldEnum[] | AreasScalarFieldEnum
    having?: AreasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AreasCountAggregateInputType | true
    _avg?: AreasAvgAggregateInputType
    _sum?: AreasSumAggregateInputType
    _min?: AreasMinAggregateInputType
    _max?: AreasMaxAggregateInputType
  }

  export type AreasGroupByOutputType = {
    id: number
    codigo: string | null
    nombre: string
    descripcion: string | null
    estado: boolean
    _count: AreasCountAggregateOutputType | null
    _avg: AreasAvgAggregateOutputType | null
    _sum: AreasSumAggregateOutputType | null
    _min: AreasMinAggregateOutputType | null
    _max: AreasMaxAggregateOutputType | null
  }

  type GetAreasGroupByPayload<T extends AreasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AreasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AreasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AreasGroupByOutputType[P]>
            : GetScalarType<T[P], AreasGroupByOutputType[P]>
        }
      >
    >


  export type AreasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
    config_medallas?: boolean | Areas$config_medallasArgs<ExtArgs>
    participacion?: boolean | Areas$participacionArgs<ExtArgs>
    _count?: boolean | AreasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["areas"]>

  export type AreasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
  }, ExtArgs["result"]["areas"]>

  export type AreasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
  }, ExtArgs["result"]["areas"]>

  export type AreasSelectScalar = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
  }

  export type AreasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "nombre" | "descripcion" | "estado", ExtArgs["result"]["areas"]>
  export type AreasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    config_medallas?: boolean | Areas$config_medallasArgs<ExtArgs>
    participacion?: boolean | Areas$participacionArgs<ExtArgs>
    _count?: boolean | AreasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AreasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AreasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AreasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Areas"
    objects: {
      config_medallas: Prisma.$ConfigMedallasPayload<ExtArgs>[]
      participacion: Prisma.$ParticipacionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string | null
      nombre: string
      descripcion: string | null
      estado: boolean
    }, ExtArgs["result"]["areas"]>
    composites: {}
  }

  type AreasGetPayload<S extends boolean | null | undefined | AreasDefaultArgs> = $Result.GetResult<Prisma.$AreasPayload, S>

  type AreasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AreasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AreasCountAggregateInputType | true
    }

  export interface AreasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Areas'], meta: { name: 'Areas' } }
    /**
     * Find zero or one Areas that matches the filter.
     * @param {AreasFindUniqueArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AreasFindUniqueArgs>(args: SelectSubset<T, AreasFindUniqueArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Areas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AreasFindUniqueOrThrowArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AreasFindUniqueOrThrowArgs>(args: SelectSubset<T, AreasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasFindFirstArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AreasFindFirstArgs>(args?: SelectSubset<T, AreasFindFirstArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Areas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasFindFirstOrThrowArgs} args - Arguments to find a Areas
     * @example
     * // Get one Areas
     * const areas = await prisma.areas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AreasFindFirstOrThrowArgs>(args?: SelectSubset<T, AreasFindFirstOrThrowArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Areas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Areas
     * const areas = await prisma.areas.findMany()
     * 
     * // Get first 10 Areas
     * const areas = await prisma.areas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const areasWithIdOnly = await prisma.areas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AreasFindManyArgs>(args?: SelectSubset<T, AreasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Areas.
     * @param {AreasCreateArgs} args - Arguments to create a Areas.
     * @example
     * // Create one Areas
     * const Areas = await prisma.areas.create({
     *   data: {
     *     // ... data to create a Areas
     *   }
     * })
     * 
     */
    create<T extends AreasCreateArgs>(args: SelectSubset<T, AreasCreateArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Areas.
     * @param {AreasCreateManyArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const areas = await prisma.areas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AreasCreateManyArgs>(args?: SelectSubset<T, AreasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Areas and returns the data saved in the database.
     * @param {AreasCreateManyAndReturnArgs} args - Arguments to create many Areas.
     * @example
     * // Create many Areas
     * const areas = await prisma.areas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Areas and only return the `id`
     * const areasWithIdOnly = await prisma.areas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AreasCreateManyAndReturnArgs>(args?: SelectSubset<T, AreasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Areas.
     * @param {AreasDeleteArgs} args - Arguments to delete one Areas.
     * @example
     * // Delete one Areas
     * const Areas = await prisma.areas.delete({
     *   where: {
     *     // ... filter to delete one Areas
     *   }
     * })
     * 
     */
    delete<T extends AreasDeleteArgs>(args: SelectSubset<T, AreasDeleteArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Areas.
     * @param {AreasUpdateArgs} args - Arguments to update one Areas.
     * @example
     * // Update one Areas
     * const areas = await prisma.areas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AreasUpdateArgs>(args: SelectSubset<T, AreasUpdateArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Areas.
     * @param {AreasDeleteManyArgs} args - Arguments to filter Areas to delete.
     * @example
     * // Delete a few Areas
     * const { count } = await prisma.areas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AreasDeleteManyArgs>(args?: SelectSubset<T, AreasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Areas
     * const areas = await prisma.areas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AreasUpdateManyArgs>(args: SelectSubset<T, AreasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Areas and returns the data updated in the database.
     * @param {AreasUpdateManyAndReturnArgs} args - Arguments to update many Areas.
     * @example
     * // Update many Areas
     * const areas = await prisma.areas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Areas and only return the `id`
     * const areasWithIdOnly = await prisma.areas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AreasUpdateManyAndReturnArgs>(args: SelectSubset<T, AreasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Areas.
     * @param {AreasUpsertArgs} args - Arguments to update or create a Areas.
     * @example
     * // Update or create a Areas
     * const areas = await prisma.areas.upsert({
     *   create: {
     *     // ... data to create a Areas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Areas we want to update
     *   }
     * })
     */
    upsert<T extends AreasUpsertArgs>(args: SelectSubset<T, AreasUpsertArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasCountArgs} args - Arguments to filter Areas to count.
     * @example
     * // Count the number of Areas
     * const count = await prisma.areas.count({
     *   where: {
     *     // ... the filter for the Areas we want to count
     *   }
     * })
    **/
    count<T extends AreasCountArgs>(
      args?: Subset<T, AreasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AreasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AreasAggregateArgs>(args: Subset<T, AreasAggregateArgs>): Prisma.PrismaPromise<GetAreasAggregateType<T>>

    /**
     * Group by Areas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AreasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AreasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AreasGroupByArgs['orderBy'] }
        : { orderBy?: AreasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AreasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAreasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Areas model
   */
  readonly fields: AreasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Areas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AreasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    config_medallas<T extends Areas$config_medallasArgs<ExtArgs> = {}>(args?: Subset<T, Areas$config_medallasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    participacion<T extends Areas$participacionArgs<ExtArgs> = {}>(args?: Subset<T, Areas$participacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Areas model
   */
  interface AreasFieldRefs {
    readonly id: FieldRef<"Areas", 'Int'>
    readonly codigo: FieldRef<"Areas", 'String'>
    readonly nombre: FieldRef<"Areas", 'String'>
    readonly descripcion: FieldRef<"Areas", 'String'>
    readonly estado: FieldRef<"Areas", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Areas findUnique
   */
  export type AreasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where: AreasWhereUniqueInput
  }

  /**
   * Areas findUniqueOrThrow
   */
  export type AreasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where: AreasWhereUniqueInput
  }

  /**
   * Areas findFirst
   */
  export type AreasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreasOrderByWithRelationInput | AreasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * Areas findFirstOrThrow
   */
  export type AreasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreasOrderByWithRelationInput | AreasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Areas.
     */
    cursor?: AreasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Areas.
     */
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * Areas findMany
   */
  export type AreasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * Filter, which Areas to fetch.
     */
    where?: AreasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Areas to fetch.
     */
    orderBy?: AreasOrderByWithRelationInput | AreasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Areas.
     */
    cursor?: AreasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Areas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Areas.
     */
    skip?: number
    distinct?: AreasScalarFieldEnum | AreasScalarFieldEnum[]
  }

  /**
   * Areas create
   */
  export type AreasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * The data needed to create a Areas.
     */
    data: XOR<AreasCreateInput, AreasUncheckedCreateInput>
  }

  /**
   * Areas createMany
   */
  export type AreasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Areas.
     */
    data: AreasCreateManyInput | AreasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Areas createManyAndReturn
   */
  export type AreasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * The data used to create many Areas.
     */
    data: AreasCreateManyInput | AreasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Areas update
   */
  export type AreasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * The data needed to update a Areas.
     */
    data: XOR<AreasUpdateInput, AreasUncheckedUpdateInput>
    /**
     * Choose, which Areas to update.
     */
    where: AreasWhereUniqueInput
  }

  /**
   * Areas updateMany
   */
  export type AreasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Areas.
     */
    data: XOR<AreasUpdateManyMutationInput, AreasUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreasWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Areas updateManyAndReturn
   */
  export type AreasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * The data used to update Areas.
     */
    data: XOR<AreasUpdateManyMutationInput, AreasUncheckedUpdateManyInput>
    /**
     * Filter which Areas to update
     */
    where?: AreasWhereInput
    /**
     * Limit how many Areas to update.
     */
    limit?: number
  }

  /**
   * Areas upsert
   */
  export type AreasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * The filter to search for the Areas to update in case it exists.
     */
    where: AreasWhereUniqueInput
    /**
     * In case the Areas found by the `where` argument doesn't exist, create a new Areas with this data.
     */
    create: XOR<AreasCreateInput, AreasUncheckedCreateInput>
    /**
     * In case the Areas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AreasUpdateInput, AreasUncheckedUpdateInput>
  }

  /**
   * Areas delete
   */
  export type AreasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
    /**
     * Filter which Areas to delete.
     */
    where: AreasWhereUniqueInput
  }

  /**
   * Areas deleteMany
   */
  export type AreasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Areas to delete
     */
    where?: AreasWhereInput
    /**
     * Limit how many Areas to delete.
     */
    limit?: number
  }

  /**
   * Areas.config_medallas
   */
  export type Areas$config_medallasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    where?: ConfigMedallasWhereInput
    orderBy?: ConfigMedallasOrderByWithRelationInput | ConfigMedallasOrderByWithRelationInput[]
    cursor?: ConfigMedallasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigMedallasScalarFieldEnum | ConfigMedallasScalarFieldEnum[]
  }

  /**
   * Areas.participacion
   */
  export type Areas$participacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    where?: ParticipacionWhereInput
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    cursor?: ParticipacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacionScalarFieldEnum | ParticipacionScalarFieldEnum[]
  }

  /**
   * Areas without action
   */
  export type AreasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Areas
     */
    select?: AreasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Areas
     */
    omit?: AreasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AreasInclude<ExtArgs> | null
  }


  /**
   * Model ConfigMedallas
   */

  export type AggregateConfigMedallas = {
    _count: ConfigMedallasCountAggregateOutputType | null
    _avg: ConfigMedallasAvgAggregateOutputType | null
    _sum: ConfigMedallasSumAggregateOutputType | null
    _min: ConfigMedallasMinAggregateOutputType | null
    _max: ConfigMedallasMaxAggregateOutputType | null
  }

  export type ConfigMedallasAvgAggregateOutputType = {
    id: number | null
    area_id: number | null
    nivel_id: number | null
    oros: number | null
    platas: number | null
    bronces: number | null
    menciones: number | null
  }

  export type ConfigMedallasSumAggregateOutputType = {
    id: number | null
    area_id: number | null
    nivel_id: number | null
    oros: number | null
    platas: number | null
    bronces: number | null
    menciones: number | null
  }

  export type ConfigMedallasMinAggregateOutputType = {
    id: number | null
    area_id: number | null
    nivel_id: number | null
    oros: number | null
    platas: number | null
    bronces: number | null
    menciones: number | null
  }

  export type ConfigMedallasMaxAggregateOutputType = {
    id: number | null
    area_id: number | null
    nivel_id: number | null
    oros: number | null
    platas: number | null
    bronces: number | null
    menciones: number | null
  }

  export type ConfigMedallasCountAggregateOutputType = {
    id: number
    area_id: number
    nivel_id: number
    oros: number
    platas: number
    bronces: number
    menciones: number
    _all: number
  }


  export type ConfigMedallasAvgAggregateInputType = {
    id?: true
    area_id?: true
    nivel_id?: true
    oros?: true
    platas?: true
    bronces?: true
    menciones?: true
  }

  export type ConfigMedallasSumAggregateInputType = {
    id?: true
    area_id?: true
    nivel_id?: true
    oros?: true
    platas?: true
    bronces?: true
    menciones?: true
  }

  export type ConfigMedallasMinAggregateInputType = {
    id?: true
    area_id?: true
    nivel_id?: true
    oros?: true
    platas?: true
    bronces?: true
    menciones?: true
  }

  export type ConfigMedallasMaxAggregateInputType = {
    id?: true
    area_id?: true
    nivel_id?: true
    oros?: true
    platas?: true
    bronces?: true
    menciones?: true
  }

  export type ConfigMedallasCountAggregateInputType = {
    id?: true
    area_id?: true
    nivel_id?: true
    oros?: true
    platas?: true
    bronces?: true
    menciones?: true
    _all?: true
  }

  export type ConfigMedallasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigMedallas to aggregate.
     */
    where?: ConfigMedallasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigMedallas to fetch.
     */
    orderBy?: ConfigMedallasOrderByWithRelationInput | ConfigMedallasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfigMedallasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigMedallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigMedallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ConfigMedallas
    **/
    _count?: true | ConfigMedallasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ConfigMedallasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ConfigMedallasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfigMedallasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfigMedallasMaxAggregateInputType
  }

  export type GetConfigMedallasAggregateType<T extends ConfigMedallasAggregateArgs> = {
        [P in keyof T & keyof AggregateConfigMedallas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfigMedallas[P]>
      : GetScalarType<T[P], AggregateConfigMedallas[P]>
  }




  export type ConfigMedallasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfigMedallasWhereInput
    orderBy?: ConfigMedallasOrderByWithAggregationInput | ConfigMedallasOrderByWithAggregationInput[]
    by: ConfigMedallasScalarFieldEnum[] | ConfigMedallasScalarFieldEnum
    having?: ConfigMedallasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfigMedallasCountAggregateInputType | true
    _avg?: ConfigMedallasAvgAggregateInputType
    _sum?: ConfigMedallasSumAggregateInputType
    _min?: ConfigMedallasMinAggregateInputType
    _max?: ConfigMedallasMaxAggregateInputType
  }

  export type ConfigMedallasGroupByOutputType = {
    id: number
    area_id: number
    nivel_id: number
    oros: number
    platas: number
    bronces: number
    menciones: number
    _count: ConfigMedallasCountAggregateOutputType | null
    _avg: ConfigMedallasAvgAggregateOutputType | null
    _sum: ConfigMedallasSumAggregateOutputType | null
    _min: ConfigMedallasMinAggregateOutputType | null
    _max: ConfigMedallasMaxAggregateOutputType | null
  }

  type GetConfigMedallasGroupByPayload<T extends ConfigMedallasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfigMedallasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfigMedallasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfigMedallasGroupByOutputType[P]>
            : GetScalarType<T[P], ConfigMedallasGroupByOutputType[P]>
        }
      >
    >


  export type ConfigMedallasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    oros?: boolean
    platas?: boolean
    bronces?: boolean
    menciones?: boolean
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configMedallas"]>

  export type ConfigMedallasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    oros?: boolean
    platas?: boolean
    bronces?: boolean
    menciones?: boolean
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configMedallas"]>

  export type ConfigMedallasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    oros?: boolean
    platas?: boolean
    bronces?: boolean
    menciones?: boolean
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["configMedallas"]>

  export type ConfigMedallasSelectScalar = {
    id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    oros?: boolean
    platas?: boolean
    bronces?: boolean
    menciones?: boolean
  }

  export type ConfigMedallasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "area_id" | "nivel_id" | "oros" | "platas" | "bronces" | "menciones", ExtArgs["result"]["configMedallas"]>
  export type ConfigMedallasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }
  export type ConfigMedallasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }
  export type ConfigMedallasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }

  export type $ConfigMedallasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ConfigMedallas"
    objects: {
      area: Prisma.$AreasPayload<ExtArgs>
      nivel: Prisma.$NivelesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      area_id: number
      nivel_id: number
      oros: number
      platas: number
      bronces: number
      menciones: number
    }, ExtArgs["result"]["configMedallas"]>
    composites: {}
  }

  type ConfigMedallasGetPayload<S extends boolean | null | undefined | ConfigMedallasDefaultArgs> = $Result.GetResult<Prisma.$ConfigMedallasPayload, S>

  type ConfigMedallasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConfigMedallasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConfigMedallasCountAggregateInputType | true
    }

  export interface ConfigMedallasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ConfigMedallas'], meta: { name: 'ConfigMedallas' } }
    /**
     * Find zero or one ConfigMedallas that matches the filter.
     * @param {ConfigMedallasFindUniqueArgs} args - Arguments to find a ConfigMedallas
     * @example
     * // Get one ConfigMedallas
     * const configMedallas = await prisma.configMedallas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfigMedallasFindUniqueArgs>(args: SelectSubset<T, ConfigMedallasFindUniqueArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ConfigMedallas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConfigMedallasFindUniqueOrThrowArgs} args - Arguments to find a ConfigMedallas
     * @example
     * // Get one ConfigMedallas
     * const configMedallas = await prisma.configMedallas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfigMedallasFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfigMedallasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigMedallas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasFindFirstArgs} args - Arguments to find a ConfigMedallas
     * @example
     * // Get one ConfigMedallas
     * const configMedallas = await prisma.configMedallas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfigMedallasFindFirstArgs>(args?: SelectSubset<T, ConfigMedallasFindFirstArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ConfigMedallas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasFindFirstOrThrowArgs} args - Arguments to find a ConfigMedallas
     * @example
     * // Get one ConfigMedallas
     * const configMedallas = await prisma.configMedallas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfigMedallasFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfigMedallasFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ConfigMedallas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ConfigMedallas
     * const configMedallas = await prisma.configMedallas.findMany()
     * 
     * // Get first 10 ConfigMedallas
     * const configMedallas = await prisma.configMedallas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configMedallasWithIdOnly = await prisma.configMedallas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfigMedallasFindManyArgs>(args?: SelectSubset<T, ConfigMedallasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ConfigMedallas.
     * @param {ConfigMedallasCreateArgs} args - Arguments to create a ConfigMedallas.
     * @example
     * // Create one ConfigMedallas
     * const ConfigMedallas = await prisma.configMedallas.create({
     *   data: {
     *     // ... data to create a ConfigMedallas
     *   }
     * })
     * 
     */
    create<T extends ConfigMedallasCreateArgs>(args: SelectSubset<T, ConfigMedallasCreateArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ConfigMedallas.
     * @param {ConfigMedallasCreateManyArgs} args - Arguments to create many ConfigMedallas.
     * @example
     * // Create many ConfigMedallas
     * const configMedallas = await prisma.configMedallas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfigMedallasCreateManyArgs>(args?: SelectSubset<T, ConfigMedallasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ConfigMedallas and returns the data saved in the database.
     * @param {ConfigMedallasCreateManyAndReturnArgs} args - Arguments to create many ConfigMedallas.
     * @example
     * // Create many ConfigMedallas
     * const configMedallas = await prisma.configMedallas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ConfigMedallas and only return the `id`
     * const configMedallasWithIdOnly = await prisma.configMedallas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfigMedallasCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfigMedallasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ConfigMedallas.
     * @param {ConfigMedallasDeleteArgs} args - Arguments to delete one ConfigMedallas.
     * @example
     * // Delete one ConfigMedallas
     * const ConfigMedallas = await prisma.configMedallas.delete({
     *   where: {
     *     // ... filter to delete one ConfigMedallas
     *   }
     * })
     * 
     */
    delete<T extends ConfigMedallasDeleteArgs>(args: SelectSubset<T, ConfigMedallasDeleteArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ConfigMedallas.
     * @param {ConfigMedallasUpdateArgs} args - Arguments to update one ConfigMedallas.
     * @example
     * // Update one ConfigMedallas
     * const configMedallas = await prisma.configMedallas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfigMedallasUpdateArgs>(args: SelectSubset<T, ConfigMedallasUpdateArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ConfigMedallas.
     * @param {ConfigMedallasDeleteManyArgs} args - Arguments to filter ConfigMedallas to delete.
     * @example
     * // Delete a few ConfigMedallas
     * const { count } = await prisma.configMedallas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfigMedallasDeleteManyArgs>(args?: SelectSubset<T, ConfigMedallasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigMedallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ConfigMedallas
     * const configMedallas = await prisma.configMedallas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfigMedallasUpdateManyArgs>(args: SelectSubset<T, ConfigMedallasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ConfigMedallas and returns the data updated in the database.
     * @param {ConfigMedallasUpdateManyAndReturnArgs} args - Arguments to update many ConfigMedallas.
     * @example
     * // Update many ConfigMedallas
     * const configMedallas = await prisma.configMedallas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ConfigMedallas and only return the `id`
     * const configMedallasWithIdOnly = await prisma.configMedallas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConfigMedallasUpdateManyAndReturnArgs>(args: SelectSubset<T, ConfigMedallasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ConfigMedallas.
     * @param {ConfigMedallasUpsertArgs} args - Arguments to update or create a ConfigMedallas.
     * @example
     * // Update or create a ConfigMedallas
     * const configMedallas = await prisma.configMedallas.upsert({
     *   create: {
     *     // ... data to create a ConfigMedallas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ConfigMedallas we want to update
     *   }
     * })
     */
    upsert<T extends ConfigMedallasUpsertArgs>(args: SelectSubset<T, ConfigMedallasUpsertArgs<ExtArgs>>): Prisma__ConfigMedallasClient<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ConfigMedallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasCountArgs} args - Arguments to filter ConfigMedallas to count.
     * @example
     * // Count the number of ConfigMedallas
     * const count = await prisma.configMedallas.count({
     *   where: {
     *     // ... the filter for the ConfigMedallas we want to count
     *   }
     * })
    **/
    count<T extends ConfigMedallasCountArgs>(
      args?: Subset<T, ConfigMedallasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfigMedallasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ConfigMedallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfigMedallasAggregateArgs>(args: Subset<T, ConfigMedallasAggregateArgs>): Prisma.PrismaPromise<GetConfigMedallasAggregateType<T>>

    /**
     * Group by ConfigMedallas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfigMedallasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfigMedallasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfigMedallasGroupByArgs['orderBy'] }
        : { orderBy?: ConfigMedallasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfigMedallasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfigMedallasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ConfigMedallas model
   */
  readonly fields: ConfigMedallasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ConfigMedallas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfigMedallasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    area<T extends AreasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreasDefaultArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nivel<T extends NivelesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NivelesDefaultArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ConfigMedallas model
   */
  interface ConfigMedallasFieldRefs {
    readonly id: FieldRef<"ConfigMedallas", 'Int'>
    readonly area_id: FieldRef<"ConfigMedallas", 'Int'>
    readonly nivel_id: FieldRef<"ConfigMedallas", 'Int'>
    readonly oros: FieldRef<"ConfigMedallas", 'Int'>
    readonly platas: FieldRef<"ConfigMedallas", 'Int'>
    readonly bronces: FieldRef<"ConfigMedallas", 'Int'>
    readonly menciones: FieldRef<"ConfigMedallas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ConfigMedallas findUnique
   */
  export type ConfigMedallasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * Filter, which ConfigMedallas to fetch.
     */
    where: ConfigMedallasWhereUniqueInput
  }

  /**
   * ConfigMedallas findUniqueOrThrow
   */
  export type ConfigMedallasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * Filter, which ConfigMedallas to fetch.
     */
    where: ConfigMedallasWhereUniqueInput
  }

  /**
   * ConfigMedallas findFirst
   */
  export type ConfigMedallasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * Filter, which ConfigMedallas to fetch.
     */
    where?: ConfigMedallasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigMedallas to fetch.
     */
    orderBy?: ConfigMedallasOrderByWithRelationInput | ConfigMedallasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigMedallas.
     */
    cursor?: ConfigMedallasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigMedallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigMedallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigMedallas.
     */
    distinct?: ConfigMedallasScalarFieldEnum | ConfigMedallasScalarFieldEnum[]
  }

  /**
   * ConfigMedallas findFirstOrThrow
   */
  export type ConfigMedallasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * Filter, which ConfigMedallas to fetch.
     */
    where?: ConfigMedallasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigMedallas to fetch.
     */
    orderBy?: ConfigMedallasOrderByWithRelationInput | ConfigMedallasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ConfigMedallas.
     */
    cursor?: ConfigMedallasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigMedallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigMedallas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ConfigMedallas.
     */
    distinct?: ConfigMedallasScalarFieldEnum | ConfigMedallasScalarFieldEnum[]
  }

  /**
   * ConfigMedallas findMany
   */
  export type ConfigMedallasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * Filter, which ConfigMedallas to fetch.
     */
    where?: ConfigMedallasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ConfigMedallas to fetch.
     */
    orderBy?: ConfigMedallasOrderByWithRelationInput | ConfigMedallasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ConfigMedallas.
     */
    cursor?: ConfigMedallasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ConfigMedallas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ConfigMedallas.
     */
    skip?: number
    distinct?: ConfigMedallasScalarFieldEnum | ConfigMedallasScalarFieldEnum[]
  }

  /**
   * ConfigMedallas create
   */
  export type ConfigMedallasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * The data needed to create a ConfigMedallas.
     */
    data: XOR<ConfigMedallasCreateInput, ConfigMedallasUncheckedCreateInput>
  }

  /**
   * ConfigMedallas createMany
   */
  export type ConfigMedallasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ConfigMedallas.
     */
    data: ConfigMedallasCreateManyInput | ConfigMedallasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ConfigMedallas createManyAndReturn
   */
  export type ConfigMedallasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * The data used to create many ConfigMedallas.
     */
    data: ConfigMedallasCreateManyInput | ConfigMedallasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigMedallas update
   */
  export type ConfigMedallasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * The data needed to update a ConfigMedallas.
     */
    data: XOR<ConfigMedallasUpdateInput, ConfigMedallasUncheckedUpdateInput>
    /**
     * Choose, which ConfigMedallas to update.
     */
    where: ConfigMedallasWhereUniqueInput
  }

  /**
   * ConfigMedallas updateMany
   */
  export type ConfigMedallasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ConfigMedallas.
     */
    data: XOR<ConfigMedallasUpdateManyMutationInput, ConfigMedallasUncheckedUpdateManyInput>
    /**
     * Filter which ConfigMedallas to update
     */
    where?: ConfigMedallasWhereInput
    /**
     * Limit how many ConfigMedallas to update.
     */
    limit?: number
  }

  /**
   * ConfigMedallas updateManyAndReturn
   */
  export type ConfigMedallasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * The data used to update ConfigMedallas.
     */
    data: XOR<ConfigMedallasUpdateManyMutationInput, ConfigMedallasUncheckedUpdateManyInput>
    /**
     * Filter which ConfigMedallas to update
     */
    where?: ConfigMedallasWhereInput
    /**
     * Limit how many ConfigMedallas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ConfigMedallas upsert
   */
  export type ConfigMedallasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * The filter to search for the ConfigMedallas to update in case it exists.
     */
    where: ConfigMedallasWhereUniqueInput
    /**
     * In case the ConfigMedallas found by the `where` argument doesn't exist, create a new ConfigMedallas with this data.
     */
    create: XOR<ConfigMedallasCreateInput, ConfigMedallasUncheckedCreateInput>
    /**
     * In case the ConfigMedallas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfigMedallasUpdateInput, ConfigMedallasUncheckedUpdateInput>
  }

  /**
   * ConfigMedallas delete
   */
  export type ConfigMedallasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    /**
     * Filter which ConfigMedallas to delete.
     */
    where: ConfigMedallasWhereUniqueInput
  }

  /**
   * ConfigMedallas deleteMany
   */
  export type ConfigMedallasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ConfigMedallas to delete
     */
    where?: ConfigMedallasWhereInput
    /**
     * Limit how many ConfigMedallas to delete.
     */
    limit?: number
  }

  /**
   * ConfigMedallas without action
   */
  export type ConfigMedallasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
  }


  /**
   * Model Evaluaciones
   */

  export type AggregateEvaluaciones = {
    _count: EvaluacionesCountAggregateOutputType | null
    _avg: EvaluacionesAvgAggregateOutputType | null
    _sum: EvaluacionesSumAggregateOutputType | null
    _min: EvaluacionesMinAggregateOutputType | null
    _max: EvaluacionesMaxAggregateOutputType | null
  }

  export type EvaluacionesAvgAggregateOutputType = {
    id: number | null
    participacion_id: number | null
    evaluador_id: number | null
    fase_id: number | null
    nota: Decimal | null
  }

  export type EvaluacionesSumAggregateOutputType = {
    id: number | null
    participacion_id: number | null
    evaluador_id: number | null
    fase_id: number | null
    nota: Decimal | null
  }

  export type EvaluacionesMinAggregateOutputType = {
    id: number | null
    participacion_id: number | null
    evaluador_id: number | null
    fase_id: number | null
    nota: Decimal | null
    comentario: string | null
    creado_en: Date | null
    validado: boolean | null
    ultima_modificacion: Date | null
  }

  export type EvaluacionesMaxAggregateOutputType = {
    id: number | null
    participacion_id: number | null
    evaluador_id: number | null
    fase_id: number | null
    nota: Decimal | null
    comentario: string | null
    creado_en: Date | null
    validado: boolean | null
    ultima_modificacion: Date | null
  }

  export type EvaluacionesCountAggregateOutputType = {
    id: number
    participacion_id: number
    evaluador_id: number
    fase_id: number
    nota: number
    comentario: number
    creado_en: number
    validado: number
    ultima_modificacion: number
    _all: number
  }


  export type EvaluacionesAvgAggregateInputType = {
    id?: true
    participacion_id?: true
    evaluador_id?: true
    fase_id?: true
    nota?: true
  }

  export type EvaluacionesSumAggregateInputType = {
    id?: true
    participacion_id?: true
    evaluador_id?: true
    fase_id?: true
    nota?: true
  }

  export type EvaluacionesMinAggregateInputType = {
    id?: true
    participacion_id?: true
    evaluador_id?: true
    fase_id?: true
    nota?: true
    comentario?: true
    creado_en?: true
    validado?: true
    ultima_modificacion?: true
  }

  export type EvaluacionesMaxAggregateInputType = {
    id?: true
    participacion_id?: true
    evaluador_id?: true
    fase_id?: true
    nota?: true
    comentario?: true
    creado_en?: true
    validado?: true
    ultima_modificacion?: true
  }

  export type EvaluacionesCountAggregateInputType = {
    id?: true
    participacion_id?: true
    evaluador_id?: true
    fase_id?: true
    nota?: true
    comentario?: true
    creado_en?: true
    validado?: true
    ultima_modificacion?: true
    _all?: true
  }

  export type EvaluacionesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluaciones to aggregate.
     */
    where?: EvaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluaciones to fetch.
     */
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EvaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Evaluaciones
    **/
    _count?: true | EvaluacionesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EvaluacionesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EvaluacionesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EvaluacionesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EvaluacionesMaxAggregateInputType
  }

  export type GetEvaluacionesAggregateType<T extends EvaluacionesAggregateArgs> = {
        [P in keyof T & keyof AggregateEvaluaciones]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvaluaciones[P]>
      : GetScalarType<T[P], AggregateEvaluaciones[P]>
  }




  export type EvaluacionesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EvaluacionesWhereInput
    orderBy?: EvaluacionesOrderByWithAggregationInput | EvaluacionesOrderByWithAggregationInput[]
    by: EvaluacionesScalarFieldEnum[] | EvaluacionesScalarFieldEnum
    having?: EvaluacionesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EvaluacionesCountAggregateInputType | true
    _avg?: EvaluacionesAvgAggregateInputType
    _sum?: EvaluacionesSumAggregateInputType
    _min?: EvaluacionesMinAggregateInputType
    _max?: EvaluacionesMaxAggregateInputType
  }

  export type EvaluacionesGroupByOutputType = {
    id: number
    participacion_id: number
    evaluador_id: number | null
    fase_id: number | null
    nota: Decimal
    comentario: string | null
    creado_en: Date
    validado: boolean | null
    ultima_modificacion: Date | null
    _count: EvaluacionesCountAggregateOutputType | null
    _avg: EvaluacionesAvgAggregateOutputType | null
    _sum: EvaluacionesSumAggregateOutputType | null
    _min: EvaluacionesMinAggregateOutputType | null
    _max: EvaluacionesMaxAggregateOutputType | null
  }

  type GetEvaluacionesGroupByPayload<T extends EvaluacionesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EvaluacionesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EvaluacionesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EvaluacionesGroupByOutputType[P]>
            : GetScalarType<T[P], EvaluacionesGroupByOutputType[P]>
        }
      >
    >


  export type EvaluacionesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participacion_id?: boolean
    evaluador_id?: boolean
    fase_id?: boolean
    nota?: boolean
    comentario?: boolean
    creado_en?: boolean
    validado?: boolean
    ultima_modificacion?: boolean
    participacion?: boolean | ParticipacionDefaultArgs<ExtArgs>
    evaluador?: boolean | Evaluaciones$evaluadorArgs<ExtArgs>
    fase?: boolean | Evaluaciones$faseArgs<ExtArgs>
  }, ExtArgs["result"]["evaluaciones"]>

  export type EvaluacionesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participacion_id?: boolean
    evaluador_id?: boolean
    fase_id?: boolean
    nota?: boolean
    comentario?: boolean
    creado_en?: boolean
    validado?: boolean
    ultima_modificacion?: boolean
    participacion?: boolean | ParticipacionDefaultArgs<ExtArgs>
    evaluador?: boolean | Evaluaciones$evaluadorArgs<ExtArgs>
    fase?: boolean | Evaluaciones$faseArgs<ExtArgs>
  }, ExtArgs["result"]["evaluaciones"]>

  export type EvaluacionesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    participacion_id?: boolean
    evaluador_id?: boolean
    fase_id?: boolean
    nota?: boolean
    comentario?: boolean
    creado_en?: boolean
    validado?: boolean
    ultima_modificacion?: boolean
    participacion?: boolean | ParticipacionDefaultArgs<ExtArgs>
    evaluador?: boolean | Evaluaciones$evaluadorArgs<ExtArgs>
    fase?: boolean | Evaluaciones$faseArgs<ExtArgs>
  }, ExtArgs["result"]["evaluaciones"]>

  export type EvaluacionesSelectScalar = {
    id?: boolean
    participacion_id?: boolean
    evaluador_id?: boolean
    fase_id?: boolean
    nota?: boolean
    comentario?: boolean
    creado_en?: boolean
    validado?: boolean
    ultima_modificacion?: boolean
  }

  export type EvaluacionesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "participacion_id" | "evaluador_id" | "fase_id" | "nota" | "comentario" | "creado_en" | "validado" | "ultima_modificacion", ExtArgs["result"]["evaluaciones"]>
  export type EvaluacionesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacion?: boolean | ParticipacionDefaultArgs<ExtArgs>
    evaluador?: boolean | Evaluaciones$evaluadorArgs<ExtArgs>
    fase?: boolean | Evaluaciones$faseArgs<ExtArgs>
  }
  export type EvaluacionesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacion?: boolean | ParticipacionDefaultArgs<ExtArgs>
    evaluador?: boolean | Evaluaciones$evaluadorArgs<ExtArgs>
    fase?: boolean | Evaluaciones$faseArgs<ExtArgs>
  }
  export type EvaluacionesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacion?: boolean | ParticipacionDefaultArgs<ExtArgs>
    evaluador?: boolean | Evaluaciones$evaluadorArgs<ExtArgs>
    fase?: boolean | Evaluaciones$faseArgs<ExtArgs>
  }

  export type $EvaluacionesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Evaluaciones"
    objects: {
      participacion: Prisma.$ParticipacionPayload<ExtArgs>
      evaluador: Prisma.$UsuariosPayload<ExtArgs> | null
      fase: Prisma.$FasesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      participacion_id: number
      evaluador_id: number | null
      fase_id: number | null
      nota: Prisma.Decimal
      comentario: string | null
      creado_en: Date
      validado: boolean | null
      ultima_modificacion: Date | null
    }, ExtArgs["result"]["evaluaciones"]>
    composites: {}
  }

  type EvaluacionesGetPayload<S extends boolean | null | undefined | EvaluacionesDefaultArgs> = $Result.GetResult<Prisma.$EvaluacionesPayload, S>

  type EvaluacionesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EvaluacionesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EvaluacionesCountAggregateInputType | true
    }

  export interface EvaluacionesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Evaluaciones'], meta: { name: 'Evaluaciones' } }
    /**
     * Find zero or one Evaluaciones that matches the filter.
     * @param {EvaluacionesFindUniqueArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EvaluacionesFindUniqueArgs>(args: SelectSubset<T, EvaluacionesFindUniqueArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Evaluaciones that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EvaluacionesFindUniqueOrThrowArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EvaluacionesFindUniqueOrThrowArgs>(args: SelectSubset<T, EvaluacionesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesFindFirstArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EvaluacionesFindFirstArgs>(args?: SelectSubset<T, EvaluacionesFindFirstArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Evaluaciones that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesFindFirstOrThrowArgs} args - Arguments to find a Evaluaciones
     * @example
     * // Get one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EvaluacionesFindFirstOrThrowArgs>(args?: SelectSubset<T, EvaluacionesFindFirstOrThrowArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Evaluaciones that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findMany()
     * 
     * // Get first 10 Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const evaluacionesWithIdOnly = await prisma.evaluaciones.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EvaluacionesFindManyArgs>(args?: SelectSubset<T, EvaluacionesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Evaluaciones.
     * @param {EvaluacionesCreateArgs} args - Arguments to create a Evaluaciones.
     * @example
     * // Create one Evaluaciones
     * const Evaluaciones = await prisma.evaluaciones.create({
     *   data: {
     *     // ... data to create a Evaluaciones
     *   }
     * })
     * 
     */
    create<T extends EvaluacionesCreateArgs>(args: SelectSubset<T, EvaluacionesCreateArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Evaluaciones.
     * @param {EvaluacionesCreateManyArgs} args - Arguments to create many Evaluaciones.
     * @example
     * // Create many Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EvaluacionesCreateManyArgs>(args?: SelectSubset<T, EvaluacionesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Evaluaciones and returns the data saved in the database.
     * @param {EvaluacionesCreateManyAndReturnArgs} args - Arguments to create many Evaluaciones.
     * @example
     * // Create many Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Evaluaciones and only return the `id`
     * const evaluacionesWithIdOnly = await prisma.evaluaciones.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EvaluacionesCreateManyAndReturnArgs>(args?: SelectSubset<T, EvaluacionesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Evaluaciones.
     * @param {EvaluacionesDeleteArgs} args - Arguments to delete one Evaluaciones.
     * @example
     * // Delete one Evaluaciones
     * const Evaluaciones = await prisma.evaluaciones.delete({
     *   where: {
     *     // ... filter to delete one Evaluaciones
     *   }
     * })
     * 
     */
    delete<T extends EvaluacionesDeleteArgs>(args: SelectSubset<T, EvaluacionesDeleteArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Evaluaciones.
     * @param {EvaluacionesUpdateArgs} args - Arguments to update one Evaluaciones.
     * @example
     * // Update one Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EvaluacionesUpdateArgs>(args: SelectSubset<T, EvaluacionesUpdateArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Evaluaciones.
     * @param {EvaluacionesDeleteManyArgs} args - Arguments to filter Evaluaciones to delete.
     * @example
     * // Delete a few Evaluaciones
     * const { count } = await prisma.evaluaciones.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EvaluacionesDeleteManyArgs>(args?: SelectSubset<T, EvaluacionesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EvaluacionesUpdateManyArgs>(args: SelectSubset<T, EvaluacionesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Evaluaciones and returns the data updated in the database.
     * @param {EvaluacionesUpdateManyAndReturnArgs} args - Arguments to update many Evaluaciones.
     * @example
     * // Update many Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Evaluaciones and only return the `id`
     * const evaluacionesWithIdOnly = await prisma.evaluaciones.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EvaluacionesUpdateManyAndReturnArgs>(args: SelectSubset<T, EvaluacionesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Evaluaciones.
     * @param {EvaluacionesUpsertArgs} args - Arguments to update or create a Evaluaciones.
     * @example
     * // Update or create a Evaluaciones
     * const evaluaciones = await prisma.evaluaciones.upsert({
     *   create: {
     *     // ... data to create a Evaluaciones
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Evaluaciones we want to update
     *   }
     * })
     */
    upsert<T extends EvaluacionesUpsertArgs>(args: SelectSubset<T, EvaluacionesUpsertArgs<ExtArgs>>): Prisma__EvaluacionesClient<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesCountArgs} args - Arguments to filter Evaluaciones to count.
     * @example
     * // Count the number of Evaluaciones
     * const count = await prisma.evaluaciones.count({
     *   where: {
     *     // ... the filter for the Evaluaciones we want to count
     *   }
     * })
    **/
    count<T extends EvaluacionesCountArgs>(
      args?: Subset<T, EvaluacionesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EvaluacionesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EvaluacionesAggregateArgs>(args: Subset<T, EvaluacionesAggregateArgs>): Prisma.PrismaPromise<GetEvaluacionesAggregateType<T>>

    /**
     * Group by Evaluaciones.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EvaluacionesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EvaluacionesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EvaluacionesGroupByArgs['orderBy'] }
        : { orderBy?: EvaluacionesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EvaluacionesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEvaluacionesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Evaluaciones model
   */
  readonly fields: EvaluacionesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Evaluaciones.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EvaluacionesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participacion<T extends ParticipacionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ParticipacionDefaultArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evaluador<T extends Evaluaciones$evaluadorArgs<ExtArgs> = {}>(args?: Subset<T, Evaluaciones$evaluadorArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    fase<T extends Evaluaciones$faseArgs<ExtArgs> = {}>(args?: Subset<T, Evaluaciones$faseArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Evaluaciones model
   */
  interface EvaluacionesFieldRefs {
    readonly id: FieldRef<"Evaluaciones", 'Int'>
    readonly participacion_id: FieldRef<"Evaluaciones", 'Int'>
    readonly evaluador_id: FieldRef<"Evaluaciones", 'Int'>
    readonly fase_id: FieldRef<"Evaluaciones", 'Int'>
    readonly nota: FieldRef<"Evaluaciones", 'Decimal'>
    readonly comentario: FieldRef<"Evaluaciones", 'String'>
    readonly creado_en: FieldRef<"Evaluaciones", 'DateTime'>
    readonly validado: FieldRef<"Evaluaciones", 'Boolean'>
    readonly ultima_modificacion: FieldRef<"Evaluaciones", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Evaluaciones findUnique
   */
  export type EvaluacionesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * Filter, which Evaluaciones to fetch.
     */
    where: EvaluacionesWhereUniqueInput
  }

  /**
   * Evaluaciones findUniqueOrThrow
   */
  export type EvaluacionesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * Filter, which Evaluaciones to fetch.
     */
    where: EvaluacionesWhereUniqueInput
  }

  /**
   * Evaluaciones findFirst
   */
  export type EvaluacionesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * Filter, which Evaluaciones to fetch.
     */
    where?: EvaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluaciones to fetch.
     */
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluaciones.
     */
    cursor?: EvaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluaciones.
     */
    distinct?: EvaluacionesScalarFieldEnum | EvaluacionesScalarFieldEnum[]
  }

  /**
   * Evaluaciones findFirstOrThrow
   */
  export type EvaluacionesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * Filter, which Evaluaciones to fetch.
     */
    where?: EvaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluaciones to fetch.
     */
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Evaluaciones.
     */
    cursor?: EvaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluaciones.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Evaluaciones.
     */
    distinct?: EvaluacionesScalarFieldEnum | EvaluacionesScalarFieldEnum[]
  }

  /**
   * Evaluaciones findMany
   */
  export type EvaluacionesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * Filter, which Evaluaciones to fetch.
     */
    where?: EvaluacionesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Evaluaciones to fetch.
     */
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Evaluaciones.
     */
    cursor?: EvaluacionesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Evaluaciones from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Evaluaciones.
     */
    skip?: number
    distinct?: EvaluacionesScalarFieldEnum | EvaluacionesScalarFieldEnum[]
  }

  /**
   * Evaluaciones create
   */
  export type EvaluacionesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * The data needed to create a Evaluaciones.
     */
    data: XOR<EvaluacionesCreateInput, EvaluacionesUncheckedCreateInput>
  }

  /**
   * Evaluaciones createMany
   */
  export type EvaluacionesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Evaluaciones.
     */
    data: EvaluacionesCreateManyInput | EvaluacionesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Evaluaciones createManyAndReturn
   */
  export type EvaluacionesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * The data used to create many Evaluaciones.
     */
    data: EvaluacionesCreateManyInput | EvaluacionesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluaciones update
   */
  export type EvaluacionesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * The data needed to update a Evaluaciones.
     */
    data: XOR<EvaluacionesUpdateInput, EvaluacionesUncheckedUpdateInput>
    /**
     * Choose, which Evaluaciones to update.
     */
    where: EvaluacionesWhereUniqueInput
  }

  /**
   * Evaluaciones updateMany
   */
  export type EvaluacionesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Evaluaciones.
     */
    data: XOR<EvaluacionesUpdateManyMutationInput, EvaluacionesUncheckedUpdateManyInput>
    /**
     * Filter which Evaluaciones to update
     */
    where?: EvaluacionesWhereInput
    /**
     * Limit how many Evaluaciones to update.
     */
    limit?: number
  }

  /**
   * Evaluaciones updateManyAndReturn
   */
  export type EvaluacionesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * The data used to update Evaluaciones.
     */
    data: XOR<EvaluacionesUpdateManyMutationInput, EvaluacionesUncheckedUpdateManyInput>
    /**
     * Filter which Evaluaciones to update
     */
    where?: EvaluacionesWhereInput
    /**
     * Limit how many Evaluaciones to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Evaluaciones upsert
   */
  export type EvaluacionesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * The filter to search for the Evaluaciones to update in case it exists.
     */
    where: EvaluacionesWhereUniqueInput
    /**
     * In case the Evaluaciones found by the `where` argument doesn't exist, create a new Evaluaciones with this data.
     */
    create: XOR<EvaluacionesCreateInput, EvaluacionesUncheckedCreateInput>
    /**
     * In case the Evaluaciones was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EvaluacionesUpdateInput, EvaluacionesUncheckedUpdateInput>
  }

  /**
   * Evaluaciones delete
   */
  export type EvaluacionesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    /**
     * Filter which Evaluaciones to delete.
     */
    where: EvaluacionesWhereUniqueInput
  }

  /**
   * Evaluaciones deleteMany
   */
  export type EvaluacionesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Evaluaciones to delete
     */
    where?: EvaluacionesWhereInput
    /**
     * Limit how many Evaluaciones to delete.
     */
    limit?: number
  }

  /**
   * Evaluaciones.evaluador
   */
  export type Evaluaciones$evaluadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }

  /**
   * Evaluaciones.fase
   */
  export type Evaluaciones$faseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    where?: FasesWhereInput
  }

  /**
   * Evaluaciones without action
   */
  export type EvaluacionesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
  }


  /**
   * Model Fases
   */

  export type AggregateFases = {
    _count: FasesCountAggregateOutputType | null
    _avg: FasesAvgAggregateOutputType | null
    _sum: FasesSumAggregateOutputType | null
    _min: FasesMinAggregateOutputType | null
    _max: FasesMaxAggregateOutputType | null
  }

  export type FasesAvgAggregateOutputType = {
    id: number | null
  }

  export type FasesSumAggregateOutputType = {
    id: number | null
  }

  export type FasesMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    inicio: Date | null
    fin: Date | null
    estado: $Enums.EstadoFase | null
  }

  export type FasesMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
    inicio: Date | null
    fin: Date | null
    estado: $Enums.EstadoFase | null
  }

  export type FasesCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    inicio: number
    fin: number
    estado: number
    _all: number
  }


  export type FasesAvgAggregateInputType = {
    id?: true
  }

  export type FasesSumAggregateInputType = {
    id?: true
  }

  export type FasesMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    inicio?: true
    fin?: true
    estado?: true
  }

  export type FasesMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    inicio?: true
    fin?: true
    estado?: true
  }

  export type FasesCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    inicio?: true
    fin?: true
    estado?: true
    _all?: true
  }

  export type FasesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fases to aggregate.
     */
    where?: FasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fases to fetch.
     */
    orderBy?: FasesOrderByWithRelationInput | FasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fases
    **/
    _count?: true | FasesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FasesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FasesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FasesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FasesMaxAggregateInputType
  }

  export type GetFasesAggregateType<T extends FasesAggregateArgs> = {
        [P in keyof T & keyof AggregateFases]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFases[P]>
      : GetScalarType<T[P], AggregateFases[P]>
  }




  export type FasesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FasesWhereInput
    orderBy?: FasesOrderByWithAggregationInput | FasesOrderByWithAggregationInput[]
    by: FasesScalarFieldEnum[] | FasesScalarFieldEnum
    having?: FasesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FasesCountAggregateInputType | true
    _avg?: FasesAvgAggregateInputType
    _sum?: FasesSumAggregateInputType
    _min?: FasesMinAggregateInputType
    _max?: FasesMaxAggregateInputType
  }

  export type FasesGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    inicio: Date | null
    fin: Date | null
    estado: $Enums.EstadoFase
    _count: FasesCountAggregateOutputType | null
    _avg: FasesAvgAggregateOutputType | null
    _sum: FasesSumAggregateOutputType | null
    _min: FasesMinAggregateOutputType | null
    _max: FasesMaxAggregateOutputType | null
  }

  type GetFasesGroupByPayload<T extends FasesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FasesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FasesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FasesGroupByOutputType[P]>
            : GetScalarType<T[P], FasesGroupByOutputType[P]>
        }
      >
    >


  export type FasesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    inicio?: boolean
    fin?: boolean
    estado?: boolean
    evaluaciones?: boolean | Fases$evaluacionesArgs<ExtArgs>
    _count?: boolean | FasesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fases"]>

  export type FasesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    inicio?: boolean
    fin?: boolean
    estado?: boolean
  }, ExtArgs["result"]["fases"]>

  export type FasesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    inicio?: boolean
    fin?: boolean
    estado?: boolean
  }, ExtArgs["result"]["fases"]>

  export type FasesSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    inicio?: boolean
    fin?: boolean
    estado?: boolean
  }

  export type FasesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion" | "inicio" | "fin" | "estado", ExtArgs["result"]["fases"]>
  export type FasesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluaciones?: boolean | Fases$evaluacionesArgs<ExtArgs>
    _count?: boolean | FasesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FasesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FasesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FasesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fases"
    objects: {
      evaluaciones: Prisma.$EvaluacionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
      inicio: Date | null
      fin: Date | null
      estado: $Enums.EstadoFase
    }, ExtArgs["result"]["fases"]>
    composites: {}
  }

  type FasesGetPayload<S extends boolean | null | undefined | FasesDefaultArgs> = $Result.GetResult<Prisma.$FasesPayload, S>

  type FasesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FasesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FasesCountAggregateInputType | true
    }

  export interface FasesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fases'], meta: { name: 'Fases' } }
    /**
     * Find zero or one Fases that matches the filter.
     * @param {FasesFindUniqueArgs} args - Arguments to find a Fases
     * @example
     * // Get one Fases
     * const fases = await prisma.fases.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FasesFindUniqueArgs>(args: SelectSubset<T, FasesFindUniqueArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Fases that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FasesFindUniqueOrThrowArgs} args - Arguments to find a Fases
     * @example
     * // Get one Fases
     * const fases = await prisma.fases.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FasesFindUniqueOrThrowArgs>(args: SelectSubset<T, FasesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesFindFirstArgs} args - Arguments to find a Fases
     * @example
     * // Get one Fases
     * const fases = await prisma.fases.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FasesFindFirstArgs>(args?: SelectSubset<T, FasesFindFirstArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Fases that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesFindFirstOrThrowArgs} args - Arguments to find a Fases
     * @example
     * // Get one Fases
     * const fases = await prisma.fases.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FasesFindFirstOrThrowArgs>(args?: SelectSubset<T, FasesFindFirstOrThrowArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Fases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fases
     * const fases = await prisma.fases.findMany()
     * 
     * // Get first 10 Fases
     * const fases = await prisma.fases.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fasesWithIdOnly = await prisma.fases.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FasesFindManyArgs>(args?: SelectSubset<T, FasesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Fases.
     * @param {FasesCreateArgs} args - Arguments to create a Fases.
     * @example
     * // Create one Fases
     * const Fases = await prisma.fases.create({
     *   data: {
     *     // ... data to create a Fases
     *   }
     * })
     * 
     */
    create<T extends FasesCreateArgs>(args: SelectSubset<T, FasesCreateArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Fases.
     * @param {FasesCreateManyArgs} args - Arguments to create many Fases.
     * @example
     * // Create many Fases
     * const fases = await prisma.fases.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FasesCreateManyArgs>(args?: SelectSubset<T, FasesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fases and returns the data saved in the database.
     * @param {FasesCreateManyAndReturnArgs} args - Arguments to create many Fases.
     * @example
     * // Create many Fases
     * const fases = await prisma.fases.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fases and only return the `id`
     * const fasesWithIdOnly = await prisma.fases.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FasesCreateManyAndReturnArgs>(args?: SelectSubset<T, FasesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Fases.
     * @param {FasesDeleteArgs} args - Arguments to delete one Fases.
     * @example
     * // Delete one Fases
     * const Fases = await prisma.fases.delete({
     *   where: {
     *     // ... filter to delete one Fases
     *   }
     * })
     * 
     */
    delete<T extends FasesDeleteArgs>(args: SelectSubset<T, FasesDeleteArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Fases.
     * @param {FasesUpdateArgs} args - Arguments to update one Fases.
     * @example
     * // Update one Fases
     * const fases = await prisma.fases.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FasesUpdateArgs>(args: SelectSubset<T, FasesUpdateArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Fases.
     * @param {FasesDeleteManyArgs} args - Arguments to filter Fases to delete.
     * @example
     * // Delete a few Fases
     * const { count } = await prisma.fases.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FasesDeleteManyArgs>(args?: SelectSubset<T, FasesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fases
     * const fases = await prisma.fases.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FasesUpdateManyArgs>(args: SelectSubset<T, FasesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fases and returns the data updated in the database.
     * @param {FasesUpdateManyAndReturnArgs} args - Arguments to update many Fases.
     * @example
     * // Update many Fases
     * const fases = await prisma.fases.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Fases and only return the `id`
     * const fasesWithIdOnly = await prisma.fases.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FasesUpdateManyAndReturnArgs>(args: SelectSubset<T, FasesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Fases.
     * @param {FasesUpsertArgs} args - Arguments to update or create a Fases.
     * @example
     * // Update or create a Fases
     * const fases = await prisma.fases.upsert({
     *   create: {
     *     // ... data to create a Fases
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fases we want to update
     *   }
     * })
     */
    upsert<T extends FasesUpsertArgs>(args: SelectSubset<T, FasesUpsertArgs<ExtArgs>>): Prisma__FasesClient<$Result.GetResult<Prisma.$FasesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Fases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesCountArgs} args - Arguments to filter Fases to count.
     * @example
     * // Count the number of Fases
     * const count = await prisma.fases.count({
     *   where: {
     *     // ... the filter for the Fases we want to count
     *   }
     * })
    **/
    count<T extends FasesCountArgs>(
      args?: Subset<T, FasesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FasesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FasesAggregateArgs>(args: Subset<T, FasesAggregateArgs>): Prisma.PrismaPromise<GetFasesAggregateType<T>>

    /**
     * Group by Fases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FasesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FasesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FasesGroupByArgs['orderBy'] }
        : { orderBy?: FasesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FasesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFasesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fases model
   */
  readonly fields: FasesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fases.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FasesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluaciones<T extends Fases$evaluacionesArgs<ExtArgs> = {}>(args?: Subset<T, Fases$evaluacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fases model
   */
  interface FasesFieldRefs {
    readonly id: FieldRef<"Fases", 'Int'>
    readonly nombre: FieldRef<"Fases", 'String'>
    readonly descripcion: FieldRef<"Fases", 'String'>
    readonly inicio: FieldRef<"Fases", 'DateTime'>
    readonly fin: FieldRef<"Fases", 'DateTime'>
    readonly estado: FieldRef<"Fases", 'EstadoFase'>
  }
    

  // Custom InputTypes
  /**
   * Fases findUnique
   */
  export type FasesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * Filter, which Fases to fetch.
     */
    where: FasesWhereUniqueInput
  }

  /**
   * Fases findUniqueOrThrow
   */
  export type FasesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * Filter, which Fases to fetch.
     */
    where: FasesWhereUniqueInput
  }

  /**
   * Fases findFirst
   */
  export type FasesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * Filter, which Fases to fetch.
     */
    where?: FasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fases to fetch.
     */
    orderBy?: FasesOrderByWithRelationInput | FasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fases.
     */
    cursor?: FasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fases.
     */
    distinct?: FasesScalarFieldEnum | FasesScalarFieldEnum[]
  }

  /**
   * Fases findFirstOrThrow
   */
  export type FasesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * Filter, which Fases to fetch.
     */
    where?: FasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fases to fetch.
     */
    orderBy?: FasesOrderByWithRelationInput | FasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fases.
     */
    cursor?: FasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fases.
     */
    distinct?: FasesScalarFieldEnum | FasesScalarFieldEnum[]
  }

  /**
   * Fases findMany
   */
  export type FasesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * Filter, which Fases to fetch.
     */
    where?: FasesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fases to fetch.
     */
    orderBy?: FasesOrderByWithRelationInput | FasesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fases.
     */
    cursor?: FasesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fases.
     */
    skip?: number
    distinct?: FasesScalarFieldEnum | FasesScalarFieldEnum[]
  }

  /**
   * Fases create
   */
  export type FasesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * The data needed to create a Fases.
     */
    data: XOR<FasesCreateInput, FasesUncheckedCreateInput>
  }

  /**
   * Fases createMany
   */
  export type FasesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fases.
     */
    data: FasesCreateManyInput | FasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fases createManyAndReturn
   */
  export type FasesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * The data used to create many Fases.
     */
    data: FasesCreateManyInput | FasesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fases update
   */
  export type FasesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * The data needed to update a Fases.
     */
    data: XOR<FasesUpdateInput, FasesUncheckedUpdateInput>
    /**
     * Choose, which Fases to update.
     */
    where: FasesWhereUniqueInput
  }

  /**
   * Fases updateMany
   */
  export type FasesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fases.
     */
    data: XOR<FasesUpdateManyMutationInput, FasesUncheckedUpdateManyInput>
    /**
     * Filter which Fases to update
     */
    where?: FasesWhereInput
    /**
     * Limit how many Fases to update.
     */
    limit?: number
  }

  /**
   * Fases updateManyAndReturn
   */
  export type FasesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * The data used to update Fases.
     */
    data: XOR<FasesUpdateManyMutationInput, FasesUncheckedUpdateManyInput>
    /**
     * Filter which Fases to update
     */
    where?: FasesWhereInput
    /**
     * Limit how many Fases to update.
     */
    limit?: number
  }

  /**
   * Fases upsert
   */
  export type FasesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * The filter to search for the Fases to update in case it exists.
     */
    where: FasesWhereUniqueInput
    /**
     * In case the Fases found by the `where` argument doesn't exist, create a new Fases with this data.
     */
    create: XOR<FasesCreateInput, FasesUncheckedCreateInput>
    /**
     * In case the Fases was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FasesUpdateInput, FasesUncheckedUpdateInput>
  }

  /**
   * Fases delete
   */
  export type FasesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
    /**
     * Filter which Fases to delete.
     */
    where: FasesWhereUniqueInput
  }

  /**
   * Fases deleteMany
   */
  export type FasesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fases to delete
     */
    where?: FasesWhereInput
    /**
     * Limit how many Fases to delete.
     */
    limit?: number
  }

  /**
   * Fases.evaluaciones
   */
  export type Fases$evaluacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    where?: EvaluacionesWhereInput
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    cursor?: EvaluacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluacionesScalarFieldEnum | EvaluacionesScalarFieldEnum[]
  }

  /**
   * Fases without action
   */
  export type FasesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fases
     */
    select?: FasesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Fases
     */
    omit?: FasesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FasesInclude<ExtArgs> | null
  }


  /**
   * Model Logs
   */

  export type AggregateLogs = {
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  export type LogsAvgAggregateOutputType = {
    id: number | null
    entidad_id: number | null
    usuario_id: number | null
  }

  export type LogsSumAggregateOutputType = {
    id: number | null
    entidad_id: number | null
    usuario_id: number | null
  }

  export type LogsMinAggregateOutputType = {
    id: number | null
    entidad: string | null
    entidad_id: number | null
    campo: string | null
    valor_anterior: string | null
    valor_nuevo: string | null
    usuario_id: number | null
    fecha_cambio: Date | null
    motivo: string | null
  }

  export type LogsMaxAggregateOutputType = {
    id: number | null
    entidad: string | null
    entidad_id: number | null
    campo: string | null
    valor_anterior: string | null
    valor_nuevo: string | null
    usuario_id: number | null
    fecha_cambio: Date | null
    motivo: string | null
  }

  export type LogsCountAggregateOutputType = {
    id: number
    entidad: number
    entidad_id: number
    campo: number
    valor_anterior: number
    valor_nuevo: number
    usuario_id: number
    fecha_cambio: number
    motivo: number
    _all: number
  }


  export type LogsAvgAggregateInputType = {
    id?: true
    entidad_id?: true
    usuario_id?: true
  }

  export type LogsSumAggregateInputType = {
    id?: true
    entidad_id?: true
    usuario_id?: true
  }

  export type LogsMinAggregateInputType = {
    id?: true
    entidad?: true
    entidad_id?: true
    campo?: true
    valor_anterior?: true
    valor_nuevo?: true
    usuario_id?: true
    fecha_cambio?: true
    motivo?: true
  }

  export type LogsMaxAggregateInputType = {
    id?: true
    entidad?: true
    entidad_id?: true
    campo?: true
    valor_anterior?: true
    valor_nuevo?: true
    usuario_id?: true
    fecha_cambio?: true
    motivo?: true
  }

  export type LogsCountAggregateInputType = {
    id?: true
    entidad?: true
    entidad_id?: true
    campo?: true
    valor_anterior?: true
    valor_nuevo?: true
    usuario_id?: true
    fecha_cambio?: true
    motivo?: true
    _all?: true
  }

  export type LogsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to aggregate.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Logs
    **/
    _count?: true | LogsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LogsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LogsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogsMaxAggregateInputType
  }

  export type GetLogsAggregateType<T extends LogsAggregateArgs> = {
        [P in keyof T & keyof AggregateLogs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLogs[P]>
      : GetScalarType<T[P], AggregateLogs[P]>
  }




  export type LogsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithAggregationInput | LogsOrderByWithAggregationInput[]
    by: LogsScalarFieldEnum[] | LogsScalarFieldEnum
    having?: LogsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogsCountAggregateInputType | true
    _avg?: LogsAvgAggregateInputType
    _sum?: LogsSumAggregateInputType
    _min?: LogsMinAggregateInputType
    _max?: LogsMaxAggregateInputType
  }

  export type LogsGroupByOutputType = {
    id: number
    entidad: string
    entidad_id: number | null
    campo: string | null
    valor_anterior: string | null
    valor_nuevo: string | null
    usuario_id: number
    fecha_cambio: Date | null
    motivo: string | null
    _count: LogsCountAggregateOutputType | null
    _avg: LogsAvgAggregateOutputType | null
    _sum: LogsSumAggregateOutputType | null
    _min: LogsMinAggregateOutputType | null
    _max: LogsMaxAggregateOutputType | null
  }

  type GetLogsGroupByPayload<T extends LogsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LogsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogsGroupByOutputType[P]>
            : GetScalarType<T[P], LogsGroupByOutputType[P]>
        }
      >
    >


  export type LogsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entidad?: boolean
    entidad_id?: boolean
    campo?: boolean
    valor_anterior?: boolean
    valor_nuevo?: boolean
    usuario_id?: boolean
    fecha_cambio?: boolean
    motivo?: boolean
    usuario?: boolean | Logs$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entidad?: boolean
    entidad_id?: boolean
    campo?: boolean
    valor_anterior?: boolean
    valor_nuevo?: boolean
    usuario_id?: boolean
    fecha_cambio?: boolean
    motivo?: boolean
    usuario?: boolean | Logs$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    entidad?: boolean
    entidad_id?: boolean
    campo?: boolean
    valor_anterior?: boolean
    valor_nuevo?: boolean
    usuario_id?: boolean
    fecha_cambio?: boolean
    motivo?: boolean
    usuario?: boolean | Logs$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["logs"]>

  export type LogsSelectScalar = {
    id?: boolean
    entidad?: boolean
    entidad_id?: boolean
    campo?: boolean
    valor_anterior?: boolean
    valor_nuevo?: boolean
    usuario_id?: boolean
    fecha_cambio?: boolean
    motivo?: boolean
  }

  export type LogsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "entidad" | "entidad_id" | "campo" | "valor_anterior" | "valor_nuevo" | "usuario_id" | "fecha_cambio" | "motivo", ExtArgs["result"]["logs"]>
  export type LogsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Logs$usuarioArgs<ExtArgs>
  }
  export type LogsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Logs$usuarioArgs<ExtArgs>
  }
  export type LogsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | Logs$usuarioArgs<ExtArgs>
  }

  export type $LogsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Logs"
    objects: {
      usuario: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      entidad: string
      entidad_id: number | null
      campo: string | null
      valor_anterior: string | null
      valor_nuevo: string | null
      usuario_id: number
      fecha_cambio: Date | null
      motivo: string | null
    }, ExtArgs["result"]["logs"]>
    composites: {}
  }

  type LogsGetPayload<S extends boolean | null | undefined | LogsDefaultArgs> = $Result.GetResult<Prisma.$LogsPayload, S>

  type LogsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LogsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LogsCountAggregateInputType | true
    }

  export interface LogsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Logs'], meta: { name: 'Logs' } }
    /**
     * Find zero or one Logs that matches the filter.
     * @param {LogsFindUniqueArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LogsFindUniqueArgs>(args: SelectSubset<T, LogsFindUniqueArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LogsFindUniqueOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LogsFindUniqueOrThrowArgs>(args: SelectSubset<T, LogsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LogsFindFirstArgs>(args?: SelectSubset<T, LogsFindFirstArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindFirstOrThrowArgs} args - Arguments to find a Logs
     * @example
     * // Get one Logs
     * const logs = await prisma.logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LogsFindFirstOrThrowArgs>(args?: SelectSubset<T, LogsFindFirstOrThrowArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.logs.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logsWithIdOnly = await prisma.logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LogsFindManyArgs>(args?: SelectSubset<T, LogsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Logs.
     * @param {LogsCreateArgs} args - Arguments to create a Logs.
     * @example
     * // Create one Logs
     * const Logs = await prisma.logs.create({
     *   data: {
     *     // ... data to create a Logs
     *   }
     * })
     * 
     */
    create<T extends LogsCreateArgs>(args: SelectSubset<T, LogsCreateArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Logs.
     * @param {LogsCreateManyArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LogsCreateManyArgs>(args?: SelectSubset<T, LogsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Logs and returns the data saved in the database.
     * @param {LogsCreateManyAndReturnArgs} args - Arguments to create many Logs.
     * @example
     * // Create many Logs
     * const logs = await prisma.logs.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Logs and only return the `id`
     * const logsWithIdOnly = await prisma.logs.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LogsCreateManyAndReturnArgs>(args?: SelectSubset<T, LogsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Logs.
     * @param {LogsDeleteArgs} args - Arguments to delete one Logs.
     * @example
     * // Delete one Logs
     * const Logs = await prisma.logs.delete({
     *   where: {
     *     // ... filter to delete one Logs
     *   }
     * })
     * 
     */
    delete<T extends LogsDeleteArgs>(args: SelectSubset<T, LogsDeleteArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Logs.
     * @param {LogsUpdateArgs} args - Arguments to update one Logs.
     * @example
     * // Update one Logs
     * const logs = await prisma.logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LogsUpdateArgs>(args: SelectSubset<T, LogsUpdateArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Logs.
     * @param {LogsDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LogsDeleteManyArgs>(args?: SelectSubset<T, LogsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LogsUpdateManyArgs>(args: SelectSubset<T, LogsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs and returns the data updated in the database.
     * @param {LogsUpdateManyAndReturnArgs} args - Arguments to update many Logs.
     * @example
     * // Update many Logs
     * const logs = await prisma.logs.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Logs and only return the `id`
     * const logsWithIdOnly = await prisma.logs.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LogsUpdateManyAndReturnArgs>(args: SelectSubset<T, LogsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Logs.
     * @param {LogsUpsertArgs} args - Arguments to update or create a Logs.
     * @example
     * // Update or create a Logs
     * const logs = await prisma.logs.upsert({
     *   create: {
     *     // ... data to create a Logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Logs we want to update
     *   }
     * })
     */
    upsert<T extends LogsUpsertArgs>(args: SelectSubset<T, LogsUpsertArgs<ExtArgs>>): Prisma__LogsClient<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.logs.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends LogsCountArgs>(
      args?: Subset<T, LogsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogsAggregateArgs>(args: Subset<T, LogsAggregateArgs>): Prisma.PrismaPromise<GetLogsAggregateType<T>>

    /**
     * Group by Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogsGroupByArgs['orderBy'] }
        : { orderBy?: LogsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Logs model
   */
  readonly fields: LogsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LogsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends Logs$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, Logs$usuarioArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Logs model
   */
  interface LogsFieldRefs {
    readonly id: FieldRef<"Logs", 'Int'>
    readonly entidad: FieldRef<"Logs", 'String'>
    readonly entidad_id: FieldRef<"Logs", 'Int'>
    readonly campo: FieldRef<"Logs", 'String'>
    readonly valor_anterior: FieldRef<"Logs", 'String'>
    readonly valor_nuevo: FieldRef<"Logs", 'String'>
    readonly usuario_id: FieldRef<"Logs", 'Int'>
    readonly fecha_cambio: FieldRef<"Logs", 'DateTime'>
    readonly motivo: FieldRef<"Logs", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Logs findUnique
   */
  export type LogsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findUniqueOrThrow
   */
  export type LogsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs findFirst
   */
  export type LogsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs findFirstOrThrow
   */
  export type LogsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Logs.
     */
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs findMany
   */
  export type LogsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter, which Logs to fetch.
     */
    where?: LogsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Logs to fetch.
     */
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Logs.
     */
    cursor?: LogsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Logs.
     */
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Logs create
   */
  export type LogsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to create a Logs.
     */
    data: XOR<LogsCreateInput, LogsUncheckedCreateInput>
  }

  /**
   * Logs createMany
   */
  export type LogsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Logs createManyAndReturn
   */
  export type LogsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * The data used to create many Logs.
     */
    data: LogsCreateManyInput | LogsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Logs update
   */
  export type LogsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The data needed to update a Logs.
     */
    data: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
    /**
     * Choose, which Logs to update.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs updateMany
   */
  export type LogsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
  }

  /**
   * Logs updateManyAndReturn
   */
  export type LogsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * The data used to update Logs.
     */
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyInput>
    /**
     * Filter which Logs to update
     */
    where?: LogsWhereInput
    /**
     * Limit how many Logs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Logs upsert
   */
  export type LogsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * The filter to search for the Logs to update in case it exists.
     */
    where: LogsWhereUniqueInput
    /**
     * In case the Logs found by the `where` argument doesn't exist, create a new Logs with this data.
     */
    create: XOR<LogsCreateInput, LogsUncheckedCreateInput>
    /**
     * In case the Logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LogsUpdateInput, LogsUncheckedUpdateInput>
  }

  /**
   * Logs delete
   */
  export type LogsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    /**
     * Filter which Logs to delete.
     */
    where: LogsWhereUniqueInput
  }

  /**
   * Logs deleteMany
   */
  export type LogsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Logs to delete
     */
    where?: LogsWhereInput
    /**
     * Limit how many Logs to delete.
     */
    limit?: number
  }

  /**
   * Logs.usuario
   */
  export type Logs$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }

  /**
   * Logs without action
   */
  export type LogsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
  }


  /**
   * Model MiembrosEquipo
   */

  export type AggregateMiembrosEquipo = {
    _count: MiembrosEquipoCountAggregateOutputType | null
    _avg: MiembrosEquipoAvgAggregateOutputType | null
    _sum: MiembrosEquipoSumAggregateOutputType | null
    _min: MiembrosEquipoMinAggregateOutputType | null
    _max: MiembrosEquipoMaxAggregateOutputType | null
  }

  export type MiembrosEquipoAvgAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
  }

  export type MiembrosEquipoSumAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
  }

  export type MiembrosEquipoMinAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
    nombre_equipo: string | null
    rol_en_equipo: $Enums.RolEquipo | null
  }

  export type MiembrosEquipoMaxAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
    nombre_equipo: string | null
    rol_en_equipo: $Enums.RolEquipo | null
  }

  export type MiembrosEquipoCountAggregateOutputType = {
    id: number
    olimpista_id: number
    nombre_equipo: number
    rol_en_equipo: number
    _all: number
  }


  export type MiembrosEquipoAvgAggregateInputType = {
    id?: true
    olimpista_id?: true
  }

  export type MiembrosEquipoSumAggregateInputType = {
    id?: true
    olimpista_id?: true
  }

  export type MiembrosEquipoMinAggregateInputType = {
    id?: true
    olimpista_id?: true
    nombre_equipo?: true
    rol_en_equipo?: true
  }

  export type MiembrosEquipoMaxAggregateInputType = {
    id?: true
    olimpista_id?: true
    nombre_equipo?: true
    rol_en_equipo?: true
  }

  export type MiembrosEquipoCountAggregateInputType = {
    id?: true
    olimpista_id?: true
    nombre_equipo?: true
    rol_en_equipo?: true
    _all?: true
  }

  export type MiembrosEquipoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MiembrosEquipo to aggregate.
     */
    where?: MiembrosEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiembrosEquipos to fetch.
     */
    orderBy?: MiembrosEquipoOrderByWithRelationInput | MiembrosEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MiembrosEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiembrosEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiembrosEquipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MiembrosEquipos
    **/
    _count?: true | MiembrosEquipoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MiembrosEquipoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MiembrosEquipoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MiembrosEquipoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MiembrosEquipoMaxAggregateInputType
  }

  export type GetMiembrosEquipoAggregateType<T extends MiembrosEquipoAggregateArgs> = {
        [P in keyof T & keyof AggregateMiembrosEquipo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMiembrosEquipo[P]>
      : GetScalarType<T[P], AggregateMiembrosEquipo[P]>
  }




  export type MiembrosEquipoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MiembrosEquipoWhereInput
    orderBy?: MiembrosEquipoOrderByWithAggregationInput | MiembrosEquipoOrderByWithAggregationInput[]
    by: MiembrosEquipoScalarFieldEnum[] | MiembrosEquipoScalarFieldEnum
    having?: MiembrosEquipoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MiembrosEquipoCountAggregateInputType | true
    _avg?: MiembrosEquipoAvgAggregateInputType
    _sum?: MiembrosEquipoSumAggregateInputType
    _min?: MiembrosEquipoMinAggregateInputType
    _max?: MiembrosEquipoMaxAggregateInputType
  }

  export type MiembrosEquipoGroupByOutputType = {
    id: number
    olimpista_id: number
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
    _count: MiembrosEquipoCountAggregateOutputType | null
    _avg: MiembrosEquipoAvgAggregateOutputType | null
    _sum: MiembrosEquipoSumAggregateOutputType | null
    _min: MiembrosEquipoMinAggregateOutputType | null
    _max: MiembrosEquipoMaxAggregateOutputType | null
  }

  type GetMiembrosEquipoGroupByPayload<T extends MiembrosEquipoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MiembrosEquipoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MiembrosEquipoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MiembrosEquipoGroupByOutputType[P]>
            : GetScalarType<T[P], MiembrosEquipoGroupByOutputType[P]>
        }
      >
    >


  export type MiembrosEquipoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    olimpista_id?: boolean
    nombre_equipo?: boolean
    rol_en_equipo?: boolean
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miembrosEquipo"]>

  export type MiembrosEquipoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    olimpista_id?: boolean
    nombre_equipo?: boolean
    rol_en_equipo?: boolean
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miembrosEquipo"]>

  export type MiembrosEquipoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    olimpista_id?: boolean
    nombre_equipo?: boolean
    rol_en_equipo?: boolean
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["miembrosEquipo"]>

  export type MiembrosEquipoSelectScalar = {
    id?: boolean
    olimpista_id?: boolean
    nombre_equipo?: boolean
    rol_en_equipo?: boolean
  }

  export type MiembrosEquipoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "olimpista_id" | "nombre_equipo" | "rol_en_equipo", ExtArgs["result"]["miembrosEquipo"]>
  export type MiembrosEquipoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
  }
  export type MiembrosEquipoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
  }
  export type MiembrosEquipoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
  }

  export type $MiembrosEquipoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MiembrosEquipo"
    objects: {
      olimpista: Prisma.$OlimpistasPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      olimpista_id: number
      nombre_equipo: string
      rol_en_equipo: $Enums.RolEquipo
    }, ExtArgs["result"]["miembrosEquipo"]>
    composites: {}
  }

  type MiembrosEquipoGetPayload<S extends boolean | null | undefined | MiembrosEquipoDefaultArgs> = $Result.GetResult<Prisma.$MiembrosEquipoPayload, S>

  type MiembrosEquipoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MiembrosEquipoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MiembrosEquipoCountAggregateInputType | true
    }

  export interface MiembrosEquipoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MiembrosEquipo'], meta: { name: 'MiembrosEquipo' } }
    /**
     * Find zero or one MiembrosEquipo that matches the filter.
     * @param {MiembrosEquipoFindUniqueArgs} args - Arguments to find a MiembrosEquipo
     * @example
     * // Get one MiembrosEquipo
     * const miembrosEquipo = await prisma.miembrosEquipo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MiembrosEquipoFindUniqueArgs>(args: SelectSubset<T, MiembrosEquipoFindUniqueArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MiembrosEquipo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MiembrosEquipoFindUniqueOrThrowArgs} args - Arguments to find a MiembrosEquipo
     * @example
     * // Get one MiembrosEquipo
     * const miembrosEquipo = await prisma.miembrosEquipo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MiembrosEquipoFindUniqueOrThrowArgs>(args: SelectSubset<T, MiembrosEquipoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MiembrosEquipo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoFindFirstArgs} args - Arguments to find a MiembrosEquipo
     * @example
     * // Get one MiembrosEquipo
     * const miembrosEquipo = await prisma.miembrosEquipo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MiembrosEquipoFindFirstArgs>(args?: SelectSubset<T, MiembrosEquipoFindFirstArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MiembrosEquipo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoFindFirstOrThrowArgs} args - Arguments to find a MiembrosEquipo
     * @example
     * // Get one MiembrosEquipo
     * const miembrosEquipo = await prisma.miembrosEquipo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MiembrosEquipoFindFirstOrThrowArgs>(args?: SelectSubset<T, MiembrosEquipoFindFirstOrThrowArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MiembrosEquipos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MiembrosEquipos
     * const miembrosEquipos = await prisma.miembrosEquipo.findMany()
     * 
     * // Get first 10 MiembrosEquipos
     * const miembrosEquipos = await prisma.miembrosEquipo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const miembrosEquipoWithIdOnly = await prisma.miembrosEquipo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MiembrosEquipoFindManyArgs>(args?: SelectSubset<T, MiembrosEquipoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MiembrosEquipo.
     * @param {MiembrosEquipoCreateArgs} args - Arguments to create a MiembrosEquipo.
     * @example
     * // Create one MiembrosEquipo
     * const MiembrosEquipo = await prisma.miembrosEquipo.create({
     *   data: {
     *     // ... data to create a MiembrosEquipo
     *   }
     * })
     * 
     */
    create<T extends MiembrosEquipoCreateArgs>(args: SelectSubset<T, MiembrosEquipoCreateArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MiembrosEquipos.
     * @param {MiembrosEquipoCreateManyArgs} args - Arguments to create many MiembrosEquipos.
     * @example
     * // Create many MiembrosEquipos
     * const miembrosEquipo = await prisma.miembrosEquipo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MiembrosEquipoCreateManyArgs>(args?: SelectSubset<T, MiembrosEquipoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MiembrosEquipos and returns the data saved in the database.
     * @param {MiembrosEquipoCreateManyAndReturnArgs} args - Arguments to create many MiembrosEquipos.
     * @example
     * // Create many MiembrosEquipos
     * const miembrosEquipo = await prisma.miembrosEquipo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MiembrosEquipos and only return the `id`
     * const miembrosEquipoWithIdOnly = await prisma.miembrosEquipo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MiembrosEquipoCreateManyAndReturnArgs>(args?: SelectSubset<T, MiembrosEquipoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MiembrosEquipo.
     * @param {MiembrosEquipoDeleteArgs} args - Arguments to delete one MiembrosEquipo.
     * @example
     * // Delete one MiembrosEquipo
     * const MiembrosEquipo = await prisma.miembrosEquipo.delete({
     *   where: {
     *     // ... filter to delete one MiembrosEquipo
     *   }
     * })
     * 
     */
    delete<T extends MiembrosEquipoDeleteArgs>(args: SelectSubset<T, MiembrosEquipoDeleteArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MiembrosEquipo.
     * @param {MiembrosEquipoUpdateArgs} args - Arguments to update one MiembrosEquipo.
     * @example
     * // Update one MiembrosEquipo
     * const miembrosEquipo = await prisma.miembrosEquipo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MiembrosEquipoUpdateArgs>(args: SelectSubset<T, MiembrosEquipoUpdateArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MiembrosEquipos.
     * @param {MiembrosEquipoDeleteManyArgs} args - Arguments to filter MiembrosEquipos to delete.
     * @example
     * // Delete a few MiembrosEquipos
     * const { count } = await prisma.miembrosEquipo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MiembrosEquipoDeleteManyArgs>(args?: SelectSubset<T, MiembrosEquipoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MiembrosEquipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MiembrosEquipos
     * const miembrosEquipo = await prisma.miembrosEquipo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MiembrosEquipoUpdateManyArgs>(args: SelectSubset<T, MiembrosEquipoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MiembrosEquipos and returns the data updated in the database.
     * @param {MiembrosEquipoUpdateManyAndReturnArgs} args - Arguments to update many MiembrosEquipos.
     * @example
     * // Update many MiembrosEquipos
     * const miembrosEquipo = await prisma.miembrosEquipo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MiembrosEquipos and only return the `id`
     * const miembrosEquipoWithIdOnly = await prisma.miembrosEquipo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MiembrosEquipoUpdateManyAndReturnArgs>(args: SelectSubset<T, MiembrosEquipoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MiembrosEquipo.
     * @param {MiembrosEquipoUpsertArgs} args - Arguments to update or create a MiembrosEquipo.
     * @example
     * // Update or create a MiembrosEquipo
     * const miembrosEquipo = await prisma.miembrosEquipo.upsert({
     *   create: {
     *     // ... data to create a MiembrosEquipo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MiembrosEquipo we want to update
     *   }
     * })
     */
    upsert<T extends MiembrosEquipoUpsertArgs>(args: SelectSubset<T, MiembrosEquipoUpsertArgs<ExtArgs>>): Prisma__MiembrosEquipoClient<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MiembrosEquipos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoCountArgs} args - Arguments to filter MiembrosEquipos to count.
     * @example
     * // Count the number of MiembrosEquipos
     * const count = await prisma.miembrosEquipo.count({
     *   where: {
     *     // ... the filter for the MiembrosEquipos we want to count
     *   }
     * })
    **/
    count<T extends MiembrosEquipoCountArgs>(
      args?: Subset<T, MiembrosEquipoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MiembrosEquipoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MiembrosEquipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MiembrosEquipoAggregateArgs>(args: Subset<T, MiembrosEquipoAggregateArgs>): Prisma.PrismaPromise<GetMiembrosEquipoAggregateType<T>>

    /**
     * Group by MiembrosEquipo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MiembrosEquipoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MiembrosEquipoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MiembrosEquipoGroupByArgs['orderBy'] }
        : { orderBy?: MiembrosEquipoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MiembrosEquipoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMiembrosEquipoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MiembrosEquipo model
   */
  readonly fields: MiembrosEquipoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MiembrosEquipo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MiembrosEquipoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    olimpista<T extends OlimpistasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OlimpistasDefaultArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MiembrosEquipo model
   */
  interface MiembrosEquipoFieldRefs {
    readonly id: FieldRef<"MiembrosEquipo", 'Int'>
    readonly olimpista_id: FieldRef<"MiembrosEquipo", 'Int'>
    readonly nombre_equipo: FieldRef<"MiembrosEquipo", 'String'>
    readonly rol_en_equipo: FieldRef<"MiembrosEquipo", 'RolEquipo'>
  }
    

  // Custom InputTypes
  /**
   * MiembrosEquipo findUnique
   */
  export type MiembrosEquipoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * Filter, which MiembrosEquipo to fetch.
     */
    where: MiembrosEquipoWhereUniqueInput
  }

  /**
   * MiembrosEquipo findUniqueOrThrow
   */
  export type MiembrosEquipoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * Filter, which MiembrosEquipo to fetch.
     */
    where: MiembrosEquipoWhereUniqueInput
  }

  /**
   * MiembrosEquipo findFirst
   */
  export type MiembrosEquipoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * Filter, which MiembrosEquipo to fetch.
     */
    where?: MiembrosEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiembrosEquipos to fetch.
     */
    orderBy?: MiembrosEquipoOrderByWithRelationInput | MiembrosEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MiembrosEquipos.
     */
    cursor?: MiembrosEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiembrosEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiembrosEquipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MiembrosEquipos.
     */
    distinct?: MiembrosEquipoScalarFieldEnum | MiembrosEquipoScalarFieldEnum[]
  }

  /**
   * MiembrosEquipo findFirstOrThrow
   */
  export type MiembrosEquipoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * Filter, which MiembrosEquipo to fetch.
     */
    where?: MiembrosEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiembrosEquipos to fetch.
     */
    orderBy?: MiembrosEquipoOrderByWithRelationInput | MiembrosEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MiembrosEquipos.
     */
    cursor?: MiembrosEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiembrosEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiembrosEquipos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MiembrosEquipos.
     */
    distinct?: MiembrosEquipoScalarFieldEnum | MiembrosEquipoScalarFieldEnum[]
  }

  /**
   * MiembrosEquipo findMany
   */
  export type MiembrosEquipoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * Filter, which MiembrosEquipos to fetch.
     */
    where?: MiembrosEquipoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MiembrosEquipos to fetch.
     */
    orderBy?: MiembrosEquipoOrderByWithRelationInput | MiembrosEquipoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MiembrosEquipos.
     */
    cursor?: MiembrosEquipoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MiembrosEquipos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MiembrosEquipos.
     */
    skip?: number
    distinct?: MiembrosEquipoScalarFieldEnum | MiembrosEquipoScalarFieldEnum[]
  }

  /**
   * MiembrosEquipo create
   */
  export type MiembrosEquipoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * The data needed to create a MiembrosEquipo.
     */
    data: XOR<MiembrosEquipoCreateInput, MiembrosEquipoUncheckedCreateInput>
  }

  /**
   * MiembrosEquipo createMany
   */
  export type MiembrosEquipoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MiembrosEquipos.
     */
    data: MiembrosEquipoCreateManyInput | MiembrosEquipoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MiembrosEquipo createManyAndReturn
   */
  export type MiembrosEquipoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * The data used to create many MiembrosEquipos.
     */
    data: MiembrosEquipoCreateManyInput | MiembrosEquipoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MiembrosEquipo update
   */
  export type MiembrosEquipoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * The data needed to update a MiembrosEquipo.
     */
    data: XOR<MiembrosEquipoUpdateInput, MiembrosEquipoUncheckedUpdateInput>
    /**
     * Choose, which MiembrosEquipo to update.
     */
    where: MiembrosEquipoWhereUniqueInput
  }

  /**
   * MiembrosEquipo updateMany
   */
  export type MiembrosEquipoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MiembrosEquipos.
     */
    data: XOR<MiembrosEquipoUpdateManyMutationInput, MiembrosEquipoUncheckedUpdateManyInput>
    /**
     * Filter which MiembrosEquipos to update
     */
    where?: MiembrosEquipoWhereInput
    /**
     * Limit how many MiembrosEquipos to update.
     */
    limit?: number
  }

  /**
   * MiembrosEquipo updateManyAndReturn
   */
  export type MiembrosEquipoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * The data used to update MiembrosEquipos.
     */
    data: XOR<MiembrosEquipoUpdateManyMutationInput, MiembrosEquipoUncheckedUpdateManyInput>
    /**
     * Filter which MiembrosEquipos to update
     */
    where?: MiembrosEquipoWhereInput
    /**
     * Limit how many MiembrosEquipos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MiembrosEquipo upsert
   */
  export type MiembrosEquipoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * The filter to search for the MiembrosEquipo to update in case it exists.
     */
    where: MiembrosEquipoWhereUniqueInput
    /**
     * In case the MiembrosEquipo found by the `where` argument doesn't exist, create a new MiembrosEquipo with this data.
     */
    create: XOR<MiembrosEquipoCreateInput, MiembrosEquipoUncheckedCreateInput>
    /**
     * In case the MiembrosEquipo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MiembrosEquipoUpdateInput, MiembrosEquipoUncheckedUpdateInput>
  }

  /**
   * MiembrosEquipo delete
   */
  export type MiembrosEquipoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    /**
     * Filter which MiembrosEquipo to delete.
     */
    where: MiembrosEquipoWhereUniqueInput
  }

  /**
   * MiembrosEquipo deleteMany
   */
  export type MiembrosEquipoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MiembrosEquipos to delete
     */
    where?: MiembrosEquipoWhereInput
    /**
     * Limit how many MiembrosEquipos to delete.
     */
    limit?: number
  }

  /**
   * MiembrosEquipo without action
   */
  export type MiembrosEquipoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
  }


  /**
   * Model Niveles
   */

  export type AggregateNiveles = {
    _count: NivelesCountAggregateOutputType | null
    _avg: NivelesAvgAggregateOutputType | null
    _sum: NivelesSumAggregateOutputType | null
    _min: NivelesMinAggregateOutputType | null
    _max: NivelesMaxAggregateOutputType | null
  }

  export type NivelesAvgAggregateOutputType = {
    id: number | null
  }

  export type NivelesSumAggregateOutputType = {
    id: number | null
  }

  export type NivelesMinAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    estado: boolean | null
  }

  export type NivelesMaxAggregateOutputType = {
    id: number | null
    codigo: string | null
    nombre: string | null
    descripcion: string | null
    estado: boolean | null
  }

  export type NivelesCountAggregateOutputType = {
    id: number
    codigo: number
    nombre: number
    descripcion: number
    estado: number
    _all: number
  }


  export type NivelesAvgAggregateInputType = {
    id?: true
  }

  export type NivelesSumAggregateInputType = {
    id?: true
  }

  export type NivelesMinAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    estado?: true
  }

  export type NivelesMaxAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    estado?: true
  }

  export type NivelesCountAggregateInputType = {
    id?: true
    codigo?: true
    nombre?: true
    descripcion?: true
    estado?: true
    _all?: true
  }

  export type NivelesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Niveles to aggregate.
     */
    where?: NivelesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveles to fetch.
     */
    orderBy?: NivelesOrderByWithRelationInput | NivelesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NivelesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Niveles
    **/
    _count?: true | NivelesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NivelesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NivelesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NivelesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NivelesMaxAggregateInputType
  }

  export type GetNivelesAggregateType<T extends NivelesAggregateArgs> = {
        [P in keyof T & keyof AggregateNiveles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNiveles[P]>
      : GetScalarType<T[P], AggregateNiveles[P]>
  }




  export type NivelesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NivelesWhereInput
    orderBy?: NivelesOrderByWithAggregationInput | NivelesOrderByWithAggregationInput[]
    by: NivelesScalarFieldEnum[] | NivelesScalarFieldEnum
    having?: NivelesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NivelesCountAggregateInputType | true
    _avg?: NivelesAvgAggregateInputType
    _sum?: NivelesSumAggregateInputType
    _min?: NivelesMinAggregateInputType
    _max?: NivelesMaxAggregateInputType
  }

  export type NivelesGroupByOutputType = {
    id: number
    codigo: string | null
    nombre: string
    descripcion: string | null
    estado: boolean
    _count: NivelesCountAggregateOutputType | null
    _avg: NivelesAvgAggregateOutputType | null
    _sum: NivelesSumAggregateOutputType | null
    _min: NivelesMinAggregateOutputType | null
    _max: NivelesMaxAggregateOutputType | null
  }

  type GetNivelesGroupByPayload<T extends NivelesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NivelesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NivelesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NivelesGroupByOutputType[P]>
            : GetScalarType<T[P], NivelesGroupByOutputType[P]>
        }
      >
    >


  export type NivelesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
    participacion?: boolean | Niveles$participacionArgs<ExtArgs>
    ConfigMedallas?: boolean | Niveles$ConfigMedallasArgs<ExtArgs>
    _count?: boolean | NivelesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["niveles"]>

  export type NivelesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
  }, ExtArgs["result"]["niveles"]>

  export type NivelesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
  }, ExtArgs["result"]["niveles"]>

  export type NivelesSelectScalar = {
    id?: boolean
    codigo?: boolean
    nombre?: boolean
    descripcion?: boolean
    estado?: boolean
  }

  export type NivelesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "codigo" | "nombre" | "descripcion" | "estado", ExtArgs["result"]["niveles"]>
  export type NivelesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participacion?: boolean | Niveles$participacionArgs<ExtArgs>
    ConfigMedallas?: boolean | Niveles$ConfigMedallasArgs<ExtArgs>
    _count?: boolean | NivelesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NivelesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type NivelesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $NivelesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Niveles"
    objects: {
      participacion: Prisma.$ParticipacionPayload<ExtArgs>[]
      ConfigMedallas: Prisma.$ConfigMedallasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      codigo: string | null
      nombre: string
      descripcion: string | null
      estado: boolean
    }, ExtArgs["result"]["niveles"]>
    composites: {}
  }

  type NivelesGetPayload<S extends boolean | null | undefined | NivelesDefaultArgs> = $Result.GetResult<Prisma.$NivelesPayload, S>

  type NivelesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NivelesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NivelesCountAggregateInputType | true
    }

  export interface NivelesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Niveles'], meta: { name: 'Niveles' } }
    /**
     * Find zero or one Niveles that matches the filter.
     * @param {NivelesFindUniqueArgs} args - Arguments to find a Niveles
     * @example
     * // Get one Niveles
     * const niveles = await prisma.niveles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NivelesFindUniqueArgs>(args: SelectSubset<T, NivelesFindUniqueArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Niveles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NivelesFindUniqueOrThrowArgs} args - Arguments to find a Niveles
     * @example
     * // Get one Niveles
     * const niveles = await prisma.niveles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NivelesFindUniqueOrThrowArgs>(args: SelectSubset<T, NivelesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Niveles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesFindFirstArgs} args - Arguments to find a Niveles
     * @example
     * // Get one Niveles
     * const niveles = await prisma.niveles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NivelesFindFirstArgs>(args?: SelectSubset<T, NivelesFindFirstArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Niveles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesFindFirstOrThrowArgs} args - Arguments to find a Niveles
     * @example
     * // Get one Niveles
     * const niveles = await prisma.niveles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NivelesFindFirstOrThrowArgs>(args?: SelectSubset<T, NivelesFindFirstOrThrowArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Niveles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Niveles
     * const niveles = await prisma.niveles.findMany()
     * 
     * // Get first 10 Niveles
     * const niveles = await prisma.niveles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nivelesWithIdOnly = await prisma.niveles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NivelesFindManyArgs>(args?: SelectSubset<T, NivelesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Niveles.
     * @param {NivelesCreateArgs} args - Arguments to create a Niveles.
     * @example
     * // Create one Niveles
     * const Niveles = await prisma.niveles.create({
     *   data: {
     *     // ... data to create a Niveles
     *   }
     * })
     * 
     */
    create<T extends NivelesCreateArgs>(args: SelectSubset<T, NivelesCreateArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Niveles.
     * @param {NivelesCreateManyArgs} args - Arguments to create many Niveles.
     * @example
     * // Create many Niveles
     * const niveles = await prisma.niveles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NivelesCreateManyArgs>(args?: SelectSubset<T, NivelesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Niveles and returns the data saved in the database.
     * @param {NivelesCreateManyAndReturnArgs} args - Arguments to create many Niveles.
     * @example
     * // Create many Niveles
     * const niveles = await prisma.niveles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Niveles and only return the `id`
     * const nivelesWithIdOnly = await prisma.niveles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NivelesCreateManyAndReturnArgs>(args?: SelectSubset<T, NivelesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Niveles.
     * @param {NivelesDeleteArgs} args - Arguments to delete one Niveles.
     * @example
     * // Delete one Niveles
     * const Niveles = await prisma.niveles.delete({
     *   where: {
     *     // ... filter to delete one Niveles
     *   }
     * })
     * 
     */
    delete<T extends NivelesDeleteArgs>(args: SelectSubset<T, NivelesDeleteArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Niveles.
     * @param {NivelesUpdateArgs} args - Arguments to update one Niveles.
     * @example
     * // Update one Niveles
     * const niveles = await prisma.niveles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NivelesUpdateArgs>(args: SelectSubset<T, NivelesUpdateArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Niveles.
     * @param {NivelesDeleteManyArgs} args - Arguments to filter Niveles to delete.
     * @example
     * // Delete a few Niveles
     * const { count } = await prisma.niveles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NivelesDeleteManyArgs>(args?: SelectSubset<T, NivelesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Niveles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Niveles
     * const niveles = await prisma.niveles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NivelesUpdateManyArgs>(args: SelectSubset<T, NivelesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Niveles and returns the data updated in the database.
     * @param {NivelesUpdateManyAndReturnArgs} args - Arguments to update many Niveles.
     * @example
     * // Update many Niveles
     * const niveles = await prisma.niveles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Niveles and only return the `id`
     * const nivelesWithIdOnly = await prisma.niveles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NivelesUpdateManyAndReturnArgs>(args: SelectSubset<T, NivelesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Niveles.
     * @param {NivelesUpsertArgs} args - Arguments to update or create a Niveles.
     * @example
     * // Update or create a Niveles
     * const niveles = await prisma.niveles.upsert({
     *   create: {
     *     // ... data to create a Niveles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Niveles we want to update
     *   }
     * })
     */
    upsert<T extends NivelesUpsertArgs>(args: SelectSubset<T, NivelesUpsertArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Niveles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesCountArgs} args - Arguments to filter Niveles to count.
     * @example
     * // Count the number of Niveles
     * const count = await prisma.niveles.count({
     *   where: {
     *     // ... the filter for the Niveles we want to count
     *   }
     * })
    **/
    count<T extends NivelesCountArgs>(
      args?: Subset<T, NivelesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NivelesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Niveles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NivelesAggregateArgs>(args: Subset<T, NivelesAggregateArgs>): Prisma.PrismaPromise<GetNivelesAggregateType<T>>

    /**
     * Group by Niveles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NivelesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NivelesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NivelesGroupByArgs['orderBy'] }
        : { orderBy?: NivelesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NivelesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNivelesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Niveles model
   */
  readonly fields: NivelesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Niveles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NivelesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participacion<T extends Niveles$participacionArgs<ExtArgs> = {}>(args?: Subset<T, Niveles$participacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ConfigMedallas<T extends Niveles$ConfigMedallasArgs<ExtArgs> = {}>(args?: Subset<T, Niveles$ConfigMedallasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfigMedallasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Niveles model
   */
  interface NivelesFieldRefs {
    readonly id: FieldRef<"Niveles", 'Int'>
    readonly codigo: FieldRef<"Niveles", 'String'>
    readonly nombre: FieldRef<"Niveles", 'String'>
    readonly descripcion: FieldRef<"Niveles", 'String'>
    readonly estado: FieldRef<"Niveles", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Niveles findUnique
   */
  export type NivelesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * Filter, which Niveles to fetch.
     */
    where: NivelesWhereUniqueInput
  }

  /**
   * Niveles findUniqueOrThrow
   */
  export type NivelesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * Filter, which Niveles to fetch.
     */
    where: NivelesWhereUniqueInput
  }

  /**
   * Niveles findFirst
   */
  export type NivelesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * Filter, which Niveles to fetch.
     */
    where?: NivelesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveles to fetch.
     */
    orderBy?: NivelesOrderByWithRelationInput | NivelesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Niveles.
     */
    cursor?: NivelesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Niveles.
     */
    distinct?: NivelesScalarFieldEnum | NivelesScalarFieldEnum[]
  }

  /**
   * Niveles findFirstOrThrow
   */
  export type NivelesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * Filter, which Niveles to fetch.
     */
    where?: NivelesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveles to fetch.
     */
    orderBy?: NivelesOrderByWithRelationInput | NivelesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Niveles.
     */
    cursor?: NivelesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Niveles.
     */
    distinct?: NivelesScalarFieldEnum | NivelesScalarFieldEnum[]
  }

  /**
   * Niveles findMany
   */
  export type NivelesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * Filter, which Niveles to fetch.
     */
    where?: NivelesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Niveles to fetch.
     */
    orderBy?: NivelesOrderByWithRelationInput | NivelesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Niveles.
     */
    cursor?: NivelesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Niveles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Niveles.
     */
    skip?: number
    distinct?: NivelesScalarFieldEnum | NivelesScalarFieldEnum[]
  }

  /**
   * Niveles create
   */
  export type NivelesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * The data needed to create a Niveles.
     */
    data: XOR<NivelesCreateInput, NivelesUncheckedCreateInput>
  }

  /**
   * Niveles createMany
   */
  export type NivelesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Niveles.
     */
    data: NivelesCreateManyInput | NivelesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Niveles createManyAndReturn
   */
  export type NivelesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * The data used to create many Niveles.
     */
    data: NivelesCreateManyInput | NivelesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Niveles update
   */
  export type NivelesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * The data needed to update a Niveles.
     */
    data: XOR<NivelesUpdateInput, NivelesUncheckedUpdateInput>
    /**
     * Choose, which Niveles to update.
     */
    where: NivelesWhereUniqueInput
  }

  /**
   * Niveles updateMany
   */
  export type NivelesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Niveles.
     */
    data: XOR<NivelesUpdateManyMutationInput, NivelesUncheckedUpdateManyInput>
    /**
     * Filter which Niveles to update
     */
    where?: NivelesWhereInput
    /**
     * Limit how many Niveles to update.
     */
    limit?: number
  }

  /**
   * Niveles updateManyAndReturn
   */
  export type NivelesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * The data used to update Niveles.
     */
    data: XOR<NivelesUpdateManyMutationInput, NivelesUncheckedUpdateManyInput>
    /**
     * Filter which Niveles to update
     */
    where?: NivelesWhereInput
    /**
     * Limit how many Niveles to update.
     */
    limit?: number
  }

  /**
   * Niveles upsert
   */
  export type NivelesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * The filter to search for the Niveles to update in case it exists.
     */
    where: NivelesWhereUniqueInput
    /**
     * In case the Niveles found by the `where` argument doesn't exist, create a new Niveles with this data.
     */
    create: XOR<NivelesCreateInput, NivelesUncheckedCreateInput>
    /**
     * In case the Niveles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NivelesUpdateInput, NivelesUncheckedUpdateInput>
  }

  /**
   * Niveles delete
   */
  export type NivelesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
    /**
     * Filter which Niveles to delete.
     */
    where: NivelesWhereUniqueInput
  }

  /**
   * Niveles deleteMany
   */
  export type NivelesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Niveles to delete
     */
    where?: NivelesWhereInput
    /**
     * Limit how many Niveles to delete.
     */
    limit?: number
  }

  /**
   * Niveles.participacion
   */
  export type Niveles$participacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    where?: ParticipacionWhereInput
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    cursor?: ParticipacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacionScalarFieldEnum | ParticipacionScalarFieldEnum[]
  }

  /**
   * Niveles.ConfigMedallas
   */
  export type Niveles$ConfigMedallasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConfigMedallas
     */
    select?: ConfigMedallasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ConfigMedallas
     */
    omit?: ConfigMedallasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConfigMedallasInclude<ExtArgs> | null
    where?: ConfigMedallasWhereInput
    orderBy?: ConfigMedallasOrderByWithRelationInput | ConfigMedallasOrderByWithRelationInput[]
    cursor?: ConfigMedallasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConfigMedallasScalarFieldEnum | ConfigMedallasScalarFieldEnum[]
  }

  /**
   * Niveles without action
   */
  export type NivelesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Niveles
     */
    select?: NivelesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Niveles
     */
    omit?: NivelesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NivelesInclude<ExtArgs> | null
  }


  /**
   * Model Olimpistas
   */

  export type AggregateOlimpistas = {
    _count: OlimpistasCountAggregateOutputType | null
    _avg: OlimpistasAvgAggregateOutputType | null
    _sum: OlimpistasSumAggregateOutputType | null
    _min: OlimpistasMinAggregateOutputType | null
    _max: OlimpistasMaxAggregateOutputType | null
  }

  export type OlimpistasAvgAggregateOutputType = {
    id: number | null
    tutor_id: number | null
  }

  export type OlimpistasSumAggregateOutputType = {
    id: number | null
    tutor_id: number | null
  }

  export type OlimpistasMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    ap_paterno: string | null
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento | null
    numero_documento: string | null
    unidad_educativa: string | null
    departamento: string | null
    grado: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sexo | null
    activo: boolean | null
    creado_en: Date | null
    tutor_id: number | null
  }

  export type OlimpistasMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    ap_paterno: string | null
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento | null
    numero_documento: string | null
    unidad_educativa: string | null
    departamento: string | null
    grado: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sexo | null
    activo: boolean | null
    creado_en: Date | null
    tutor_id: number | null
  }

  export type OlimpistasCountAggregateOutputType = {
    id: number
    nombre: number
    ap_paterno: number
    ap_materno: number
    tipo_documento: number
    numero_documento: number
    unidad_educativa: number
    departamento: number
    grado: number
    fecha_nacimiento: number
    sexo: number
    activo: number
    creado_en: number
    tutor_id: number
    _all: number
  }


  export type OlimpistasAvgAggregateInputType = {
    id?: true
    tutor_id?: true
  }

  export type OlimpistasSumAggregateInputType = {
    id?: true
    tutor_id?: true
  }

  export type OlimpistasMinAggregateInputType = {
    id?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    unidad_educativa?: true
    departamento?: true
    grado?: true
    fecha_nacimiento?: true
    sexo?: true
    activo?: true
    creado_en?: true
    tutor_id?: true
  }

  export type OlimpistasMaxAggregateInputType = {
    id?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    unidad_educativa?: true
    departamento?: true
    grado?: true
    fecha_nacimiento?: true
    sexo?: true
    activo?: true
    creado_en?: true
    tutor_id?: true
  }

  export type OlimpistasCountAggregateInputType = {
    id?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    unidad_educativa?: true
    departamento?: true
    grado?: true
    fecha_nacimiento?: true
    sexo?: true
    activo?: true
    creado_en?: true
    tutor_id?: true
    _all?: true
  }

  export type OlimpistasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Olimpistas to aggregate.
     */
    where?: OlimpistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Olimpistas to fetch.
     */
    orderBy?: OlimpistasOrderByWithRelationInput | OlimpistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OlimpistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Olimpistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Olimpistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Olimpistas
    **/
    _count?: true | OlimpistasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OlimpistasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OlimpistasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OlimpistasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OlimpistasMaxAggregateInputType
  }

  export type GetOlimpistasAggregateType<T extends OlimpistasAggregateArgs> = {
        [P in keyof T & keyof AggregateOlimpistas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOlimpistas[P]>
      : GetScalarType<T[P], AggregateOlimpistas[P]>
  }




  export type OlimpistasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OlimpistasWhereInput
    orderBy?: OlimpistasOrderByWithAggregationInput | OlimpistasOrderByWithAggregationInput[]
    by: OlimpistasScalarFieldEnum[] | OlimpistasScalarFieldEnum
    having?: OlimpistasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OlimpistasCountAggregateInputType | true
    _avg?: OlimpistasAvgAggregateInputType
    _sum?: OlimpistasSumAggregateInputType
    _min?: OlimpistasMinAggregateInputType
    _max?: OlimpistasMaxAggregateInputType
  }

  export type OlimpistasGroupByOutputType = {
    id: number
    nombre: string
    ap_paterno: string
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado: string | null
    fecha_nacimiento: Date | null
    sexo: $Enums.Sexo | null
    activo: boolean
    creado_en: Date
    tutor_id: number | null
    _count: OlimpistasCountAggregateOutputType | null
    _avg: OlimpistasAvgAggregateOutputType | null
    _sum: OlimpistasSumAggregateOutputType | null
    _min: OlimpistasMinAggregateOutputType | null
    _max: OlimpistasMaxAggregateOutputType | null
  }

  type GetOlimpistasGroupByPayload<T extends OlimpistasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OlimpistasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OlimpistasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OlimpistasGroupByOutputType[P]>
            : GetScalarType<T[P], OlimpistasGroupByOutputType[P]>
        }
      >
    >


  export type OlimpistasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    unidad_educativa?: boolean
    departamento?: boolean
    grado?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    activo?: boolean
    creado_en?: boolean
    tutor_id?: boolean
    tutor?: boolean | Olimpistas$tutorArgs<ExtArgs>
    participacion?: boolean | Olimpistas$participacionArgs<ExtArgs>
    miembros_equipo?: boolean | Olimpistas$miembros_equipoArgs<ExtArgs>
    _count?: boolean | OlimpistasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["olimpistas"]>

  export type OlimpistasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    unidad_educativa?: boolean
    departamento?: boolean
    grado?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    activo?: boolean
    creado_en?: boolean
    tutor_id?: boolean
    tutor?: boolean | Olimpistas$tutorArgs<ExtArgs>
  }, ExtArgs["result"]["olimpistas"]>

  export type OlimpistasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    unidad_educativa?: boolean
    departamento?: boolean
    grado?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    activo?: boolean
    creado_en?: boolean
    tutor_id?: boolean
    tutor?: boolean | Olimpistas$tutorArgs<ExtArgs>
  }, ExtArgs["result"]["olimpistas"]>

  export type OlimpistasSelectScalar = {
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    unidad_educativa?: boolean
    departamento?: boolean
    grado?: boolean
    fecha_nacimiento?: boolean
    sexo?: boolean
    activo?: boolean
    creado_en?: boolean
    tutor_id?: boolean
  }

  export type OlimpistasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "ap_paterno" | "ap_materno" | "tipo_documento" | "numero_documento" | "unidad_educativa" | "departamento" | "grado" | "fecha_nacimiento" | "sexo" | "activo" | "creado_en" | "tutor_id", ExtArgs["result"]["olimpistas"]>
  export type OlimpistasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | Olimpistas$tutorArgs<ExtArgs>
    participacion?: boolean | Olimpistas$participacionArgs<ExtArgs>
    miembros_equipo?: boolean | Olimpistas$miembros_equipoArgs<ExtArgs>
    _count?: boolean | OlimpistasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type OlimpistasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | Olimpistas$tutorArgs<ExtArgs>
  }
  export type OlimpistasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tutor?: boolean | Olimpistas$tutorArgs<ExtArgs>
  }

  export type $OlimpistasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Olimpistas"
    objects: {
      tutor: Prisma.$TutoresPayload<ExtArgs> | null
      participacion: Prisma.$ParticipacionPayload<ExtArgs>[]
      miembros_equipo: Prisma.$MiembrosEquipoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      ap_paterno: string
      ap_materno: string | null
      tipo_documento: $Enums.TipoDocumento
      numero_documento: string
      unidad_educativa: string
      departamento: string
      grado: string | null
      fecha_nacimiento: Date | null
      sexo: $Enums.Sexo | null
      activo: boolean
      creado_en: Date
      tutor_id: number | null
    }, ExtArgs["result"]["olimpistas"]>
    composites: {}
  }

  type OlimpistasGetPayload<S extends boolean | null | undefined | OlimpistasDefaultArgs> = $Result.GetResult<Prisma.$OlimpistasPayload, S>

  type OlimpistasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OlimpistasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OlimpistasCountAggregateInputType | true
    }

  export interface OlimpistasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Olimpistas'], meta: { name: 'Olimpistas' } }
    /**
     * Find zero or one Olimpistas that matches the filter.
     * @param {OlimpistasFindUniqueArgs} args - Arguments to find a Olimpistas
     * @example
     * // Get one Olimpistas
     * const olimpistas = await prisma.olimpistas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OlimpistasFindUniqueArgs>(args: SelectSubset<T, OlimpistasFindUniqueArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Olimpistas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OlimpistasFindUniqueOrThrowArgs} args - Arguments to find a Olimpistas
     * @example
     * // Get one Olimpistas
     * const olimpistas = await prisma.olimpistas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OlimpistasFindUniqueOrThrowArgs>(args: SelectSubset<T, OlimpistasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Olimpistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasFindFirstArgs} args - Arguments to find a Olimpistas
     * @example
     * // Get one Olimpistas
     * const olimpistas = await prisma.olimpistas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OlimpistasFindFirstArgs>(args?: SelectSubset<T, OlimpistasFindFirstArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Olimpistas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasFindFirstOrThrowArgs} args - Arguments to find a Olimpistas
     * @example
     * // Get one Olimpistas
     * const olimpistas = await prisma.olimpistas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OlimpistasFindFirstOrThrowArgs>(args?: SelectSubset<T, OlimpistasFindFirstOrThrowArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Olimpistas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Olimpistas
     * const olimpistas = await prisma.olimpistas.findMany()
     * 
     * // Get first 10 Olimpistas
     * const olimpistas = await prisma.olimpistas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const olimpistasWithIdOnly = await prisma.olimpistas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OlimpistasFindManyArgs>(args?: SelectSubset<T, OlimpistasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Olimpistas.
     * @param {OlimpistasCreateArgs} args - Arguments to create a Olimpistas.
     * @example
     * // Create one Olimpistas
     * const Olimpistas = await prisma.olimpistas.create({
     *   data: {
     *     // ... data to create a Olimpistas
     *   }
     * })
     * 
     */
    create<T extends OlimpistasCreateArgs>(args: SelectSubset<T, OlimpistasCreateArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Olimpistas.
     * @param {OlimpistasCreateManyArgs} args - Arguments to create many Olimpistas.
     * @example
     * // Create many Olimpistas
     * const olimpistas = await prisma.olimpistas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OlimpistasCreateManyArgs>(args?: SelectSubset<T, OlimpistasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Olimpistas and returns the data saved in the database.
     * @param {OlimpistasCreateManyAndReturnArgs} args - Arguments to create many Olimpistas.
     * @example
     * // Create many Olimpistas
     * const olimpistas = await prisma.olimpistas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Olimpistas and only return the `id`
     * const olimpistasWithIdOnly = await prisma.olimpistas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OlimpistasCreateManyAndReturnArgs>(args?: SelectSubset<T, OlimpistasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Olimpistas.
     * @param {OlimpistasDeleteArgs} args - Arguments to delete one Olimpistas.
     * @example
     * // Delete one Olimpistas
     * const Olimpistas = await prisma.olimpistas.delete({
     *   where: {
     *     // ... filter to delete one Olimpistas
     *   }
     * })
     * 
     */
    delete<T extends OlimpistasDeleteArgs>(args: SelectSubset<T, OlimpistasDeleteArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Olimpistas.
     * @param {OlimpistasUpdateArgs} args - Arguments to update one Olimpistas.
     * @example
     * // Update one Olimpistas
     * const olimpistas = await prisma.olimpistas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OlimpistasUpdateArgs>(args: SelectSubset<T, OlimpistasUpdateArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Olimpistas.
     * @param {OlimpistasDeleteManyArgs} args - Arguments to filter Olimpistas to delete.
     * @example
     * // Delete a few Olimpistas
     * const { count } = await prisma.olimpistas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OlimpistasDeleteManyArgs>(args?: SelectSubset<T, OlimpistasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Olimpistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Olimpistas
     * const olimpistas = await prisma.olimpistas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OlimpistasUpdateManyArgs>(args: SelectSubset<T, OlimpistasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Olimpistas and returns the data updated in the database.
     * @param {OlimpistasUpdateManyAndReturnArgs} args - Arguments to update many Olimpistas.
     * @example
     * // Update many Olimpistas
     * const olimpistas = await prisma.olimpistas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Olimpistas and only return the `id`
     * const olimpistasWithIdOnly = await prisma.olimpistas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OlimpistasUpdateManyAndReturnArgs>(args: SelectSubset<T, OlimpistasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Olimpistas.
     * @param {OlimpistasUpsertArgs} args - Arguments to update or create a Olimpistas.
     * @example
     * // Update or create a Olimpistas
     * const olimpistas = await prisma.olimpistas.upsert({
     *   create: {
     *     // ... data to create a Olimpistas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Olimpistas we want to update
     *   }
     * })
     */
    upsert<T extends OlimpistasUpsertArgs>(args: SelectSubset<T, OlimpistasUpsertArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Olimpistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasCountArgs} args - Arguments to filter Olimpistas to count.
     * @example
     * // Count the number of Olimpistas
     * const count = await prisma.olimpistas.count({
     *   where: {
     *     // ... the filter for the Olimpistas we want to count
     *   }
     * })
    **/
    count<T extends OlimpistasCountArgs>(
      args?: Subset<T, OlimpistasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OlimpistasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Olimpistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OlimpistasAggregateArgs>(args: Subset<T, OlimpistasAggregateArgs>): Prisma.PrismaPromise<GetOlimpistasAggregateType<T>>

    /**
     * Group by Olimpistas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OlimpistasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OlimpistasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OlimpistasGroupByArgs['orderBy'] }
        : { orderBy?: OlimpistasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OlimpistasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOlimpistasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Olimpistas model
   */
  readonly fields: OlimpistasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Olimpistas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OlimpistasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tutor<T extends Olimpistas$tutorArgs<ExtArgs> = {}>(args?: Subset<T, Olimpistas$tutorArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    participacion<T extends Olimpistas$participacionArgs<ExtArgs> = {}>(args?: Subset<T, Olimpistas$participacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    miembros_equipo<T extends Olimpistas$miembros_equipoArgs<ExtArgs> = {}>(args?: Subset<T, Olimpistas$miembros_equipoArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MiembrosEquipoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Olimpistas model
   */
  interface OlimpistasFieldRefs {
    readonly id: FieldRef<"Olimpistas", 'Int'>
    readonly nombre: FieldRef<"Olimpistas", 'String'>
    readonly ap_paterno: FieldRef<"Olimpistas", 'String'>
    readonly ap_materno: FieldRef<"Olimpistas", 'String'>
    readonly tipo_documento: FieldRef<"Olimpistas", 'TipoDocumento'>
    readonly numero_documento: FieldRef<"Olimpistas", 'String'>
    readonly unidad_educativa: FieldRef<"Olimpistas", 'String'>
    readonly departamento: FieldRef<"Olimpistas", 'String'>
    readonly grado: FieldRef<"Olimpistas", 'String'>
    readonly fecha_nacimiento: FieldRef<"Olimpistas", 'DateTime'>
    readonly sexo: FieldRef<"Olimpistas", 'Sexo'>
    readonly activo: FieldRef<"Olimpistas", 'Boolean'>
    readonly creado_en: FieldRef<"Olimpistas", 'DateTime'>
    readonly tutor_id: FieldRef<"Olimpistas", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Olimpistas findUnique
   */
  export type OlimpistasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * Filter, which Olimpistas to fetch.
     */
    where: OlimpistasWhereUniqueInput
  }

  /**
   * Olimpistas findUniqueOrThrow
   */
  export type OlimpistasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * Filter, which Olimpistas to fetch.
     */
    where: OlimpistasWhereUniqueInput
  }

  /**
   * Olimpistas findFirst
   */
  export type OlimpistasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * Filter, which Olimpistas to fetch.
     */
    where?: OlimpistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Olimpistas to fetch.
     */
    orderBy?: OlimpistasOrderByWithRelationInput | OlimpistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Olimpistas.
     */
    cursor?: OlimpistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Olimpistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Olimpistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Olimpistas.
     */
    distinct?: OlimpistasScalarFieldEnum | OlimpistasScalarFieldEnum[]
  }

  /**
   * Olimpistas findFirstOrThrow
   */
  export type OlimpistasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * Filter, which Olimpistas to fetch.
     */
    where?: OlimpistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Olimpistas to fetch.
     */
    orderBy?: OlimpistasOrderByWithRelationInput | OlimpistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Olimpistas.
     */
    cursor?: OlimpistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Olimpistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Olimpistas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Olimpistas.
     */
    distinct?: OlimpistasScalarFieldEnum | OlimpistasScalarFieldEnum[]
  }

  /**
   * Olimpistas findMany
   */
  export type OlimpistasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * Filter, which Olimpistas to fetch.
     */
    where?: OlimpistasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Olimpistas to fetch.
     */
    orderBy?: OlimpistasOrderByWithRelationInput | OlimpistasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Olimpistas.
     */
    cursor?: OlimpistasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Olimpistas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Olimpistas.
     */
    skip?: number
    distinct?: OlimpistasScalarFieldEnum | OlimpistasScalarFieldEnum[]
  }

  /**
   * Olimpistas create
   */
  export type OlimpistasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * The data needed to create a Olimpistas.
     */
    data: XOR<OlimpistasCreateInput, OlimpistasUncheckedCreateInput>
  }

  /**
   * Olimpistas createMany
   */
  export type OlimpistasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Olimpistas.
     */
    data: OlimpistasCreateManyInput | OlimpistasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Olimpistas createManyAndReturn
   */
  export type OlimpistasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * The data used to create many Olimpistas.
     */
    data: OlimpistasCreateManyInput | OlimpistasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Olimpistas update
   */
  export type OlimpistasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * The data needed to update a Olimpistas.
     */
    data: XOR<OlimpistasUpdateInput, OlimpistasUncheckedUpdateInput>
    /**
     * Choose, which Olimpistas to update.
     */
    where: OlimpistasWhereUniqueInput
  }

  /**
   * Olimpistas updateMany
   */
  export type OlimpistasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Olimpistas.
     */
    data: XOR<OlimpistasUpdateManyMutationInput, OlimpistasUncheckedUpdateManyInput>
    /**
     * Filter which Olimpistas to update
     */
    where?: OlimpistasWhereInput
    /**
     * Limit how many Olimpistas to update.
     */
    limit?: number
  }

  /**
   * Olimpistas updateManyAndReturn
   */
  export type OlimpistasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * The data used to update Olimpistas.
     */
    data: XOR<OlimpistasUpdateManyMutationInput, OlimpistasUncheckedUpdateManyInput>
    /**
     * Filter which Olimpistas to update
     */
    where?: OlimpistasWhereInput
    /**
     * Limit how many Olimpistas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Olimpistas upsert
   */
  export type OlimpistasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * The filter to search for the Olimpistas to update in case it exists.
     */
    where: OlimpistasWhereUniqueInput
    /**
     * In case the Olimpistas found by the `where` argument doesn't exist, create a new Olimpistas with this data.
     */
    create: XOR<OlimpistasCreateInput, OlimpistasUncheckedCreateInput>
    /**
     * In case the Olimpistas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OlimpistasUpdateInput, OlimpistasUncheckedUpdateInput>
  }

  /**
   * Olimpistas delete
   */
  export type OlimpistasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    /**
     * Filter which Olimpistas to delete.
     */
    where: OlimpistasWhereUniqueInput
  }

  /**
   * Olimpistas deleteMany
   */
  export type OlimpistasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Olimpistas to delete
     */
    where?: OlimpistasWhereInput
    /**
     * Limit how many Olimpistas to delete.
     */
    limit?: number
  }

  /**
   * Olimpistas.tutor
   */
  export type Olimpistas$tutorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    where?: TutoresWhereInput
  }

  /**
   * Olimpistas.participacion
   */
  export type Olimpistas$participacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    where?: ParticipacionWhereInput
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    cursor?: ParticipacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ParticipacionScalarFieldEnum | ParticipacionScalarFieldEnum[]
  }

  /**
   * Olimpistas.miembros_equipo
   */
  export type Olimpistas$miembros_equipoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MiembrosEquipo
     */
    select?: MiembrosEquipoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MiembrosEquipo
     */
    omit?: MiembrosEquipoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MiembrosEquipoInclude<ExtArgs> | null
    where?: MiembrosEquipoWhereInput
    orderBy?: MiembrosEquipoOrderByWithRelationInput | MiembrosEquipoOrderByWithRelationInput[]
    cursor?: MiembrosEquipoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MiembrosEquipoScalarFieldEnum | MiembrosEquipoScalarFieldEnum[]
  }

  /**
   * Olimpistas without action
   */
  export type OlimpistasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
  }


  /**
   * Model Participacion
   */

  export type AggregateParticipacion = {
    _count: ParticipacionCountAggregateOutputType | null
    _avg: ParticipacionAvgAggregateOutputType | null
    _sum: ParticipacionSumAggregateOutputType | null
    _min: ParticipacionMinAggregateOutputType | null
    _max: ParticipacionMaxAggregateOutputType | null
  }

  export type ParticipacionAvgAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
    area_id: number | null
    nivel_id: number | null
  }

  export type ParticipacionSumAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
    area_id: number | null
    nivel_id: number | null
  }

  export type ParticipacionMinAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
    area_id: number | null
    nivel_id: number | null
    estado: $Enums.EstadoParticipacion | null
    tipo: $Enums.TipoParticipacion | null
  }

  export type ParticipacionMaxAggregateOutputType = {
    id: number | null
    olimpista_id: number | null
    area_id: number | null
    nivel_id: number | null
    estado: $Enums.EstadoParticipacion | null
    tipo: $Enums.TipoParticipacion | null
  }

  export type ParticipacionCountAggregateOutputType = {
    id: number
    olimpista_id: number
    area_id: number
    nivel_id: number
    estado: number
    tipo: number
    _all: number
  }


  export type ParticipacionAvgAggregateInputType = {
    id?: true
    olimpista_id?: true
    area_id?: true
    nivel_id?: true
  }

  export type ParticipacionSumAggregateInputType = {
    id?: true
    olimpista_id?: true
    area_id?: true
    nivel_id?: true
  }

  export type ParticipacionMinAggregateInputType = {
    id?: true
    olimpista_id?: true
    area_id?: true
    nivel_id?: true
    estado?: true
    tipo?: true
  }

  export type ParticipacionMaxAggregateInputType = {
    id?: true
    olimpista_id?: true
    area_id?: true
    nivel_id?: true
    estado?: true
    tipo?: true
  }

  export type ParticipacionCountAggregateInputType = {
    id?: true
    olimpista_id?: true
    area_id?: true
    nivel_id?: true
    estado?: true
    tipo?: true
    _all?: true
  }

  export type ParticipacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participacion to aggregate.
     */
    where?: ParticipacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participacions to fetch.
     */
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ParticipacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Participacions
    **/
    _count?: true | ParticipacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ParticipacionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ParticipacionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ParticipacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ParticipacionMaxAggregateInputType
  }

  export type GetParticipacionAggregateType<T extends ParticipacionAggregateArgs> = {
        [P in keyof T & keyof AggregateParticipacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParticipacion[P]>
      : GetScalarType<T[P], AggregateParticipacion[P]>
  }




  export type ParticipacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ParticipacionWhereInput
    orderBy?: ParticipacionOrderByWithAggregationInput | ParticipacionOrderByWithAggregationInput[]
    by: ParticipacionScalarFieldEnum[] | ParticipacionScalarFieldEnum
    having?: ParticipacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ParticipacionCountAggregateInputType | true
    _avg?: ParticipacionAvgAggregateInputType
    _sum?: ParticipacionSumAggregateInputType
    _min?: ParticipacionMinAggregateInputType
    _max?: ParticipacionMaxAggregateInputType
  }

  export type ParticipacionGroupByOutputType = {
    id: number
    olimpista_id: number
    area_id: number
    nivel_id: number
    estado: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    _count: ParticipacionCountAggregateOutputType | null
    _avg: ParticipacionAvgAggregateOutputType | null
    _sum: ParticipacionSumAggregateOutputType | null
    _min: ParticipacionMinAggregateOutputType | null
    _max: ParticipacionMaxAggregateOutputType | null
  }

  type GetParticipacionGroupByPayload<T extends ParticipacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ParticipacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ParticipacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ParticipacionGroupByOutputType[P]>
            : GetScalarType<T[P], ParticipacionGroupByOutputType[P]>
        }
      >
    >


  export type ParticipacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    olimpista_id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    estado?: boolean
    tipo?: boolean
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
    evaluaciones?: boolean | Participacion$evaluacionesArgs<ExtArgs>
    _count?: boolean | ParticipacionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacion"]>

  export type ParticipacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    olimpista_id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    estado?: boolean
    tipo?: boolean
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacion"]>

  export type ParticipacionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    olimpista_id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    estado?: boolean
    tipo?: boolean
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["participacion"]>

  export type ParticipacionSelectScalar = {
    id?: boolean
    olimpista_id?: boolean
    area_id?: boolean
    nivel_id?: boolean
    estado?: boolean
    tipo?: boolean
  }

  export type ParticipacionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "olimpista_id" | "area_id" | "nivel_id" | "estado" | "tipo", ExtArgs["result"]["participacion"]>
  export type ParticipacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
    evaluaciones?: boolean | Participacion$evaluacionesArgs<ExtArgs>
    _count?: boolean | ParticipacionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ParticipacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }
  export type ParticipacionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpista?: boolean | OlimpistasDefaultArgs<ExtArgs>
    area?: boolean | AreasDefaultArgs<ExtArgs>
    nivel?: boolean | NivelesDefaultArgs<ExtArgs>
  }

  export type $ParticipacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Participacion"
    objects: {
      olimpista: Prisma.$OlimpistasPayload<ExtArgs>
      area: Prisma.$AreasPayload<ExtArgs>
      nivel: Prisma.$NivelesPayload<ExtArgs>
      evaluaciones: Prisma.$EvaluacionesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      olimpista_id: number
      area_id: number
      nivel_id: number
      estado: $Enums.EstadoParticipacion
      tipo: $Enums.TipoParticipacion
    }, ExtArgs["result"]["participacion"]>
    composites: {}
  }

  type ParticipacionGetPayload<S extends boolean | null | undefined | ParticipacionDefaultArgs> = $Result.GetResult<Prisma.$ParticipacionPayload, S>

  type ParticipacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ParticipacionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ParticipacionCountAggregateInputType | true
    }

  export interface ParticipacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Participacion'], meta: { name: 'Participacion' } }
    /**
     * Find zero or one Participacion that matches the filter.
     * @param {ParticipacionFindUniqueArgs} args - Arguments to find a Participacion
     * @example
     * // Get one Participacion
     * const participacion = await prisma.participacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ParticipacionFindUniqueArgs>(args: SelectSubset<T, ParticipacionFindUniqueArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Participacion that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ParticipacionFindUniqueOrThrowArgs} args - Arguments to find a Participacion
     * @example
     * // Get one Participacion
     * const participacion = await prisma.participacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ParticipacionFindUniqueOrThrowArgs>(args: SelectSubset<T, ParticipacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionFindFirstArgs} args - Arguments to find a Participacion
     * @example
     * // Get one Participacion
     * const participacion = await prisma.participacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ParticipacionFindFirstArgs>(args?: SelectSubset<T, ParticipacionFindFirstArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Participacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionFindFirstOrThrowArgs} args - Arguments to find a Participacion
     * @example
     * // Get one Participacion
     * const participacion = await prisma.participacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ParticipacionFindFirstOrThrowArgs>(args?: SelectSubset<T, ParticipacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Participacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Participacions
     * const participacions = await prisma.participacion.findMany()
     * 
     * // Get first 10 Participacions
     * const participacions = await prisma.participacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const participacionWithIdOnly = await prisma.participacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ParticipacionFindManyArgs>(args?: SelectSubset<T, ParticipacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Participacion.
     * @param {ParticipacionCreateArgs} args - Arguments to create a Participacion.
     * @example
     * // Create one Participacion
     * const Participacion = await prisma.participacion.create({
     *   data: {
     *     // ... data to create a Participacion
     *   }
     * })
     * 
     */
    create<T extends ParticipacionCreateArgs>(args: SelectSubset<T, ParticipacionCreateArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Participacions.
     * @param {ParticipacionCreateManyArgs} args - Arguments to create many Participacions.
     * @example
     * // Create many Participacions
     * const participacion = await prisma.participacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ParticipacionCreateManyArgs>(args?: SelectSubset<T, ParticipacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Participacions and returns the data saved in the database.
     * @param {ParticipacionCreateManyAndReturnArgs} args - Arguments to create many Participacions.
     * @example
     * // Create many Participacions
     * const participacion = await prisma.participacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Participacions and only return the `id`
     * const participacionWithIdOnly = await prisma.participacion.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ParticipacionCreateManyAndReturnArgs>(args?: SelectSubset<T, ParticipacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Participacion.
     * @param {ParticipacionDeleteArgs} args - Arguments to delete one Participacion.
     * @example
     * // Delete one Participacion
     * const Participacion = await prisma.participacion.delete({
     *   where: {
     *     // ... filter to delete one Participacion
     *   }
     * })
     * 
     */
    delete<T extends ParticipacionDeleteArgs>(args: SelectSubset<T, ParticipacionDeleteArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Participacion.
     * @param {ParticipacionUpdateArgs} args - Arguments to update one Participacion.
     * @example
     * // Update one Participacion
     * const participacion = await prisma.participacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ParticipacionUpdateArgs>(args: SelectSubset<T, ParticipacionUpdateArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Participacions.
     * @param {ParticipacionDeleteManyArgs} args - Arguments to filter Participacions to delete.
     * @example
     * // Delete a few Participacions
     * const { count } = await prisma.participacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ParticipacionDeleteManyArgs>(args?: SelectSubset<T, ParticipacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Participacions
     * const participacion = await prisma.participacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ParticipacionUpdateManyArgs>(args: SelectSubset<T, ParticipacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Participacions and returns the data updated in the database.
     * @param {ParticipacionUpdateManyAndReturnArgs} args - Arguments to update many Participacions.
     * @example
     * // Update many Participacions
     * const participacion = await prisma.participacion.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Participacions and only return the `id`
     * const participacionWithIdOnly = await prisma.participacion.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ParticipacionUpdateManyAndReturnArgs>(args: SelectSubset<T, ParticipacionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Participacion.
     * @param {ParticipacionUpsertArgs} args - Arguments to update or create a Participacion.
     * @example
     * // Update or create a Participacion
     * const participacion = await prisma.participacion.upsert({
     *   create: {
     *     // ... data to create a Participacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Participacion we want to update
     *   }
     * })
     */
    upsert<T extends ParticipacionUpsertArgs>(args: SelectSubset<T, ParticipacionUpsertArgs<ExtArgs>>): Prisma__ParticipacionClient<$Result.GetResult<Prisma.$ParticipacionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Participacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionCountArgs} args - Arguments to filter Participacions to count.
     * @example
     * // Count the number of Participacions
     * const count = await prisma.participacion.count({
     *   where: {
     *     // ... the filter for the Participacions we want to count
     *   }
     * })
    **/
    count<T extends ParticipacionCountArgs>(
      args?: Subset<T, ParticipacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ParticipacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Participacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ParticipacionAggregateArgs>(args: Subset<T, ParticipacionAggregateArgs>): Prisma.PrismaPromise<GetParticipacionAggregateType<T>>

    /**
     * Group by Participacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ParticipacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ParticipacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ParticipacionGroupByArgs['orderBy'] }
        : { orderBy?: ParticipacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ParticipacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParticipacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Participacion model
   */
  readonly fields: ParticipacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Participacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ParticipacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    olimpista<T extends OlimpistasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OlimpistasDefaultArgs<ExtArgs>>): Prisma__OlimpistasClient<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    area<T extends AreasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AreasDefaultArgs<ExtArgs>>): Prisma__AreasClient<$Result.GetResult<Prisma.$AreasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    nivel<T extends NivelesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NivelesDefaultArgs<ExtArgs>>): Prisma__NivelesClient<$Result.GetResult<Prisma.$NivelesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    evaluaciones<T extends Participacion$evaluacionesArgs<ExtArgs> = {}>(args?: Subset<T, Participacion$evaluacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Participacion model
   */
  interface ParticipacionFieldRefs {
    readonly id: FieldRef<"Participacion", 'Int'>
    readonly olimpista_id: FieldRef<"Participacion", 'Int'>
    readonly area_id: FieldRef<"Participacion", 'Int'>
    readonly nivel_id: FieldRef<"Participacion", 'Int'>
    readonly estado: FieldRef<"Participacion", 'EstadoParticipacion'>
    readonly tipo: FieldRef<"Participacion", 'TipoParticipacion'>
  }
    

  // Custom InputTypes
  /**
   * Participacion findUnique
   */
  export type ParticipacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * Filter, which Participacion to fetch.
     */
    where: ParticipacionWhereUniqueInput
  }

  /**
   * Participacion findUniqueOrThrow
   */
  export type ParticipacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * Filter, which Participacion to fetch.
     */
    where: ParticipacionWhereUniqueInput
  }

  /**
   * Participacion findFirst
   */
  export type ParticipacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * Filter, which Participacion to fetch.
     */
    where?: ParticipacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participacions to fetch.
     */
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participacions.
     */
    cursor?: ParticipacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participacions.
     */
    distinct?: ParticipacionScalarFieldEnum | ParticipacionScalarFieldEnum[]
  }

  /**
   * Participacion findFirstOrThrow
   */
  export type ParticipacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * Filter, which Participacion to fetch.
     */
    where?: ParticipacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participacions to fetch.
     */
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Participacions.
     */
    cursor?: ParticipacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Participacions.
     */
    distinct?: ParticipacionScalarFieldEnum | ParticipacionScalarFieldEnum[]
  }

  /**
   * Participacion findMany
   */
  export type ParticipacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * Filter, which Participacions to fetch.
     */
    where?: ParticipacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Participacions to fetch.
     */
    orderBy?: ParticipacionOrderByWithRelationInput | ParticipacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Participacions.
     */
    cursor?: ParticipacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Participacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Participacions.
     */
    skip?: number
    distinct?: ParticipacionScalarFieldEnum | ParticipacionScalarFieldEnum[]
  }

  /**
   * Participacion create
   */
  export type ParticipacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * The data needed to create a Participacion.
     */
    data: XOR<ParticipacionCreateInput, ParticipacionUncheckedCreateInput>
  }

  /**
   * Participacion createMany
   */
  export type ParticipacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Participacions.
     */
    data: ParticipacionCreateManyInput | ParticipacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Participacion createManyAndReturn
   */
  export type ParticipacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * The data used to create many Participacions.
     */
    data: ParticipacionCreateManyInput | ParticipacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Participacion update
   */
  export type ParticipacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * The data needed to update a Participacion.
     */
    data: XOR<ParticipacionUpdateInput, ParticipacionUncheckedUpdateInput>
    /**
     * Choose, which Participacion to update.
     */
    where: ParticipacionWhereUniqueInput
  }

  /**
   * Participacion updateMany
   */
  export type ParticipacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Participacions.
     */
    data: XOR<ParticipacionUpdateManyMutationInput, ParticipacionUncheckedUpdateManyInput>
    /**
     * Filter which Participacions to update
     */
    where?: ParticipacionWhereInput
    /**
     * Limit how many Participacions to update.
     */
    limit?: number
  }

  /**
   * Participacion updateManyAndReturn
   */
  export type ParticipacionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * The data used to update Participacions.
     */
    data: XOR<ParticipacionUpdateManyMutationInput, ParticipacionUncheckedUpdateManyInput>
    /**
     * Filter which Participacions to update
     */
    where?: ParticipacionWhereInput
    /**
     * Limit how many Participacions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Participacion upsert
   */
  export type ParticipacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * The filter to search for the Participacion to update in case it exists.
     */
    where: ParticipacionWhereUniqueInput
    /**
     * In case the Participacion found by the `where` argument doesn't exist, create a new Participacion with this data.
     */
    create: XOR<ParticipacionCreateInput, ParticipacionUncheckedCreateInput>
    /**
     * In case the Participacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ParticipacionUpdateInput, ParticipacionUncheckedUpdateInput>
  }

  /**
   * Participacion delete
   */
  export type ParticipacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
    /**
     * Filter which Participacion to delete.
     */
    where: ParticipacionWhereUniqueInput
  }

  /**
   * Participacion deleteMany
   */
  export type ParticipacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Participacions to delete
     */
    where?: ParticipacionWhereInput
    /**
     * Limit how many Participacions to delete.
     */
    limit?: number
  }

  /**
   * Participacion.evaluaciones
   */
  export type Participacion$evaluacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    where?: EvaluacionesWhereInput
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    cursor?: EvaluacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluacionesScalarFieldEnum | EvaluacionesScalarFieldEnum[]
  }

  /**
   * Participacion without action
   */
  export type ParticipacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Participacion
     */
    select?: ParticipacionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Participacion
     */
    omit?: ParticipacionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ParticipacionInclude<ExtArgs> | null
  }


  /**
   * Model Reportes
   */

  export type AggregateReportes = {
    _count: ReportesCountAggregateOutputType | null
    _avg: ReportesAvgAggregateOutputType | null
    _sum: ReportesSumAggregateOutputType | null
    _min: ReportesMinAggregateOutputType | null
    _max: ReportesMaxAggregateOutputType | null
  }

  export type ReportesAvgAggregateOutputType = {
    id: number | null
    generado_por: number | null
  }

  export type ReportesSumAggregateOutputType = {
    id: number | null
    generado_por: number | null
  }

  export type ReportesMinAggregateOutputType = {
    id: number | null
    tipo: string | null
    archivo: string | null
    generado_por: number | null
    generado_en: Date | null
  }

  export type ReportesMaxAggregateOutputType = {
    id: number | null
    tipo: string | null
    archivo: string | null
    generado_por: number | null
    generado_en: Date | null
  }

  export type ReportesCountAggregateOutputType = {
    id: number
    tipo: number
    parametros: number
    archivo: number
    generado_por: number
    generado_en: number
    _all: number
  }


  export type ReportesAvgAggregateInputType = {
    id?: true
    generado_por?: true
  }

  export type ReportesSumAggregateInputType = {
    id?: true
    generado_por?: true
  }

  export type ReportesMinAggregateInputType = {
    id?: true
    tipo?: true
    archivo?: true
    generado_por?: true
    generado_en?: true
  }

  export type ReportesMaxAggregateInputType = {
    id?: true
    tipo?: true
    archivo?: true
    generado_por?: true
    generado_en?: true
  }

  export type ReportesCountAggregateInputType = {
    id?: true
    tipo?: true
    parametros?: true
    archivo?: true
    generado_por?: true
    generado_en?: true
    _all?: true
  }

  export type ReportesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reportes to aggregate.
     */
    where?: ReportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReportesOrderByWithRelationInput | ReportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reportes
    **/
    _count?: true | ReportesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportesMaxAggregateInputType
  }

  export type GetReportesAggregateType<T extends ReportesAggregateArgs> = {
        [P in keyof T & keyof AggregateReportes]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReportes[P]>
      : GetScalarType<T[P], AggregateReportes[P]>
  }




  export type ReportesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReportesWhereInput
    orderBy?: ReportesOrderByWithAggregationInput | ReportesOrderByWithAggregationInput[]
    by: ReportesScalarFieldEnum[] | ReportesScalarFieldEnum
    having?: ReportesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportesCountAggregateInputType | true
    _avg?: ReportesAvgAggregateInputType
    _sum?: ReportesSumAggregateInputType
    _min?: ReportesMinAggregateInputType
    _max?: ReportesMaxAggregateInputType
  }

  export type ReportesGroupByOutputType = {
    id: number
    tipo: string
    parametros: JsonValue | null
    archivo: string | null
    generado_por: number
    generado_en: Date | null
    _count: ReportesCountAggregateOutputType | null
    _avg: ReportesAvgAggregateOutputType | null
    _sum: ReportesSumAggregateOutputType | null
    _min: ReportesMinAggregateOutputType | null
    _max: ReportesMaxAggregateOutputType | null
  }

  type GetReportesGroupByPayload<T extends ReportesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReportesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportesGroupByOutputType[P]>
            : GetScalarType<T[P], ReportesGroupByOutputType[P]>
        }
      >
    >


  export type ReportesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    parametros?: boolean
    archivo?: boolean
    generado_por?: boolean
    generado_en?: boolean
    generadoPor?: boolean | Reportes$generadoPorArgs<ExtArgs>
  }, ExtArgs["result"]["reportes"]>

  export type ReportesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    parametros?: boolean
    archivo?: boolean
    generado_por?: boolean
    generado_en?: boolean
    generadoPor?: boolean | Reportes$generadoPorArgs<ExtArgs>
  }, ExtArgs["result"]["reportes"]>

  export type ReportesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    parametros?: boolean
    archivo?: boolean
    generado_por?: boolean
    generado_en?: boolean
    generadoPor?: boolean | Reportes$generadoPorArgs<ExtArgs>
  }, ExtArgs["result"]["reportes"]>

  export type ReportesSelectScalar = {
    id?: boolean
    tipo?: boolean
    parametros?: boolean
    archivo?: boolean
    generado_por?: boolean
    generado_en?: boolean
  }

  export type ReportesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tipo" | "parametros" | "archivo" | "generado_por" | "generado_en", ExtArgs["result"]["reportes"]>
  export type ReportesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generadoPor?: boolean | Reportes$generadoPorArgs<ExtArgs>
  }
  export type ReportesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generadoPor?: boolean | Reportes$generadoPorArgs<ExtArgs>
  }
  export type ReportesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    generadoPor?: boolean | Reportes$generadoPorArgs<ExtArgs>
  }

  export type $ReportesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reportes"
    objects: {
      generadoPor: Prisma.$UsuariosPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      tipo: string
      parametros: Prisma.JsonValue | null
      archivo: string | null
      generado_por: number
      generado_en: Date | null
    }, ExtArgs["result"]["reportes"]>
    composites: {}
  }

  type ReportesGetPayload<S extends boolean | null | undefined | ReportesDefaultArgs> = $Result.GetResult<Prisma.$ReportesPayload, S>

  type ReportesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReportesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReportesCountAggregateInputType | true
    }

  export interface ReportesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reportes'], meta: { name: 'Reportes' } }
    /**
     * Find zero or one Reportes that matches the filter.
     * @param {ReportesFindUniqueArgs} args - Arguments to find a Reportes
     * @example
     * // Get one Reportes
     * const reportes = await prisma.reportes.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReportesFindUniqueArgs>(args: SelectSubset<T, ReportesFindUniqueArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Reportes that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReportesFindUniqueOrThrowArgs} args - Arguments to find a Reportes
     * @example
     * // Get one Reportes
     * const reportes = await prisma.reportes.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReportesFindUniqueOrThrowArgs>(args: SelectSubset<T, ReportesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesFindFirstArgs} args - Arguments to find a Reportes
     * @example
     * // Get one Reportes
     * const reportes = await prisma.reportes.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReportesFindFirstArgs>(args?: SelectSubset<T, ReportesFindFirstArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Reportes that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesFindFirstOrThrowArgs} args - Arguments to find a Reportes
     * @example
     * // Get one Reportes
     * const reportes = await prisma.reportes.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReportesFindFirstOrThrowArgs>(args?: SelectSubset<T, ReportesFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reportes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reportes
     * const reportes = await prisma.reportes.findMany()
     * 
     * // Get first 10 Reportes
     * const reportes = await prisma.reportes.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportesWithIdOnly = await prisma.reportes.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReportesFindManyArgs>(args?: SelectSubset<T, ReportesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Reportes.
     * @param {ReportesCreateArgs} args - Arguments to create a Reportes.
     * @example
     * // Create one Reportes
     * const Reportes = await prisma.reportes.create({
     *   data: {
     *     // ... data to create a Reportes
     *   }
     * })
     * 
     */
    create<T extends ReportesCreateArgs>(args: SelectSubset<T, ReportesCreateArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reportes.
     * @param {ReportesCreateManyArgs} args - Arguments to create many Reportes.
     * @example
     * // Create many Reportes
     * const reportes = await prisma.reportes.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReportesCreateManyArgs>(args?: SelectSubset<T, ReportesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reportes and returns the data saved in the database.
     * @param {ReportesCreateManyAndReturnArgs} args - Arguments to create many Reportes.
     * @example
     * // Create many Reportes
     * const reportes = await prisma.reportes.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reportes and only return the `id`
     * const reportesWithIdOnly = await prisma.reportes.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReportesCreateManyAndReturnArgs>(args?: SelectSubset<T, ReportesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Reportes.
     * @param {ReportesDeleteArgs} args - Arguments to delete one Reportes.
     * @example
     * // Delete one Reportes
     * const Reportes = await prisma.reportes.delete({
     *   where: {
     *     // ... filter to delete one Reportes
     *   }
     * })
     * 
     */
    delete<T extends ReportesDeleteArgs>(args: SelectSubset<T, ReportesDeleteArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Reportes.
     * @param {ReportesUpdateArgs} args - Arguments to update one Reportes.
     * @example
     * // Update one Reportes
     * const reportes = await prisma.reportes.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReportesUpdateArgs>(args: SelectSubset<T, ReportesUpdateArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reportes.
     * @param {ReportesDeleteManyArgs} args - Arguments to filter Reportes to delete.
     * @example
     * // Delete a few Reportes
     * const { count } = await prisma.reportes.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReportesDeleteManyArgs>(args?: SelectSubset<T, ReportesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reportes
     * const reportes = await prisma.reportes.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReportesUpdateManyArgs>(args: SelectSubset<T, ReportesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reportes and returns the data updated in the database.
     * @param {ReportesUpdateManyAndReturnArgs} args - Arguments to update many Reportes.
     * @example
     * // Update many Reportes
     * const reportes = await prisma.reportes.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reportes and only return the `id`
     * const reportesWithIdOnly = await prisma.reportes.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReportesUpdateManyAndReturnArgs>(args: SelectSubset<T, ReportesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Reportes.
     * @param {ReportesUpsertArgs} args - Arguments to update or create a Reportes.
     * @example
     * // Update or create a Reportes
     * const reportes = await prisma.reportes.upsert({
     *   create: {
     *     // ... data to create a Reportes
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reportes we want to update
     *   }
     * })
     */
    upsert<T extends ReportesUpsertArgs>(args: SelectSubset<T, ReportesUpsertArgs<ExtArgs>>): Prisma__ReportesClient<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesCountArgs} args - Arguments to filter Reportes to count.
     * @example
     * // Count the number of Reportes
     * const count = await prisma.reportes.count({
     *   where: {
     *     // ... the filter for the Reportes we want to count
     *   }
     * })
    **/
    count<T extends ReportesCountArgs>(
      args?: Subset<T, ReportesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportesAggregateArgs>(args: Subset<T, ReportesAggregateArgs>): Prisma.PrismaPromise<GetReportesAggregateType<T>>

    /**
     * Group by Reportes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportesGroupByArgs['orderBy'] }
        : { orderBy?: ReportesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reportes model
   */
  readonly fields: ReportesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reportes.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReportesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    generadoPor<T extends Reportes$generadoPorArgs<ExtArgs> = {}>(args?: Subset<T, Reportes$generadoPorArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reportes model
   */
  interface ReportesFieldRefs {
    readonly id: FieldRef<"Reportes", 'Int'>
    readonly tipo: FieldRef<"Reportes", 'String'>
    readonly parametros: FieldRef<"Reportes", 'Json'>
    readonly archivo: FieldRef<"Reportes", 'String'>
    readonly generado_por: FieldRef<"Reportes", 'Int'>
    readonly generado_en: FieldRef<"Reportes", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Reportes findUnique
   */
  export type ReportesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * Filter, which Reportes to fetch.
     */
    where: ReportesWhereUniqueInput
  }

  /**
   * Reportes findUniqueOrThrow
   */
  export type ReportesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * Filter, which Reportes to fetch.
     */
    where: ReportesWhereUniqueInput
  }

  /**
   * Reportes findFirst
   */
  export type ReportesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * Filter, which Reportes to fetch.
     */
    where?: ReportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReportesOrderByWithRelationInput | ReportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reportes.
     */
    cursor?: ReportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reportes.
     */
    distinct?: ReportesScalarFieldEnum | ReportesScalarFieldEnum[]
  }

  /**
   * Reportes findFirstOrThrow
   */
  export type ReportesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * Filter, which Reportes to fetch.
     */
    where?: ReportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReportesOrderByWithRelationInput | ReportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reportes.
     */
    cursor?: ReportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reportes.
     */
    distinct?: ReportesScalarFieldEnum | ReportesScalarFieldEnum[]
  }

  /**
   * Reportes findMany
   */
  export type ReportesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * Filter, which Reportes to fetch.
     */
    where?: ReportesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reportes to fetch.
     */
    orderBy?: ReportesOrderByWithRelationInput | ReportesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reportes.
     */
    cursor?: ReportesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reportes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reportes.
     */
    skip?: number
    distinct?: ReportesScalarFieldEnum | ReportesScalarFieldEnum[]
  }

  /**
   * Reportes create
   */
  export type ReportesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * The data needed to create a Reportes.
     */
    data: XOR<ReportesCreateInput, ReportesUncheckedCreateInput>
  }

  /**
   * Reportes createMany
   */
  export type ReportesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reportes.
     */
    data: ReportesCreateManyInput | ReportesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reportes createManyAndReturn
   */
  export type ReportesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * The data used to create many Reportes.
     */
    data: ReportesCreateManyInput | ReportesCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reportes update
   */
  export type ReportesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * The data needed to update a Reportes.
     */
    data: XOR<ReportesUpdateInput, ReportesUncheckedUpdateInput>
    /**
     * Choose, which Reportes to update.
     */
    where: ReportesWhereUniqueInput
  }

  /**
   * Reportes updateMany
   */
  export type ReportesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reportes.
     */
    data: XOR<ReportesUpdateManyMutationInput, ReportesUncheckedUpdateManyInput>
    /**
     * Filter which Reportes to update
     */
    where?: ReportesWhereInput
    /**
     * Limit how many Reportes to update.
     */
    limit?: number
  }

  /**
   * Reportes updateManyAndReturn
   */
  export type ReportesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * The data used to update Reportes.
     */
    data: XOR<ReportesUpdateManyMutationInput, ReportesUncheckedUpdateManyInput>
    /**
     * Filter which Reportes to update
     */
    where?: ReportesWhereInput
    /**
     * Limit how many Reportes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reportes upsert
   */
  export type ReportesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * The filter to search for the Reportes to update in case it exists.
     */
    where: ReportesWhereUniqueInput
    /**
     * In case the Reportes found by the `where` argument doesn't exist, create a new Reportes with this data.
     */
    create: XOR<ReportesCreateInput, ReportesUncheckedCreateInput>
    /**
     * In case the Reportes was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReportesUpdateInput, ReportesUncheckedUpdateInput>
  }

  /**
   * Reportes delete
   */
  export type ReportesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    /**
     * Filter which Reportes to delete.
     */
    where: ReportesWhereUniqueInput
  }

  /**
   * Reportes deleteMany
   */
  export type ReportesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reportes to delete
     */
    where?: ReportesWhereInput
    /**
     * Limit how many Reportes to delete.
     */
    limit?: number
  }

  /**
   * Reportes.generadoPor
   */
  export type Reportes$generadoPorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }

  /**
   * Reportes without action
   */
  export type ReportesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
  }


  /**
   * Model Roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: number | null
  }

  export type RolesMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type RolesMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    descripcion: string | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to aggregate.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type RolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RolesWhereInput
    orderBy?: RolesOrderByWithAggregationInput | RolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: RolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: number
    nombre: string
    descripcion: string | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends RolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type RolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    usuario_rol?: boolean | Roles$usuario_rolArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }, ExtArgs["result"]["roles"]>

  export type RolesSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
  }

  export type RolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "descripcion", ExtArgs["result"]["roles"]>
  export type RolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario_rol?: boolean | Roles$usuario_rolArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type RolesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type RolesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $RolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roles"
    objects: {
      usuario_rol: Prisma.$UsuarioRolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      descripcion: string | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type RolesGetPayload<S extends boolean | null | undefined | RolesDefaultArgs> = $Result.GetResult<Prisma.$RolesPayload, S>

  type RolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface RolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roles'], meta: { name: 'Roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {RolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RolesFindUniqueArgs>(args: SelectSubset<T, RolesFindUniqueArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RolesFindUniqueOrThrowArgs>(args: SelectSubset<T, RolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RolesFindFirstArgs>(args?: SelectSubset<T, RolesFindFirstArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RolesFindFirstOrThrowArgs>(args?: SelectSubset<T, RolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RolesFindManyArgs>(args?: SelectSubset<T, RolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {RolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends RolesCreateArgs>(args: SelectSubset<T, RolesCreateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {RolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RolesCreateManyArgs>(args?: SelectSubset<T, RolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Roles and returns the data saved in the database.
     * @param {RolesCreateManyAndReturnArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RolesCreateManyAndReturnArgs>(args?: SelectSubset<T, RolesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Roles.
     * @param {RolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends RolesDeleteArgs>(args: SelectSubset<T, RolesDeleteArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {RolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RolesUpdateArgs>(args: SelectSubset<T, RolesUpdateArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {RolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RolesDeleteManyArgs>(args?: SelectSubset<T, RolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RolesUpdateManyArgs>(args: SelectSubset<T, RolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles and returns the data updated in the database.
     * @param {RolesUpdateManyAndReturnArgs} args - Arguments to update many Roles.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Roles and only return the `id`
     * const rolesWithIdOnly = await prisma.roles.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RolesUpdateManyAndReturnArgs>(args: SelectSubset<T, RolesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Roles.
     * @param {RolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends RolesUpsertArgs>(args: SelectSubset<T, RolesUpsertArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends RolesCountArgs>(
      args?: Subset<T, RolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RolesGroupByArgs['orderBy'] }
        : { orderBy?: RolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roles model
   */
  readonly fields: RolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario_rol<T extends Roles$usuario_rolArgs<ExtArgs> = {}>(args?: Subset<T, Roles$usuario_rolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roles model
   */
  interface RolesFieldRefs {
    readonly id: FieldRef<"Roles", 'Int'>
    readonly nombre: FieldRef<"Roles", 'String'>
    readonly descripcion: FieldRef<"Roles", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Roles findUnique
   */
  export type RolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findUniqueOrThrow
   */
  export type RolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles findFirst
   */
  export type RolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findFirstOrThrow
   */
  export type RolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles findMany
   */
  export type RolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter, which Roles to fetch.
     */
    where?: RolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roles to fetch.
     */
    orderBy?: RolesOrderByWithRelationInput | RolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roles.
     */
    cursor?: RolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * Roles create
   */
  export type RolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to create a Roles.
     */
    data: XOR<RolesCreateInput, RolesUncheckedCreateInput>
  }

  /**
   * Roles createMany
   */
  export type RolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles createManyAndReturn
   */
  export type RolesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to create many Roles.
     */
    data: RolesCreateManyInput | RolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roles update
   */
  export type RolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The data needed to update a Roles.
     */
    data: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
    /**
     * Choose, which Roles to update.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles updateMany
   */
  export type RolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles updateManyAndReturn
   */
  export type RolesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * The data used to update Roles.
     */
    data: XOR<RolesUpdateManyMutationInput, RolesUncheckedUpdateManyInput>
    /**
     * Filter which Roles to update
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to update.
     */
    limit?: number
  }

  /**
   * Roles upsert
   */
  export type RolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * The filter to search for the Roles to update in case it exists.
     */
    where: RolesWhereUniqueInput
    /**
     * In case the Roles found by the `where` argument doesn't exist, create a new Roles with this data.
     */
    create: XOR<RolesCreateInput, RolesUncheckedCreateInput>
    /**
     * In case the Roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RolesUpdateInput, RolesUncheckedUpdateInput>
  }

  /**
   * Roles delete
   */
  export type RolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    /**
     * Filter which Roles to delete.
     */
    where: RolesWhereUniqueInput
  }

  /**
   * Roles deleteMany
   */
  export type RolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roles to delete
     */
    where?: RolesWhereInput
    /**
     * Limit how many Roles to delete.
     */
    limit?: number
  }

  /**
   * Roles.usuario_rol
   */
  export type Roles$usuario_rolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    where?: UsuarioRolWhereInput
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    cursor?: UsuarioRolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * Roles without action
   */
  export type RolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
  }


  /**
   * Model Tutores
   */

  export type AggregateTutores = {
    _count: TutoresCountAggregateOutputType | null
    _avg: TutoresAvgAggregateOutputType | null
    _sum: TutoresSumAggregateOutputType | null
    _min: TutoresMinAggregateOutputType | null
    _max: TutoresMaxAggregateOutputType | null
  }

  export type TutoresAvgAggregateOutputType = {
    id: number | null
  }

  export type TutoresSumAggregateOutputType = {
    id: number | null
  }

  export type TutoresMinAggregateOutputType = {
    id: number | null
    nombre: string | null
    ap_paterno: string | null
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento | null
    numero_documento: string | null
    telefono: string | null
    correo: string | null
    unidad_educativa: string | null
    profesion: string | null
    creado_en: Date | null
  }

  export type TutoresMaxAggregateOutputType = {
    id: number | null
    nombre: string | null
    ap_paterno: string | null
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento | null
    numero_documento: string | null
    telefono: string | null
    correo: string | null
    unidad_educativa: string | null
    profesion: string | null
    creado_en: Date | null
  }

  export type TutoresCountAggregateOutputType = {
    id: number
    nombre: number
    ap_paterno: number
    ap_materno: number
    tipo_documento: number
    numero_documento: number
    telefono: number
    correo: number
    unidad_educativa: number
    profesion: number
    creado_en: number
    _all: number
  }


  export type TutoresAvgAggregateInputType = {
    id?: true
  }

  export type TutoresSumAggregateInputType = {
    id?: true
  }

  export type TutoresMinAggregateInputType = {
    id?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    telefono?: true
    correo?: true
    unidad_educativa?: true
    profesion?: true
    creado_en?: true
  }

  export type TutoresMaxAggregateInputType = {
    id?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    telefono?: true
    correo?: true
    unidad_educativa?: true
    profesion?: true
    creado_en?: true
  }

  export type TutoresCountAggregateInputType = {
    id?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    telefono?: true
    correo?: true
    unidad_educativa?: true
    profesion?: true
    creado_en?: true
    _all?: true
  }

  export type TutoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutores to aggregate.
     */
    where?: TutoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutores to fetch.
     */
    orderBy?: TutoresOrderByWithRelationInput | TutoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TutoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tutores
    **/
    _count?: true | TutoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TutoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TutoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TutoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TutoresMaxAggregateInputType
  }

  export type GetTutoresAggregateType<T extends TutoresAggregateArgs> = {
        [P in keyof T & keyof AggregateTutores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTutores[P]>
      : GetScalarType<T[P], AggregateTutores[P]>
  }




  export type TutoresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TutoresWhereInput
    orderBy?: TutoresOrderByWithAggregationInput | TutoresOrderByWithAggregationInput[]
    by: TutoresScalarFieldEnum[] | TutoresScalarFieldEnum
    having?: TutoresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TutoresCountAggregateInputType | true
    _avg?: TutoresAvgAggregateInputType
    _sum?: TutoresSumAggregateInputType
    _min?: TutoresMinAggregateInputType
    _max?: TutoresMaxAggregateInputType
  }

  export type TutoresGroupByOutputType = {
    id: number
    nombre: string
    ap_paterno: string
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    telefono: string | null
    correo: string | null
    unidad_educativa: string
    profesion: string | null
    creado_en: Date
    _count: TutoresCountAggregateOutputType | null
    _avg: TutoresAvgAggregateOutputType | null
    _sum: TutoresSumAggregateOutputType | null
    _min: TutoresMinAggregateOutputType | null
    _max: TutoresMaxAggregateOutputType | null
  }

  type GetTutoresGroupByPayload<T extends TutoresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TutoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TutoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TutoresGroupByOutputType[P]>
            : GetScalarType<T[P], TutoresGroupByOutputType[P]>
        }
      >
    >


  export type TutoresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    telefono?: boolean
    correo?: boolean
    unidad_educativa?: boolean
    profesion?: boolean
    creado_en?: boolean
    olimpistas?: boolean | Tutores$olimpistasArgs<ExtArgs>
    _count?: boolean | TutoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tutores"]>

  export type TutoresSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    telefono?: boolean
    correo?: boolean
    unidad_educativa?: boolean
    profesion?: boolean
    creado_en?: boolean
  }, ExtArgs["result"]["tutores"]>

  export type TutoresSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    telefono?: boolean
    correo?: boolean
    unidad_educativa?: boolean
    profesion?: boolean
    creado_en?: boolean
  }, ExtArgs["result"]["tutores"]>

  export type TutoresSelectScalar = {
    id?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    telefono?: boolean
    correo?: boolean
    unidad_educativa?: boolean
    profesion?: boolean
    creado_en?: boolean
  }

  export type TutoresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nombre" | "ap_paterno" | "ap_materno" | "tipo_documento" | "numero_documento" | "telefono" | "correo" | "unidad_educativa" | "profesion" | "creado_en", ExtArgs["result"]["tutores"]>
  export type TutoresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    olimpistas?: boolean | Tutores$olimpistasArgs<ExtArgs>
    _count?: boolean | TutoresCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TutoresIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TutoresIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TutoresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tutores"
    objects: {
      olimpistas: Prisma.$OlimpistasPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nombre: string
      ap_paterno: string
      ap_materno: string | null
      tipo_documento: $Enums.TipoDocumento
      numero_documento: string
      telefono: string | null
      correo: string | null
      unidad_educativa: string
      profesion: string | null
      creado_en: Date
    }, ExtArgs["result"]["tutores"]>
    composites: {}
  }

  type TutoresGetPayload<S extends boolean | null | undefined | TutoresDefaultArgs> = $Result.GetResult<Prisma.$TutoresPayload, S>

  type TutoresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TutoresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TutoresCountAggregateInputType | true
    }

  export interface TutoresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tutores'], meta: { name: 'Tutores' } }
    /**
     * Find zero or one Tutores that matches the filter.
     * @param {TutoresFindUniqueArgs} args - Arguments to find a Tutores
     * @example
     * // Get one Tutores
     * const tutores = await prisma.tutores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TutoresFindUniqueArgs>(args: SelectSubset<T, TutoresFindUniqueArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tutores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TutoresFindUniqueOrThrowArgs} args - Arguments to find a Tutores
     * @example
     * // Get one Tutores
     * const tutores = await prisma.tutores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TutoresFindUniqueOrThrowArgs>(args: SelectSubset<T, TutoresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresFindFirstArgs} args - Arguments to find a Tutores
     * @example
     * // Get one Tutores
     * const tutores = await prisma.tutores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TutoresFindFirstArgs>(args?: SelectSubset<T, TutoresFindFirstArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tutores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresFindFirstOrThrowArgs} args - Arguments to find a Tutores
     * @example
     * // Get one Tutores
     * const tutores = await prisma.tutores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TutoresFindFirstOrThrowArgs>(args?: SelectSubset<T, TutoresFindFirstOrThrowArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tutores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tutores
     * const tutores = await prisma.tutores.findMany()
     * 
     * // Get first 10 Tutores
     * const tutores = await prisma.tutores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tutoresWithIdOnly = await prisma.tutores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TutoresFindManyArgs>(args?: SelectSubset<T, TutoresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tutores.
     * @param {TutoresCreateArgs} args - Arguments to create a Tutores.
     * @example
     * // Create one Tutores
     * const Tutores = await prisma.tutores.create({
     *   data: {
     *     // ... data to create a Tutores
     *   }
     * })
     * 
     */
    create<T extends TutoresCreateArgs>(args: SelectSubset<T, TutoresCreateArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tutores.
     * @param {TutoresCreateManyArgs} args - Arguments to create many Tutores.
     * @example
     * // Create many Tutores
     * const tutores = await prisma.tutores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TutoresCreateManyArgs>(args?: SelectSubset<T, TutoresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tutores and returns the data saved in the database.
     * @param {TutoresCreateManyAndReturnArgs} args - Arguments to create many Tutores.
     * @example
     * // Create many Tutores
     * const tutores = await prisma.tutores.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tutores and only return the `id`
     * const tutoresWithIdOnly = await prisma.tutores.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TutoresCreateManyAndReturnArgs>(args?: SelectSubset<T, TutoresCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tutores.
     * @param {TutoresDeleteArgs} args - Arguments to delete one Tutores.
     * @example
     * // Delete one Tutores
     * const Tutores = await prisma.tutores.delete({
     *   where: {
     *     // ... filter to delete one Tutores
     *   }
     * })
     * 
     */
    delete<T extends TutoresDeleteArgs>(args: SelectSubset<T, TutoresDeleteArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tutores.
     * @param {TutoresUpdateArgs} args - Arguments to update one Tutores.
     * @example
     * // Update one Tutores
     * const tutores = await prisma.tutores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TutoresUpdateArgs>(args: SelectSubset<T, TutoresUpdateArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tutores.
     * @param {TutoresDeleteManyArgs} args - Arguments to filter Tutores to delete.
     * @example
     * // Delete a few Tutores
     * const { count } = await prisma.tutores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TutoresDeleteManyArgs>(args?: SelectSubset<T, TutoresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tutores
     * const tutores = await prisma.tutores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TutoresUpdateManyArgs>(args: SelectSubset<T, TutoresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tutores and returns the data updated in the database.
     * @param {TutoresUpdateManyAndReturnArgs} args - Arguments to update many Tutores.
     * @example
     * // Update many Tutores
     * const tutores = await prisma.tutores.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tutores and only return the `id`
     * const tutoresWithIdOnly = await prisma.tutores.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TutoresUpdateManyAndReturnArgs>(args: SelectSubset<T, TutoresUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tutores.
     * @param {TutoresUpsertArgs} args - Arguments to update or create a Tutores.
     * @example
     * // Update or create a Tutores
     * const tutores = await prisma.tutores.upsert({
     *   create: {
     *     // ... data to create a Tutores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tutores we want to update
     *   }
     * })
     */
    upsert<T extends TutoresUpsertArgs>(args: SelectSubset<T, TutoresUpsertArgs<ExtArgs>>): Prisma__TutoresClient<$Result.GetResult<Prisma.$TutoresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tutores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresCountArgs} args - Arguments to filter Tutores to count.
     * @example
     * // Count the number of Tutores
     * const count = await prisma.tutores.count({
     *   where: {
     *     // ... the filter for the Tutores we want to count
     *   }
     * })
    **/
    count<T extends TutoresCountArgs>(
      args?: Subset<T, TutoresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TutoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tutores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TutoresAggregateArgs>(args: Subset<T, TutoresAggregateArgs>): Prisma.PrismaPromise<GetTutoresAggregateType<T>>

    /**
     * Group by Tutores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TutoresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TutoresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TutoresGroupByArgs['orderBy'] }
        : { orderBy?: TutoresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TutoresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTutoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tutores model
   */
  readonly fields: TutoresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tutores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TutoresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    olimpistas<T extends Tutores$olimpistasArgs<ExtArgs> = {}>(args?: Subset<T, Tutores$olimpistasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OlimpistasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tutores model
   */
  interface TutoresFieldRefs {
    readonly id: FieldRef<"Tutores", 'Int'>
    readonly nombre: FieldRef<"Tutores", 'String'>
    readonly ap_paterno: FieldRef<"Tutores", 'String'>
    readonly ap_materno: FieldRef<"Tutores", 'String'>
    readonly tipo_documento: FieldRef<"Tutores", 'TipoDocumento'>
    readonly numero_documento: FieldRef<"Tutores", 'String'>
    readonly telefono: FieldRef<"Tutores", 'String'>
    readonly correo: FieldRef<"Tutores", 'String'>
    readonly unidad_educativa: FieldRef<"Tutores", 'String'>
    readonly profesion: FieldRef<"Tutores", 'String'>
    readonly creado_en: FieldRef<"Tutores", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tutores findUnique
   */
  export type TutoresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * Filter, which Tutores to fetch.
     */
    where: TutoresWhereUniqueInput
  }

  /**
   * Tutores findUniqueOrThrow
   */
  export type TutoresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * Filter, which Tutores to fetch.
     */
    where: TutoresWhereUniqueInput
  }

  /**
   * Tutores findFirst
   */
  export type TutoresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * Filter, which Tutores to fetch.
     */
    where?: TutoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutores to fetch.
     */
    orderBy?: TutoresOrderByWithRelationInput | TutoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutores.
     */
    cursor?: TutoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutores.
     */
    distinct?: TutoresScalarFieldEnum | TutoresScalarFieldEnum[]
  }

  /**
   * Tutores findFirstOrThrow
   */
  export type TutoresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * Filter, which Tutores to fetch.
     */
    where?: TutoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutores to fetch.
     */
    orderBy?: TutoresOrderByWithRelationInput | TutoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tutores.
     */
    cursor?: TutoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tutores.
     */
    distinct?: TutoresScalarFieldEnum | TutoresScalarFieldEnum[]
  }

  /**
   * Tutores findMany
   */
  export type TutoresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * Filter, which Tutores to fetch.
     */
    where?: TutoresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tutores to fetch.
     */
    orderBy?: TutoresOrderByWithRelationInput | TutoresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tutores.
     */
    cursor?: TutoresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tutores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tutores.
     */
    skip?: number
    distinct?: TutoresScalarFieldEnum | TutoresScalarFieldEnum[]
  }

  /**
   * Tutores create
   */
  export type TutoresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * The data needed to create a Tutores.
     */
    data: XOR<TutoresCreateInput, TutoresUncheckedCreateInput>
  }

  /**
   * Tutores createMany
   */
  export type TutoresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tutores.
     */
    data: TutoresCreateManyInput | TutoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tutores createManyAndReturn
   */
  export type TutoresCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * The data used to create many Tutores.
     */
    data: TutoresCreateManyInput | TutoresCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tutores update
   */
  export type TutoresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * The data needed to update a Tutores.
     */
    data: XOR<TutoresUpdateInput, TutoresUncheckedUpdateInput>
    /**
     * Choose, which Tutores to update.
     */
    where: TutoresWhereUniqueInput
  }

  /**
   * Tutores updateMany
   */
  export type TutoresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tutores.
     */
    data: XOR<TutoresUpdateManyMutationInput, TutoresUncheckedUpdateManyInput>
    /**
     * Filter which Tutores to update
     */
    where?: TutoresWhereInput
    /**
     * Limit how many Tutores to update.
     */
    limit?: number
  }

  /**
   * Tutores updateManyAndReturn
   */
  export type TutoresUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * The data used to update Tutores.
     */
    data: XOR<TutoresUpdateManyMutationInput, TutoresUncheckedUpdateManyInput>
    /**
     * Filter which Tutores to update
     */
    where?: TutoresWhereInput
    /**
     * Limit how many Tutores to update.
     */
    limit?: number
  }

  /**
   * Tutores upsert
   */
  export type TutoresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * The filter to search for the Tutores to update in case it exists.
     */
    where: TutoresWhereUniqueInput
    /**
     * In case the Tutores found by the `where` argument doesn't exist, create a new Tutores with this data.
     */
    create: XOR<TutoresCreateInput, TutoresUncheckedCreateInput>
    /**
     * In case the Tutores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TutoresUpdateInput, TutoresUncheckedUpdateInput>
  }

  /**
   * Tutores delete
   */
  export type TutoresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
    /**
     * Filter which Tutores to delete.
     */
    where: TutoresWhereUniqueInput
  }

  /**
   * Tutores deleteMany
   */
  export type TutoresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tutores to delete
     */
    where?: TutoresWhereInput
    /**
     * Limit how many Tutores to delete.
     */
    limit?: number
  }

  /**
   * Tutores.olimpistas
   */
  export type Tutores$olimpistasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Olimpistas
     */
    select?: OlimpistasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Olimpistas
     */
    omit?: OlimpistasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OlimpistasInclude<ExtArgs> | null
    where?: OlimpistasWhereInput
    orderBy?: OlimpistasOrderByWithRelationInput | OlimpistasOrderByWithRelationInput[]
    cursor?: OlimpistasWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OlimpistasScalarFieldEnum | OlimpistasScalarFieldEnum[]
  }

  /**
   * Tutores without action
   */
  export type TutoresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tutores
     */
    select?: TutoresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tutores
     */
    omit?: TutoresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TutoresInclude<ExtArgs> | null
  }


  /**
   * Model UsuarioRol
   */

  export type AggregateUsuarioRol = {
    _count: UsuarioRolCountAggregateOutputType | null
    _avg: UsuarioRolAvgAggregateOutputType | null
    _sum: UsuarioRolSumAggregateOutputType | null
    _min: UsuarioRolMinAggregateOutputType | null
    _max: UsuarioRolMaxAggregateOutputType | null
  }

  export type UsuarioRolAvgAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    rol_id: number | null
  }

  export type UsuarioRolSumAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    rol_id: number | null
  }

  export type UsuarioRolMinAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    rol_id: number | null
  }

  export type UsuarioRolMaxAggregateOutputType = {
    id: number | null
    usuario_id: number | null
    rol_id: number | null
  }

  export type UsuarioRolCountAggregateOutputType = {
    id: number
    usuario_id: number
    rol_id: number
    _all: number
  }


  export type UsuarioRolAvgAggregateInputType = {
    id?: true
    usuario_id?: true
    rol_id?: true
  }

  export type UsuarioRolSumAggregateInputType = {
    id?: true
    usuario_id?: true
    rol_id?: true
  }

  export type UsuarioRolMinAggregateInputType = {
    id?: true
    usuario_id?: true
    rol_id?: true
  }

  export type UsuarioRolMaxAggregateInputType = {
    id?: true
    usuario_id?: true
    rol_id?: true
  }

  export type UsuarioRolCountAggregateInputType = {
    id?: true
    usuario_id?: true
    rol_id?: true
    _all?: true
  }

  export type UsuarioRolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioRol to aggregate.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsuarioRols
    **/
    _count?: true | UsuarioRolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioRolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioRolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioRolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioRolMaxAggregateInputType
  }

  export type GetUsuarioRolAggregateType<T extends UsuarioRolAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarioRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarioRol[P]>
      : GetScalarType<T[P], AggregateUsuarioRol[P]>
  }




  export type UsuarioRolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioRolWhereInput
    orderBy?: UsuarioRolOrderByWithAggregationInput | UsuarioRolOrderByWithAggregationInput[]
    by: UsuarioRolScalarFieldEnum[] | UsuarioRolScalarFieldEnum
    having?: UsuarioRolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioRolCountAggregateInputType | true
    _avg?: UsuarioRolAvgAggregateInputType
    _sum?: UsuarioRolSumAggregateInputType
    _min?: UsuarioRolMinAggregateInputType
    _max?: UsuarioRolMaxAggregateInputType
  }

  export type UsuarioRolGroupByOutputType = {
    id: number
    usuario_id: number | null
    rol_id: number | null
    _count: UsuarioRolCountAggregateOutputType | null
    _avg: UsuarioRolAvgAggregateOutputType | null
    _sum: UsuarioRolSumAggregateOutputType | null
    _min: UsuarioRolMinAggregateOutputType | null
    _max: UsuarioRolMaxAggregateOutputType | null
  }

  type GetUsuarioRolGroupByPayload<T extends UsuarioRolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioRolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioRolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioRolGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioRolGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioRolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    rol_id?: boolean
    usuario?: boolean | UsuarioRol$usuarioArgs<ExtArgs>
    rol?: boolean | UsuarioRol$rolArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioRol"]>

  export type UsuarioRolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    rol_id?: boolean
    usuario?: boolean | UsuarioRol$usuarioArgs<ExtArgs>
    rol?: boolean | UsuarioRol$rolArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioRol"]>

  export type UsuarioRolSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuario_id?: boolean
    rol_id?: boolean
    usuario?: boolean | UsuarioRol$usuarioArgs<ExtArgs>
    rol?: boolean | UsuarioRol$rolArgs<ExtArgs>
  }, ExtArgs["result"]["usuarioRol"]>

  export type UsuarioRolSelectScalar = {
    id?: boolean
    usuario_id?: boolean
    rol_id?: boolean
  }

  export type UsuarioRolOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "usuario_id" | "rol_id", ExtArgs["result"]["usuarioRol"]>
  export type UsuarioRolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioRol$usuarioArgs<ExtArgs>
    rol?: boolean | UsuarioRol$rolArgs<ExtArgs>
  }
  export type UsuarioRolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioRol$usuarioArgs<ExtArgs>
    rol?: boolean | UsuarioRol$rolArgs<ExtArgs>
  }
  export type UsuarioRolIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioRol$usuarioArgs<ExtArgs>
    rol?: boolean | UsuarioRol$rolArgs<ExtArgs>
  }

  export type $UsuarioRolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsuarioRol"
    objects: {
      usuario: Prisma.$UsuariosPayload<ExtArgs> | null
      rol: Prisma.$RolesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      usuario_id: number | null
      rol_id: number | null
    }, ExtArgs["result"]["usuarioRol"]>
    composites: {}
  }

  type UsuarioRolGetPayload<S extends boolean | null | undefined | UsuarioRolDefaultArgs> = $Result.GetResult<Prisma.$UsuarioRolPayload, S>

  type UsuarioRolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuarioRolFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuarioRolCountAggregateInputType | true
    }

  export interface UsuarioRolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsuarioRol'], meta: { name: 'UsuarioRol' } }
    /**
     * Find zero or one UsuarioRol that matches the filter.
     * @param {UsuarioRolFindUniqueArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioRolFindUniqueArgs>(args: SelectSubset<T, UsuarioRolFindUniqueArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsuarioRol that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuarioRolFindUniqueOrThrowArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioRolFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioRolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuarioRol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindFirstArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioRolFindFirstArgs>(args?: SelectSubset<T, UsuarioRolFindFirstArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsuarioRol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindFirstOrThrowArgs} args - Arguments to find a UsuarioRol
     * @example
     * // Get one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioRolFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioRolFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsuarioRols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsuarioRols
     * const usuarioRols = await prisma.usuarioRol.findMany()
     * 
     * // Get first 10 UsuarioRols
     * const usuarioRols = await prisma.usuarioRol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioRolWithIdOnly = await prisma.usuarioRol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioRolFindManyArgs>(args?: SelectSubset<T, UsuarioRolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsuarioRol.
     * @param {UsuarioRolCreateArgs} args - Arguments to create a UsuarioRol.
     * @example
     * // Create one UsuarioRol
     * const UsuarioRol = await prisma.usuarioRol.create({
     *   data: {
     *     // ... data to create a UsuarioRol
     *   }
     * })
     * 
     */
    create<T extends UsuarioRolCreateArgs>(args: SelectSubset<T, UsuarioRolCreateArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsuarioRols.
     * @param {UsuarioRolCreateManyArgs} args - Arguments to create many UsuarioRols.
     * @example
     * // Create many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioRolCreateManyArgs>(args?: SelectSubset<T, UsuarioRolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsuarioRols and returns the data saved in the database.
     * @param {UsuarioRolCreateManyAndReturnArgs} args - Arguments to create many UsuarioRols.
     * @example
     * // Create many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsuarioRols and only return the `id`
     * const usuarioRolWithIdOnly = await prisma.usuarioRol.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioRolCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioRolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsuarioRol.
     * @param {UsuarioRolDeleteArgs} args - Arguments to delete one UsuarioRol.
     * @example
     * // Delete one UsuarioRol
     * const UsuarioRol = await prisma.usuarioRol.delete({
     *   where: {
     *     // ... filter to delete one UsuarioRol
     *   }
     * })
     * 
     */
    delete<T extends UsuarioRolDeleteArgs>(args: SelectSubset<T, UsuarioRolDeleteArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsuarioRol.
     * @param {UsuarioRolUpdateArgs} args - Arguments to update one UsuarioRol.
     * @example
     * // Update one UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioRolUpdateArgs>(args: SelectSubset<T, UsuarioRolUpdateArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsuarioRols.
     * @param {UsuarioRolDeleteManyArgs} args - Arguments to filter UsuarioRols to delete.
     * @example
     * // Delete a few UsuarioRols
     * const { count } = await prisma.usuarioRol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioRolDeleteManyArgs>(args?: SelectSubset<T, UsuarioRolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioRolUpdateManyArgs>(args: SelectSubset<T, UsuarioRolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsuarioRols and returns the data updated in the database.
     * @param {UsuarioRolUpdateManyAndReturnArgs} args - Arguments to update many UsuarioRols.
     * @example
     * // Update many UsuarioRols
     * const usuarioRol = await prisma.usuarioRol.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsuarioRols and only return the `id`
     * const usuarioRolWithIdOnly = await prisma.usuarioRol.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuarioRolUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuarioRolUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsuarioRol.
     * @param {UsuarioRolUpsertArgs} args - Arguments to update or create a UsuarioRol.
     * @example
     * // Update or create a UsuarioRol
     * const usuarioRol = await prisma.usuarioRol.upsert({
     *   create: {
     *     // ... data to create a UsuarioRol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsuarioRol we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioRolUpsertArgs>(args: SelectSubset<T, UsuarioRolUpsertArgs<ExtArgs>>): Prisma__UsuarioRolClient<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsuarioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolCountArgs} args - Arguments to filter UsuarioRols to count.
     * @example
     * // Count the number of UsuarioRols
     * const count = await prisma.usuarioRol.count({
     *   where: {
     *     // ... the filter for the UsuarioRols we want to count
     *   }
     * })
    **/
    count<T extends UsuarioRolCountArgs>(
      args?: Subset<T, UsuarioRolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioRolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsuarioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioRolAggregateArgs>(args: Subset<T, UsuarioRolAggregateArgs>): Prisma.PrismaPromise<GetUsuarioRolAggregateType<T>>

    /**
     * Group by UsuarioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioRolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioRolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioRolGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioRolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioRolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsuarioRol model
   */
  readonly fields: UsuarioRolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsuarioRol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioRolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioRol$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioRol$usuarioArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    rol<T extends UsuarioRol$rolArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioRol$rolArgs<ExtArgs>>): Prisma__RolesClient<$Result.GetResult<Prisma.$RolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsuarioRol model
   */
  interface UsuarioRolFieldRefs {
    readonly id: FieldRef<"UsuarioRol", 'Int'>
    readonly usuario_id: FieldRef<"UsuarioRol", 'Int'>
    readonly rol_id: FieldRef<"UsuarioRol", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * UsuarioRol findUnique
   */
  export type UsuarioRolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol findUniqueOrThrow
   */
  export type UsuarioRolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol findFirst
   */
  export type UsuarioRolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioRols.
     */
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * UsuarioRol findFirstOrThrow
   */
  export type UsuarioRolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRol to fetch.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsuarioRols.
     */
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * UsuarioRol findMany
   */
  export type UsuarioRolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter, which UsuarioRols to fetch.
     */
    where?: UsuarioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsuarioRols to fetch.
     */
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsuarioRols.
     */
    cursor?: UsuarioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsuarioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsuarioRols.
     */
    skip?: number
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * UsuarioRol create
   */
  export type UsuarioRolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * The data needed to create a UsuarioRol.
     */
    data?: XOR<UsuarioRolCreateInput, UsuarioRolUncheckedCreateInput>
  }

  /**
   * UsuarioRol createMany
   */
  export type UsuarioRolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsuarioRols.
     */
    data: UsuarioRolCreateManyInput | UsuarioRolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsuarioRol createManyAndReturn
   */
  export type UsuarioRolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * The data used to create many UsuarioRols.
     */
    data: UsuarioRolCreateManyInput | UsuarioRolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioRol update
   */
  export type UsuarioRolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * The data needed to update a UsuarioRol.
     */
    data: XOR<UsuarioRolUpdateInput, UsuarioRolUncheckedUpdateInput>
    /**
     * Choose, which UsuarioRol to update.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol updateMany
   */
  export type UsuarioRolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsuarioRols.
     */
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioRols to update
     */
    where?: UsuarioRolWhereInput
    /**
     * Limit how many UsuarioRols to update.
     */
    limit?: number
  }

  /**
   * UsuarioRol updateManyAndReturn
   */
  export type UsuarioRolUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * The data used to update UsuarioRols.
     */
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyInput>
    /**
     * Filter which UsuarioRols to update
     */
    where?: UsuarioRolWhereInput
    /**
     * Limit how many UsuarioRols to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsuarioRol upsert
   */
  export type UsuarioRolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * The filter to search for the UsuarioRol to update in case it exists.
     */
    where: UsuarioRolWhereUniqueInput
    /**
     * In case the UsuarioRol found by the `where` argument doesn't exist, create a new UsuarioRol with this data.
     */
    create: XOR<UsuarioRolCreateInput, UsuarioRolUncheckedCreateInput>
    /**
     * In case the UsuarioRol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioRolUpdateInput, UsuarioRolUncheckedUpdateInput>
  }

  /**
   * UsuarioRol delete
   */
  export type UsuarioRolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    /**
     * Filter which UsuarioRol to delete.
     */
    where: UsuarioRolWhereUniqueInput
  }

  /**
   * UsuarioRol deleteMany
   */
  export type UsuarioRolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsuarioRols to delete
     */
    where?: UsuarioRolWhereInput
    /**
     * Limit how many UsuarioRols to delete.
     */
    limit?: number
  }

  /**
   * UsuarioRol.usuario
   */
  export type UsuarioRol$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    where?: UsuariosWhereInput
  }

  /**
   * UsuarioRol.rol
   */
  export type UsuarioRol$rolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roles
     */
    select?: RolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Roles
     */
    omit?: RolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RolesInclude<ExtArgs> | null
    where?: RolesWhereInput
  }

  /**
   * UsuarioRol without action
   */
  export type UsuarioRolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
  }


  /**
   * Model Usuarios
   */

  export type AggregateUsuarios = {
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  export type UsuariosAvgAggregateOutputType = {
    id: number | null
  }

  export type UsuariosSumAggregateOutputType = {
    id: number | null
  }

  export type UsuariosMinAggregateOutputType = {
    id: number | null
    contrasena_hash: string | null
    nombre: string | null
    ap_paterno: string | null
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento | null
    numero_documento: string | null
    correo: string | null
    telefono: string | null
    cargo: string | null
    profesion: string | null
    institucion: string | null
    estado: boolean | null
    creado_en: Date | null
    actualizado_en: Date | null
  }

  export type UsuariosMaxAggregateOutputType = {
    id: number | null
    contrasena_hash: string | null
    nombre: string | null
    ap_paterno: string | null
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento | null
    numero_documento: string | null
    correo: string | null
    telefono: string | null
    cargo: string | null
    profesion: string | null
    institucion: string | null
    estado: boolean | null
    creado_en: Date | null
    actualizado_en: Date | null
  }

  export type UsuariosCountAggregateOutputType = {
    id: number
    contrasena_hash: number
    nombre: number
    ap_paterno: number
    ap_materno: number
    tipo_documento: number
    numero_documento: number
    correo: number
    telefono: number
    cargo: number
    profesion: number
    institucion: number
    estado: number
    creado_en: number
    actualizado_en: number
    _all: number
  }


  export type UsuariosAvgAggregateInputType = {
    id?: true
  }

  export type UsuariosSumAggregateInputType = {
    id?: true
  }

  export type UsuariosMinAggregateInputType = {
    id?: true
    contrasena_hash?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    correo?: true
    telefono?: true
    cargo?: true
    profesion?: true
    institucion?: true
    estado?: true
    creado_en?: true
    actualizado_en?: true
  }

  export type UsuariosMaxAggregateInputType = {
    id?: true
    contrasena_hash?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    correo?: true
    telefono?: true
    cargo?: true
    profesion?: true
    institucion?: true
    estado?: true
    creado_en?: true
    actualizado_en?: true
  }

  export type UsuariosCountAggregateInputType = {
    id?: true
    contrasena_hash?: true
    nombre?: true
    ap_paterno?: true
    ap_materno?: true
    tipo_documento?: true
    numero_documento?: true
    correo?: true
    telefono?: true
    cargo?: true
    profesion?: true
    institucion?: true
    estado?: true
    creado_en?: true
    actualizado_en?: true
    _all?: true
  }

  export type UsuariosAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to aggregate.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuariosCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuariosAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuariosSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuariosMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuariosMaxAggregateInputType
  }

  export type GetUsuariosAggregateType<T extends UsuariosAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuarios]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuarios[P]>
      : GetScalarType<T[P], AggregateUsuarios[P]>
  }




  export type UsuariosGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuariosWhereInput
    orderBy?: UsuariosOrderByWithAggregationInput | UsuariosOrderByWithAggregationInput[]
    by: UsuariosScalarFieldEnum[] | UsuariosScalarFieldEnum
    having?: UsuariosScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuariosCountAggregateInputType | true
    _avg?: UsuariosAvgAggregateInputType
    _sum?: UsuariosSumAggregateInputType
    _min?: UsuariosMinAggregateInputType
    _max?: UsuariosMaxAggregateInputType
  }

  export type UsuariosGroupByOutputType = {
    id: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono: string | null
    cargo: string | null
    profesion: string | null
    institucion: string | null
    estado: boolean
    creado_en: Date
    actualizado_en: Date | null
    _count: UsuariosCountAggregateOutputType | null
    _avg: UsuariosAvgAggregateOutputType | null
    _sum: UsuariosSumAggregateOutputType | null
    _min: UsuariosMinAggregateOutputType | null
    _max: UsuariosMaxAggregateOutputType | null
  }

  type GetUsuariosGroupByPayload<T extends UsuariosGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuariosGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuariosGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
            : GetScalarType<T[P], UsuariosGroupByOutputType[P]>
        }
      >
    >


  export type UsuariosSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contrasena_hash?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    correo?: boolean
    telefono?: boolean
    cargo?: boolean
    profesion?: boolean
    institucion?: boolean
    estado?: boolean
    creado_en?: boolean
    actualizado_en?: boolean
    evaluaciones?: boolean | Usuarios$evaluacionesArgs<ExtArgs>
    logs?: boolean | Usuarios$logsArgs<ExtArgs>
    reportes?: boolean | Usuarios$reportesArgs<ExtArgs>
    usuario_rol?: boolean | Usuarios$usuario_rolArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contrasena_hash?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    correo?: boolean
    telefono?: boolean
    cargo?: boolean
    profesion?: boolean
    institucion?: boolean
    estado?: boolean
    creado_en?: boolean
    actualizado_en?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contrasena_hash?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    correo?: boolean
    telefono?: boolean
    cargo?: boolean
    profesion?: boolean
    institucion?: boolean
    estado?: boolean
    creado_en?: boolean
    actualizado_en?: boolean
  }, ExtArgs["result"]["usuarios"]>

  export type UsuariosSelectScalar = {
    id?: boolean
    contrasena_hash?: boolean
    nombre?: boolean
    ap_paterno?: boolean
    ap_materno?: boolean
    tipo_documento?: boolean
    numero_documento?: boolean
    correo?: boolean
    telefono?: boolean
    cargo?: boolean
    profesion?: boolean
    institucion?: boolean
    estado?: boolean
    creado_en?: boolean
    actualizado_en?: boolean
  }

  export type UsuariosOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contrasena_hash" | "nombre" | "ap_paterno" | "ap_materno" | "tipo_documento" | "numero_documento" | "correo" | "telefono" | "cargo" | "profesion" | "institucion" | "estado" | "creado_en" | "actualizado_en", ExtArgs["result"]["usuarios"]>
  export type UsuariosInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    evaluaciones?: boolean | Usuarios$evaluacionesArgs<ExtArgs>
    logs?: boolean | Usuarios$logsArgs<ExtArgs>
    reportes?: boolean | Usuarios$reportesArgs<ExtArgs>
    usuario_rol?: boolean | Usuarios$usuario_rolArgs<ExtArgs>
    _count?: boolean | UsuariosCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuariosIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UsuariosIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UsuariosPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuarios"
    objects: {
      evaluaciones: Prisma.$EvaluacionesPayload<ExtArgs>[]
      logs: Prisma.$LogsPayload<ExtArgs>[]
      reportes: Prisma.$ReportesPayload<ExtArgs>[]
      usuario_rol: Prisma.$UsuarioRolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      contrasena_hash: string
      nombre: string
      ap_paterno: string
      ap_materno: string | null
      tipo_documento: $Enums.TipoDocumento
      numero_documento: string
      correo: string
      telefono: string | null
      cargo: string | null
      profesion: string | null
      institucion: string | null
      estado: boolean
      creado_en: Date
      actualizado_en: Date | null
    }, ExtArgs["result"]["usuarios"]>
    composites: {}
  }

  type UsuariosGetPayload<S extends boolean | null | undefined | UsuariosDefaultArgs> = $Result.GetResult<Prisma.$UsuariosPayload, S>

  type UsuariosCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsuariosFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsuariosCountAggregateInputType | true
    }

  export interface UsuariosDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuarios'], meta: { name: 'Usuarios' } }
    /**
     * Find zero or one Usuarios that matches the filter.
     * @param {UsuariosFindUniqueArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuariosFindUniqueArgs>(args: SelectSubset<T, UsuariosFindUniqueArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Usuarios that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsuariosFindUniqueOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuariosFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuariosFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuariosFindFirstArgs>(args?: SelectSubset<T, UsuariosFindFirstArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Usuarios that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindFirstOrThrowArgs} args - Arguments to find a Usuarios
     * @example
     * // Get one Usuarios
     * const usuarios = await prisma.usuarios.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuariosFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuariosFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuarios.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuarios.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuariosFindManyArgs>(args?: SelectSubset<T, UsuariosFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Usuarios.
     * @param {UsuariosCreateArgs} args - Arguments to create a Usuarios.
     * @example
     * // Create one Usuarios
     * const Usuarios = await prisma.usuarios.create({
     *   data: {
     *     // ... data to create a Usuarios
     *   }
     * })
     * 
     */
    create<T extends UsuariosCreateArgs>(args: SelectSubset<T, UsuariosCreateArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Usuarios.
     * @param {UsuariosCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuariosCreateManyArgs>(args?: SelectSubset<T, UsuariosCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuariosCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuarios = await prisma.usuarios.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuariosCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuariosCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Usuarios.
     * @param {UsuariosDeleteArgs} args - Arguments to delete one Usuarios.
     * @example
     * // Delete one Usuarios
     * const Usuarios = await prisma.usuarios.delete({
     *   where: {
     *     // ... filter to delete one Usuarios
     *   }
     * })
     * 
     */
    delete<T extends UsuariosDeleteArgs>(args: SelectSubset<T, UsuariosDeleteArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Usuarios.
     * @param {UsuariosUpdateArgs} args - Arguments to update one Usuarios.
     * @example
     * // Update one Usuarios
     * const usuarios = await prisma.usuarios.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuariosUpdateArgs>(args: SelectSubset<T, UsuariosUpdateArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuariosDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuarios.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuariosDeleteManyArgs>(args?: SelectSubset<T, UsuariosDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuariosUpdateManyArgs>(args: SelectSubset<T, UsuariosUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios and returns the data updated in the database.
     * @param {UsuariosUpdateManyAndReturnArgs} args - Arguments to update many Usuarios.
     * @example
     * // Update many Usuarios
     * const usuarios = await prisma.usuarios.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Usuarios and only return the `id`
     * const usuariosWithIdOnly = await prisma.usuarios.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsuariosUpdateManyAndReturnArgs>(args: SelectSubset<T, UsuariosUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Usuarios.
     * @param {UsuariosUpsertArgs} args - Arguments to update or create a Usuarios.
     * @example
     * // Update or create a Usuarios
     * const usuarios = await prisma.usuarios.upsert({
     *   create: {
     *     // ... data to create a Usuarios
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuarios we want to update
     *   }
     * })
     */
    upsert<T extends UsuariosUpsertArgs>(args: SelectSubset<T, UsuariosUpsertArgs<ExtArgs>>): Prisma__UsuariosClient<$Result.GetResult<Prisma.$UsuariosPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuarios.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuariosCountArgs>(
      args?: Subset<T, UsuariosCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuariosCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuariosAggregateArgs>(args: Subset<T, UsuariosAggregateArgs>): Prisma.PrismaPromise<GetUsuariosAggregateType<T>>

    /**
     * Group by Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuariosGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuariosGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuariosGroupByArgs['orderBy'] }
        : { orderBy?: UsuariosGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuariosGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuariosGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuarios model
   */
  readonly fields: UsuariosFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuarios.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuariosClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    evaluaciones<T extends Usuarios$evaluacionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$evaluacionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EvaluacionesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    logs<T extends Usuarios$logsArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LogsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reportes<T extends Usuarios$reportesArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$reportesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReportesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usuario_rol<T extends Usuarios$usuario_rolArgs<ExtArgs> = {}>(args?: Subset<T, Usuarios$usuario_rolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioRolPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuarios model
   */
  interface UsuariosFieldRefs {
    readonly id: FieldRef<"Usuarios", 'Int'>
    readonly contrasena_hash: FieldRef<"Usuarios", 'String'>
    readonly nombre: FieldRef<"Usuarios", 'String'>
    readonly ap_paterno: FieldRef<"Usuarios", 'String'>
    readonly ap_materno: FieldRef<"Usuarios", 'String'>
    readonly tipo_documento: FieldRef<"Usuarios", 'TipoDocumento'>
    readonly numero_documento: FieldRef<"Usuarios", 'String'>
    readonly correo: FieldRef<"Usuarios", 'String'>
    readonly telefono: FieldRef<"Usuarios", 'String'>
    readonly cargo: FieldRef<"Usuarios", 'String'>
    readonly profesion: FieldRef<"Usuarios", 'String'>
    readonly institucion: FieldRef<"Usuarios", 'String'>
    readonly estado: FieldRef<"Usuarios", 'Boolean'>
    readonly creado_en: FieldRef<"Usuarios", 'DateTime'>
    readonly actualizado_en: FieldRef<"Usuarios", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Usuarios findUnique
   */
  export type UsuariosFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios findUniqueOrThrow
   */
  export type UsuariosFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios findFirst
   */
  export type UsuariosFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios findFirstOrThrow
   */
  export type UsuariosFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios findMany
   */
  export type UsuariosFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuariosWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuariosOrderByWithRelationInput | UsuariosOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuariosWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuariosScalarFieldEnum | UsuariosScalarFieldEnum[]
  }

  /**
   * Usuarios create
   */
  export type UsuariosCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuarios.
     */
    data: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
  }

  /**
   * Usuarios createMany
   */
  export type UsuariosCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuarios createManyAndReturn
   */
  export type UsuariosCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuariosCreateManyInput | UsuariosCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuarios update
   */
  export type UsuariosUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuarios.
     */
    data: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
    /**
     * Choose, which Usuarios to update.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios updateMany
   */
  export type UsuariosUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuarios updateManyAndReturn
   */
  export type UsuariosUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuariosUpdateManyMutationInput, UsuariosUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to update.
     */
    limit?: number
  }

  /**
   * Usuarios upsert
   */
  export type UsuariosUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuarios to update in case it exists.
     */
    where: UsuariosWhereUniqueInput
    /**
     * In case the Usuarios found by the `where` argument doesn't exist, create a new Usuarios with this data.
     */
    create: XOR<UsuariosCreateInput, UsuariosUncheckedCreateInput>
    /**
     * In case the Usuarios was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuariosUpdateInput, UsuariosUncheckedUpdateInput>
  }

  /**
   * Usuarios delete
   */
  export type UsuariosDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
    /**
     * Filter which Usuarios to delete.
     */
    where: UsuariosWhereUniqueInput
  }

  /**
   * Usuarios deleteMany
   */
  export type UsuariosDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuariosWhereInput
    /**
     * Limit how many Usuarios to delete.
     */
    limit?: number
  }

  /**
   * Usuarios.evaluaciones
   */
  export type Usuarios$evaluacionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Evaluaciones
     */
    select?: EvaluacionesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Evaluaciones
     */
    omit?: EvaluacionesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EvaluacionesInclude<ExtArgs> | null
    where?: EvaluacionesWhereInput
    orderBy?: EvaluacionesOrderByWithRelationInput | EvaluacionesOrderByWithRelationInput[]
    cursor?: EvaluacionesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EvaluacionesScalarFieldEnum | EvaluacionesScalarFieldEnum[]
  }

  /**
   * Usuarios.logs
   */
  export type Usuarios$logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Logs
     */
    select?: LogsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Logs
     */
    omit?: LogsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LogsInclude<ExtArgs> | null
    where?: LogsWhereInput
    orderBy?: LogsOrderByWithRelationInput | LogsOrderByWithRelationInput[]
    cursor?: LogsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LogsScalarFieldEnum | LogsScalarFieldEnum[]
  }

  /**
   * Usuarios.reportes
   */
  export type Usuarios$reportesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reportes
     */
    select?: ReportesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Reportes
     */
    omit?: ReportesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReportesInclude<ExtArgs> | null
    where?: ReportesWhereInput
    orderBy?: ReportesOrderByWithRelationInput | ReportesOrderByWithRelationInput[]
    cursor?: ReportesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReportesScalarFieldEnum | ReportesScalarFieldEnum[]
  }

  /**
   * Usuarios.usuario_rol
   */
  export type Usuarios$usuario_rolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioRol
     */
    select?: UsuarioRolSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsuarioRol
     */
    omit?: UsuarioRolOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioRolInclude<ExtArgs> | null
    where?: UsuarioRolWhereInput
    orderBy?: UsuarioRolOrderByWithRelationInput | UsuarioRolOrderByWithRelationInput[]
    cursor?: UsuarioRolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioRolScalarFieldEnum | UsuarioRolScalarFieldEnum[]
  }

  /**
   * Usuarios without action
   */
  export type UsuariosDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuarios
     */
    select?: UsuariosSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Usuarios
     */
    omit?: UsuariosOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuariosInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AreasScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    estado: 'estado'
  };

  export type AreasScalarFieldEnum = (typeof AreasScalarFieldEnum)[keyof typeof AreasScalarFieldEnum]


  export const ConfigMedallasScalarFieldEnum: {
    id: 'id',
    area_id: 'area_id',
    nivel_id: 'nivel_id',
    oros: 'oros',
    platas: 'platas',
    bronces: 'bronces',
    menciones: 'menciones'
  };

  export type ConfigMedallasScalarFieldEnum = (typeof ConfigMedallasScalarFieldEnum)[keyof typeof ConfigMedallasScalarFieldEnum]


  export const EvaluacionesScalarFieldEnum: {
    id: 'id',
    participacion_id: 'participacion_id',
    evaluador_id: 'evaluador_id',
    fase_id: 'fase_id',
    nota: 'nota',
    comentario: 'comentario',
    creado_en: 'creado_en',
    validado: 'validado',
    ultima_modificacion: 'ultima_modificacion'
  };

  export type EvaluacionesScalarFieldEnum = (typeof EvaluacionesScalarFieldEnum)[keyof typeof EvaluacionesScalarFieldEnum]


  export const FasesScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    inicio: 'inicio',
    fin: 'fin',
    estado: 'estado'
  };

  export type FasesScalarFieldEnum = (typeof FasesScalarFieldEnum)[keyof typeof FasesScalarFieldEnum]


  export const LogsScalarFieldEnum: {
    id: 'id',
    entidad: 'entidad',
    entidad_id: 'entidad_id',
    campo: 'campo',
    valor_anterior: 'valor_anterior',
    valor_nuevo: 'valor_nuevo',
    usuario_id: 'usuario_id',
    fecha_cambio: 'fecha_cambio',
    motivo: 'motivo'
  };

  export type LogsScalarFieldEnum = (typeof LogsScalarFieldEnum)[keyof typeof LogsScalarFieldEnum]


  export const MiembrosEquipoScalarFieldEnum: {
    id: 'id',
    olimpista_id: 'olimpista_id',
    nombre_equipo: 'nombre_equipo',
    rol_en_equipo: 'rol_en_equipo'
  };

  export type MiembrosEquipoScalarFieldEnum = (typeof MiembrosEquipoScalarFieldEnum)[keyof typeof MiembrosEquipoScalarFieldEnum]


  export const NivelesScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    estado: 'estado'
  };

  export type NivelesScalarFieldEnum = (typeof NivelesScalarFieldEnum)[keyof typeof NivelesScalarFieldEnum]


  export const OlimpistasScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    ap_paterno: 'ap_paterno',
    ap_materno: 'ap_materno',
    tipo_documento: 'tipo_documento',
    numero_documento: 'numero_documento',
    unidad_educativa: 'unidad_educativa',
    departamento: 'departamento',
    grado: 'grado',
    fecha_nacimiento: 'fecha_nacimiento',
    sexo: 'sexo',
    activo: 'activo',
    creado_en: 'creado_en',
    tutor_id: 'tutor_id'
  };

  export type OlimpistasScalarFieldEnum = (typeof OlimpistasScalarFieldEnum)[keyof typeof OlimpistasScalarFieldEnum]


  export const ParticipacionScalarFieldEnum: {
    id: 'id',
    olimpista_id: 'olimpista_id',
    area_id: 'area_id',
    nivel_id: 'nivel_id',
    estado: 'estado',
    tipo: 'tipo'
  };

  export type ParticipacionScalarFieldEnum = (typeof ParticipacionScalarFieldEnum)[keyof typeof ParticipacionScalarFieldEnum]


  export const ReportesScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    parametros: 'parametros',
    archivo: 'archivo',
    generado_por: 'generado_por',
    generado_en: 'generado_en'
  };

  export type ReportesScalarFieldEnum = (typeof ReportesScalarFieldEnum)[keyof typeof ReportesScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const TutoresScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    ap_paterno: 'ap_paterno',
    ap_materno: 'ap_materno',
    tipo_documento: 'tipo_documento',
    numero_documento: 'numero_documento',
    telefono: 'telefono',
    correo: 'correo',
    unidad_educativa: 'unidad_educativa',
    profesion: 'profesion',
    creado_en: 'creado_en'
  };

  export type TutoresScalarFieldEnum = (typeof TutoresScalarFieldEnum)[keyof typeof TutoresScalarFieldEnum]


  export const UsuarioRolScalarFieldEnum: {
    id: 'id',
    usuario_id: 'usuario_id',
    rol_id: 'rol_id'
  };

  export type UsuarioRolScalarFieldEnum = (typeof UsuarioRolScalarFieldEnum)[keyof typeof UsuarioRolScalarFieldEnum]


  export const UsuariosScalarFieldEnum: {
    id: 'id',
    contrasena_hash: 'contrasena_hash',
    nombre: 'nombre',
    ap_paterno: 'ap_paterno',
    ap_materno: 'ap_materno',
    tipo_documento: 'tipo_documento',
    numero_documento: 'numero_documento',
    correo: 'correo',
    telefono: 'telefono',
    cargo: 'cargo',
    profesion: 'profesion',
    institucion: 'institucion',
    estado: 'estado',
    creado_en: 'creado_en',
    actualizado_en: 'actualizado_en'
  };

  export type UsuariosScalarFieldEnum = (typeof UsuariosScalarFieldEnum)[keyof typeof UsuariosScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'EstadoFase'
   */
  export type EnumEstadoFaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoFase'>
    


  /**
   * Reference to a field of type 'EstadoFase[]'
   */
  export type ListEnumEstadoFaseFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoFase[]'>
    


  /**
   * Reference to a field of type 'RolEquipo'
   */
  export type EnumRolEquipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolEquipo'>
    


  /**
   * Reference to a field of type 'RolEquipo[]'
   */
  export type ListEnumRolEquipoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RolEquipo[]'>
    


  /**
   * Reference to a field of type 'TipoDocumento'
   */
  export type EnumTipoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDocumento'>
    


  /**
   * Reference to a field of type 'TipoDocumento[]'
   */
  export type ListEnumTipoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDocumento[]'>
    


  /**
   * Reference to a field of type 'Sexo'
   */
  export type EnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo'>
    


  /**
   * Reference to a field of type 'Sexo[]'
   */
  export type ListEnumSexoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Sexo[]'>
    


  /**
   * Reference to a field of type 'EstadoParticipacion'
   */
  export type EnumEstadoParticipacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoParticipacion'>
    


  /**
   * Reference to a field of type 'EstadoParticipacion[]'
   */
  export type ListEnumEstadoParticipacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoParticipacion[]'>
    


  /**
   * Reference to a field of type 'TipoParticipacion'
   */
  export type EnumTipoParticipacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoParticipacion'>
    


  /**
   * Reference to a field of type 'TipoParticipacion[]'
   */
  export type ListEnumTipoParticipacionFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoParticipacion[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type AreasWhereInput = {
    AND?: AreasWhereInput | AreasWhereInput[]
    OR?: AreasWhereInput[]
    NOT?: AreasWhereInput | AreasWhereInput[]
    id?: IntFilter<"Areas"> | number
    codigo?: StringNullableFilter<"Areas"> | string | null
    nombre?: StringFilter<"Areas"> | string
    descripcion?: StringNullableFilter<"Areas"> | string | null
    estado?: BoolFilter<"Areas"> | boolean
    config_medallas?: ConfigMedallasListRelationFilter
    participacion?: ParticipacionListRelationFilter
  }

  export type AreasOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    config_medallas?: ConfigMedallasOrderByRelationAggregateInput
    participacion?: ParticipacionOrderByRelationAggregateInput
  }

  export type AreasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AreasWhereInput | AreasWhereInput[]
    OR?: AreasWhereInput[]
    NOT?: AreasWhereInput | AreasWhereInput[]
    codigo?: StringNullableFilter<"Areas"> | string | null
    nombre?: StringFilter<"Areas"> | string
    descripcion?: StringNullableFilter<"Areas"> | string | null
    estado?: BoolFilter<"Areas"> | boolean
    config_medallas?: ConfigMedallasListRelationFilter
    participacion?: ParticipacionListRelationFilter
  }, "id">

  export type AreasOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: AreasCountOrderByAggregateInput
    _avg?: AreasAvgOrderByAggregateInput
    _max?: AreasMaxOrderByAggregateInput
    _min?: AreasMinOrderByAggregateInput
    _sum?: AreasSumOrderByAggregateInput
  }

  export type AreasScalarWhereWithAggregatesInput = {
    AND?: AreasScalarWhereWithAggregatesInput | AreasScalarWhereWithAggregatesInput[]
    OR?: AreasScalarWhereWithAggregatesInput[]
    NOT?: AreasScalarWhereWithAggregatesInput | AreasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Areas"> | number
    codigo?: StringNullableWithAggregatesFilter<"Areas"> | string | null
    nombre?: StringWithAggregatesFilter<"Areas"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Areas"> | string | null
    estado?: BoolWithAggregatesFilter<"Areas"> | boolean
  }

  export type ConfigMedallasWhereInput = {
    AND?: ConfigMedallasWhereInput | ConfigMedallasWhereInput[]
    OR?: ConfigMedallasWhereInput[]
    NOT?: ConfigMedallasWhereInput | ConfigMedallasWhereInput[]
    id?: IntFilter<"ConfigMedallas"> | number
    area_id?: IntFilter<"ConfigMedallas"> | number
    nivel_id?: IntFilter<"ConfigMedallas"> | number
    oros?: IntFilter<"ConfigMedallas"> | number
    platas?: IntFilter<"ConfigMedallas"> | number
    bronces?: IntFilter<"ConfigMedallas"> | number
    menciones?: IntFilter<"ConfigMedallas"> | number
    area?: XOR<AreasScalarRelationFilter, AreasWhereInput>
    nivel?: XOR<NivelesScalarRelationFilter, NivelesWhereInput>
  }

  export type ConfigMedallasOrderByWithRelationInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
    area?: AreasOrderByWithRelationInput
    nivel?: NivelesOrderByWithRelationInput
  }

  export type ConfigMedallasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ConfigMedallasWhereInput | ConfigMedallasWhereInput[]
    OR?: ConfigMedallasWhereInput[]
    NOT?: ConfigMedallasWhereInput | ConfigMedallasWhereInput[]
    area_id?: IntFilter<"ConfigMedallas"> | number
    nivel_id?: IntFilter<"ConfigMedallas"> | number
    oros?: IntFilter<"ConfigMedallas"> | number
    platas?: IntFilter<"ConfigMedallas"> | number
    bronces?: IntFilter<"ConfigMedallas"> | number
    menciones?: IntFilter<"ConfigMedallas"> | number
    area?: XOR<AreasScalarRelationFilter, AreasWhereInput>
    nivel?: XOR<NivelesScalarRelationFilter, NivelesWhereInput>
  }, "id">

  export type ConfigMedallasOrderByWithAggregationInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
    _count?: ConfigMedallasCountOrderByAggregateInput
    _avg?: ConfigMedallasAvgOrderByAggregateInput
    _max?: ConfigMedallasMaxOrderByAggregateInput
    _min?: ConfigMedallasMinOrderByAggregateInput
    _sum?: ConfigMedallasSumOrderByAggregateInput
  }

  export type ConfigMedallasScalarWhereWithAggregatesInput = {
    AND?: ConfigMedallasScalarWhereWithAggregatesInput | ConfigMedallasScalarWhereWithAggregatesInput[]
    OR?: ConfigMedallasScalarWhereWithAggregatesInput[]
    NOT?: ConfigMedallasScalarWhereWithAggregatesInput | ConfigMedallasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ConfigMedallas"> | number
    area_id?: IntWithAggregatesFilter<"ConfigMedallas"> | number
    nivel_id?: IntWithAggregatesFilter<"ConfigMedallas"> | number
    oros?: IntWithAggregatesFilter<"ConfigMedallas"> | number
    platas?: IntWithAggregatesFilter<"ConfigMedallas"> | number
    bronces?: IntWithAggregatesFilter<"ConfigMedallas"> | number
    menciones?: IntWithAggregatesFilter<"ConfigMedallas"> | number
  }

  export type EvaluacionesWhereInput = {
    AND?: EvaluacionesWhereInput | EvaluacionesWhereInput[]
    OR?: EvaluacionesWhereInput[]
    NOT?: EvaluacionesWhereInput | EvaluacionesWhereInput[]
    id?: IntFilter<"Evaluaciones"> | number
    participacion_id?: IntFilter<"Evaluaciones"> | number
    evaluador_id?: IntNullableFilter<"Evaluaciones"> | number | null
    fase_id?: IntNullableFilter<"Evaluaciones"> | number | null
    nota?: DecimalFilter<"Evaluaciones"> | Decimal | DecimalJsLike | number | string
    comentario?: StringNullableFilter<"Evaluaciones"> | string | null
    creado_en?: DateTimeFilter<"Evaluaciones"> | Date | string
    validado?: BoolNullableFilter<"Evaluaciones"> | boolean | null
    ultima_modificacion?: DateTimeNullableFilter<"Evaluaciones"> | Date | string | null
    participacion?: XOR<ParticipacionScalarRelationFilter, ParticipacionWhereInput>
    evaluador?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
    fase?: XOR<FasesNullableScalarRelationFilter, FasesWhereInput> | null
  }

  export type EvaluacionesOrderByWithRelationInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrderInput | SortOrder
    fase_id?: SortOrderInput | SortOrder
    nota?: SortOrder
    comentario?: SortOrderInput | SortOrder
    creado_en?: SortOrder
    validado?: SortOrderInput | SortOrder
    ultima_modificacion?: SortOrderInput | SortOrder
    participacion?: ParticipacionOrderByWithRelationInput
    evaluador?: UsuariosOrderByWithRelationInput
    fase?: FasesOrderByWithRelationInput
  }

  export type EvaluacionesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: EvaluacionesWhereInput | EvaluacionesWhereInput[]
    OR?: EvaluacionesWhereInput[]
    NOT?: EvaluacionesWhereInput | EvaluacionesWhereInput[]
    participacion_id?: IntFilter<"Evaluaciones"> | number
    evaluador_id?: IntNullableFilter<"Evaluaciones"> | number | null
    fase_id?: IntNullableFilter<"Evaluaciones"> | number | null
    nota?: DecimalFilter<"Evaluaciones"> | Decimal | DecimalJsLike | number | string
    comentario?: StringNullableFilter<"Evaluaciones"> | string | null
    creado_en?: DateTimeFilter<"Evaluaciones"> | Date | string
    validado?: BoolNullableFilter<"Evaluaciones"> | boolean | null
    ultima_modificacion?: DateTimeNullableFilter<"Evaluaciones"> | Date | string | null
    participacion?: XOR<ParticipacionScalarRelationFilter, ParticipacionWhereInput>
    evaluador?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
    fase?: XOR<FasesNullableScalarRelationFilter, FasesWhereInput> | null
  }, "id">

  export type EvaluacionesOrderByWithAggregationInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrderInput | SortOrder
    fase_id?: SortOrderInput | SortOrder
    nota?: SortOrder
    comentario?: SortOrderInput | SortOrder
    creado_en?: SortOrder
    validado?: SortOrderInput | SortOrder
    ultima_modificacion?: SortOrderInput | SortOrder
    _count?: EvaluacionesCountOrderByAggregateInput
    _avg?: EvaluacionesAvgOrderByAggregateInput
    _max?: EvaluacionesMaxOrderByAggregateInput
    _min?: EvaluacionesMinOrderByAggregateInput
    _sum?: EvaluacionesSumOrderByAggregateInput
  }

  export type EvaluacionesScalarWhereWithAggregatesInput = {
    AND?: EvaluacionesScalarWhereWithAggregatesInput | EvaluacionesScalarWhereWithAggregatesInput[]
    OR?: EvaluacionesScalarWhereWithAggregatesInput[]
    NOT?: EvaluacionesScalarWhereWithAggregatesInput | EvaluacionesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Evaluaciones"> | number
    participacion_id?: IntWithAggregatesFilter<"Evaluaciones"> | number
    evaluador_id?: IntNullableWithAggregatesFilter<"Evaluaciones"> | number | null
    fase_id?: IntNullableWithAggregatesFilter<"Evaluaciones"> | number | null
    nota?: DecimalWithAggregatesFilter<"Evaluaciones"> | Decimal | DecimalJsLike | number | string
    comentario?: StringNullableWithAggregatesFilter<"Evaluaciones"> | string | null
    creado_en?: DateTimeWithAggregatesFilter<"Evaluaciones"> | Date | string
    validado?: BoolNullableWithAggregatesFilter<"Evaluaciones"> | boolean | null
    ultima_modificacion?: DateTimeNullableWithAggregatesFilter<"Evaluaciones"> | Date | string | null
  }

  export type FasesWhereInput = {
    AND?: FasesWhereInput | FasesWhereInput[]
    OR?: FasesWhereInput[]
    NOT?: FasesWhereInput | FasesWhereInput[]
    id?: IntFilter<"Fases"> | number
    nombre?: StringFilter<"Fases"> | string
    descripcion?: StringNullableFilter<"Fases"> | string | null
    inicio?: DateTimeNullableFilter<"Fases"> | Date | string | null
    fin?: DateTimeNullableFilter<"Fases"> | Date | string | null
    estado?: EnumEstadoFaseFilter<"Fases"> | $Enums.EstadoFase
    evaluaciones?: EvaluacionesListRelationFilter
  }

  export type FasesOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    estado?: SortOrder
    evaluaciones?: EvaluacionesOrderByRelationAggregateInput
  }

  export type FasesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FasesWhereInput | FasesWhereInput[]
    OR?: FasesWhereInput[]
    NOT?: FasesWhereInput | FasesWhereInput[]
    nombre?: StringFilter<"Fases"> | string
    descripcion?: StringNullableFilter<"Fases"> | string | null
    inicio?: DateTimeNullableFilter<"Fases"> | Date | string | null
    fin?: DateTimeNullableFilter<"Fases"> | Date | string | null
    estado?: EnumEstadoFaseFilter<"Fases"> | $Enums.EstadoFase
    evaluaciones?: EvaluacionesListRelationFilter
  }, "id">

  export type FasesOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    inicio?: SortOrderInput | SortOrder
    fin?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: FasesCountOrderByAggregateInput
    _avg?: FasesAvgOrderByAggregateInput
    _max?: FasesMaxOrderByAggregateInput
    _min?: FasesMinOrderByAggregateInput
    _sum?: FasesSumOrderByAggregateInput
  }

  export type FasesScalarWhereWithAggregatesInput = {
    AND?: FasesScalarWhereWithAggregatesInput | FasesScalarWhereWithAggregatesInput[]
    OR?: FasesScalarWhereWithAggregatesInput[]
    NOT?: FasesScalarWhereWithAggregatesInput | FasesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fases"> | number
    nombre?: StringWithAggregatesFilter<"Fases"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Fases"> | string | null
    inicio?: DateTimeNullableWithAggregatesFilter<"Fases"> | Date | string | null
    fin?: DateTimeNullableWithAggregatesFilter<"Fases"> | Date | string | null
    estado?: EnumEstadoFaseWithAggregatesFilter<"Fases"> | $Enums.EstadoFase
  }

  export type LogsWhereInput = {
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    id?: IntFilter<"Logs"> | number
    entidad?: StringFilter<"Logs"> | string
    entidad_id?: IntNullableFilter<"Logs"> | number | null
    campo?: StringNullableFilter<"Logs"> | string | null
    valor_anterior?: StringNullableFilter<"Logs"> | string | null
    valor_nuevo?: StringNullableFilter<"Logs"> | string | null
    usuario_id?: IntFilter<"Logs"> | number
    fecha_cambio?: DateTimeNullableFilter<"Logs"> | Date | string | null
    motivo?: StringNullableFilter<"Logs"> | string | null
    usuario?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
  }

  export type LogsOrderByWithRelationInput = {
    id?: SortOrder
    entidad?: SortOrder
    entidad_id?: SortOrderInput | SortOrder
    campo?: SortOrderInput | SortOrder
    valor_anterior?: SortOrderInput | SortOrder
    valor_nuevo?: SortOrderInput | SortOrder
    usuario_id?: SortOrder
    fecha_cambio?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    usuario?: UsuariosOrderByWithRelationInput
  }

  export type LogsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: LogsWhereInput | LogsWhereInput[]
    OR?: LogsWhereInput[]
    NOT?: LogsWhereInput | LogsWhereInput[]
    entidad?: StringFilter<"Logs"> | string
    entidad_id?: IntNullableFilter<"Logs"> | number | null
    campo?: StringNullableFilter<"Logs"> | string | null
    valor_anterior?: StringNullableFilter<"Logs"> | string | null
    valor_nuevo?: StringNullableFilter<"Logs"> | string | null
    usuario_id?: IntFilter<"Logs"> | number
    fecha_cambio?: DateTimeNullableFilter<"Logs"> | Date | string | null
    motivo?: StringNullableFilter<"Logs"> | string | null
    usuario?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
  }, "id">

  export type LogsOrderByWithAggregationInput = {
    id?: SortOrder
    entidad?: SortOrder
    entidad_id?: SortOrderInput | SortOrder
    campo?: SortOrderInput | SortOrder
    valor_anterior?: SortOrderInput | SortOrder
    valor_nuevo?: SortOrderInput | SortOrder
    usuario_id?: SortOrder
    fecha_cambio?: SortOrderInput | SortOrder
    motivo?: SortOrderInput | SortOrder
    _count?: LogsCountOrderByAggregateInput
    _avg?: LogsAvgOrderByAggregateInput
    _max?: LogsMaxOrderByAggregateInput
    _min?: LogsMinOrderByAggregateInput
    _sum?: LogsSumOrderByAggregateInput
  }

  export type LogsScalarWhereWithAggregatesInput = {
    AND?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    OR?: LogsScalarWhereWithAggregatesInput[]
    NOT?: LogsScalarWhereWithAggregatesInput | LogsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Logs"> | number
    entidad?: StringWithAggregatesFilter<"Logs"> | string
    entidad_id?: IntNullableWithAggregatesFilter<"Logs"> | number | null
    campo?: StringNullableWithAggregatesFilter<"Logs"> | string | null
    valor_anterior?: StringNullableWithAggregatesFilter<"Logs"> | string | null
    valor_nuevo?: StringNullableWithAggregatesFilter<"Logs"> | string | null
    usuario_id?: IntWithAggregatesFilter<"Logs"> | number
    fecha_cambio?: DateTimeNullableWithAggregatesFilter<"Logs"> | Date | string | null
    motivo?: StringNullableWithAggregatesFilter<"Logs"> | string | null
  }

  export type MiembrosEquipoWhereInput = {
    AND?: MiembrosEquipoWhereInput | MiembrosEquipoWhereInput[]
    OR?: MiembrosEquipoWhereInput[]
    NOT?: MiembrosEquipoWhereInput | MiembrosEquipoWhereInput[]
    id?: IntFilter<"MiembrosEquipo"> | number
    olimpista_id?: IntFilter<"MiembrosEquipo"> | number
    nombre_equipo?: StringFilter<"MiembrosEquipo"> | string
    rol_en_equipo?: EnumRolEquipoFilter<"MiembrosEquipo"> | $Enums.RolEquipo
    olimpista?: XOR<OlimpistasScalarRelationFilter, OlimpistasWhereInput>
  }

  export type MiembrosEquipoOrderByWithRelationInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    nombre_equipo?: SortOrder
    rol_en_equipo?: SortOrder
    olimpista?: OlimpistasOrderByWithRelationInput
  }

  export type MiembrosEquipoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MiembrosEquipoWhereInput | MiembrosEquipoWhereInput[]
    OR?: MiembrosEquipoWhereInput[]
    NOT?: MiembrosEquipoWhereInput | MiembrosEquipoWhereInput[]
    olimpista_id?: IntFilter<"MiembrosEquipo"> | number
    nombre_equipo?: StringFilter<"MiembrosEquipo"> | string
    rol_en_equipo?: EnumRolEquipoFilter<"MiembrosEquipo"> | $Enums.RolEquipo
    olimpista?: XOR<OlimpistasScalarRelationFilter, OlimpistasWhereInput>
  }, "id">

  export type MiembrosEquipoOrderByWithAggregationInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    nombre_equipo?: SortOrder
    rol_en_equipo?: SortOrder
    _count?: MiembrosEquipoCountOrderByAggregateInput
    _avg?: MiembrosEquipoAvgOrderByAggregateInput
    _max?: MiembrosEquipoMaxOrderByAggregateInput
    _min?: MiembrosEquipoMinOrderByAggregateInput
    _sum?: MiembrosEquipoSumOrderByAggregateInput
  }

  export type MiembrosEquipoScalarWhereWithAggregatesInput = {
    AND?: MiembrosEquipoScalarWhereWithAggregatesInput | MiembrosEquipoScalarWhereWithAggregatesInput[]
    OR?: MiembrosEquipoScalarWhereWithAggregatesInput[]
    NOT?: MiembrosEquipoScalarWhereWithAggregatesInput | MiembrosEquipoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MiembrosEquipo"> | number
    olimpista_id?: IntWithAggregatesFilter<"MiembrosEquipo"> | number
    nombre_equipo?: StringWithAggregatesFilter<"MiembrosEquipo"> | string
    rol_en_equipo?: EnumRolEquipoWithAggregatesFilter<"MiembrosEquipo"> | $Enums.RolEquipo
  }

  export type NivelesWhereInput = {
    AND?: NivelesWhereInput | NivelesWhereInput[]
    OR?: NivelesWhereInput[]
    NOT?: NivelesWhereInput | NivelesWhereInput[]
    id?: IntFilter<"Niveles"> | number
    codigo?: StringNullableFilter<"Niveles"> | string | null
    nombre?: StringFilter<"Niveles"> | string
    descripcion?: StringNullableFilter<"Niveles"> | string | null
    estado?: BoolFilter<"Niveles"> | boolean
    participacion?: ParticipacionListRelationFilter
    ConfigMedallas?: ConfigMedallasListRelationFilter
  }

  export type NivelesOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    participacion?: ParticipacionOrderByRelationAggregateInput
    ConfigMedallas?: ConfigMedallasOrderByRelationAggregateInput
  }

  export type NivelesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NivelesWhereInput | NivelesWhereInput[]
    OR?: NivelesWhereInput[]
    NOT?: NivelesWhereInput | NivelesWhereInput[]
    codigo?: StringNullableFilter<"Niveles"> | string | null
    nombre?: StringFilter<"Niveles"> | string
    descripcion?: StringNullableFilter<"Niveles"> | string | null
    estado?: BoolFilter<"Niveles"> | boolean
    participacion?: ParticipacionListRelationFilter
    ConfigMedallas?: ConfigMedallasListRelationFilter
  }, "id">

  export type NivelesOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrderInput | SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    estado?: SortOrder
    _count?: NivelesCountOrderByAggregateInput
    _avg?: NivelesAvgOrderByAggregateInput
    _max?: NivelesMaxOrderByAggregateInput
    _min?: NivelesMinOrderByAggregateInput
    _sum?: NivelesSumOrderByAggregateInput
  }

  export type NivelesScalarWhereWithAggregatesInput = {
    AND?: NivelesScalarWhereWithAggregatesInput | NivelesScalarWhereWithAggregatesInput[]
    OR?: NivelesScalarWhereWithAggregatesInput[]
    NOT?: NivelesScalarWhereWithAggregatesInput | NivelesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Niveles"> | number
    codigo?: StringNullableWithAggregatesFilter<"Niveles"> | string | null
    nombre?: StringWithAggregatesFilter<"Niveles"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Niveles"> | string | null
    estado?: BoolWithAggregatesFilter<"Niveles"> | boolean
  }

  export type OlimpistasWhereInput = {
    AND?: OlimpistasWhereInput | OlimpistasWhereInput[]
    OR?: OlimpistasWhereInput[]
    NOT?: OlimpistasWhereInput | OlimpistasWhereInput[]
    id?: IntFilter<"Olimpistas"> | number
    nombre?: StringFilter<"Olimpistas"> | string
    ap_paterno?: StringFilter<"Olimpistas"> | string
    ap_materno?: StringNullableFilter<"Olimpistas"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Olimpistas"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Olimpistas"> | string
    unidad_educativa?: StringFilter<"Olimpistas"> | string
    departamento?: StringFilter<"Olimpistas"> | string
    grado?: StringNullableFilter<"Olimpistas"> | string | null
    fecha_nacimiento?: DateTimeNullableFilter<"Olimpistas"> | Date | string | null
    sexo?: EnumSexoNullableFilter<"Olimpistas"> | $Enums.Sexo | null
    activo?: BoolFilter<"Olimpistas"> | boolean
    creado_en?: DateTimeFilter<"Olimpistas"> | Date | string
    tutor_id?: IntNullableFilter<"Olimpistas"> | number | null
    tutor?: XOR<TutoresNullableScalarRelationFilter, TutoresWhereInput> | null
    participacion?: ParticipacionListRelationFilter
    miembros_equipo?: MiembrosEquipoListRelationFilter
  }

  export type OlimpistasOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrderInput | SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    unidad_educativa?: SortOrder
    departamento?: SortOrder
    grado?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    sexo?: SortOrderInput | SortOrder
    activo?: SortOrder
    creado_en?: SortOrder
    tutor_id?: SortOrderInput | SortOrder
    tutor?: TutoresOrderByWithRelationInput
    participacion?: ParticipacionOrderByRelationAggregateInput
    miembros_equipo?: MiembrosEquipoOrderByRelationAggregateInput
  }

  export type OlimpistasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tipo_documento_numero_documento?: OlimpistasTipo_documentoNumero_documentoCompoundUniqueInput
    AND?: OlimpistasWhereInput | OlimpistasWhereInput[]
    OR?: OlimpistasWhereInput[]
    NOT?: OlimpistasWhereInput | OlimpistasWhereInput[]
    nombre?: StringFilter<"Olimpistas"> | string
    ap_paterno?: StringFilter<"Olimpistas"> | string
    ap_materno?: StringNullableFilter<"Olimpistas"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Olimpistas"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Olimpistas"> | string
    unidad_educativa?: StringFilter<"Olimpistas"> | string
    departamento?: StringFilter<"Olimpistas"> | string
    grado?: StringNullableFilter<"Olimpistas"> | string | null
    fecha_nacimiento?: DateTimeNullableFilter<"Olimpistas"> | Date | string | null
    sexo?: EnumSexoNullableFilter<"Olimpistas"> | $Enums.Sexo | null
    activo?: BoolFilter<"Olimpistas"> | boolean
    creado_en?: DateTimeFilter<"Olimpistas"> | Date | string
    tutor_id?: IntNullableFilter<"Olimpistas"> | number | null
    tutor?: XOR<TutoresNullableScalarRelationFilter, TutoresWhereInput> | null
    participacion?: ParticipacionListRelationFilter
    miembros_equipo?: MiembrosEquipoListRelationFilter
  }, "id" | "tipo_documento_numero_documento">

  export type OlimpistasOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrderInput | SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    unidad_educativa?: SortOrder
    departamento?: SortOrder
    grado?: SortOrderInput | SortOrder
    fecha_nacimiento?: SortOrderInput | SortOrder
    sexo?: SortOrderInput | SortOrder
    activo?: SortOrder
    creado_en?: SortOrder
    tutor_id?: SortOrderInput | SortOrder
    _count?: OlimpistasCountOrderByAggregateInput
    _avg?: OlimpistasAvgOrderByAggregateInput
    _max?: OlimpistasMaxOrderByAggregateInput
    _min?: OlimpistasMinOrderByAggregateInput
    _sum?: OlimpistasSumOrderByAggregateInput
  }

  export type OlimpistasScalarWhereWithAggregatesInput = {
    AND?: OlimpistasScalarWhereWithAggregatesInput | OlimpistasScalarWhereWithAggregatesInput[]
    OR?: OlimpistasScalarWhereWithAggregatesInput[]
    NOT?: OlimpistasScalarWhereWithAggregatesInput | OlimpistasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Olimpistas"> | number
    nombre?: StringWithAggregatesFilter<"Olimpistas"> | string
    ap_paterno?: StringWithAggregatesFilter<"Olimpistas"> | string
    ap_materno?: StringNullableWithAggregatesFilter<"Olimpistas"> | string | null
    tipo_documento?: EnumTipoDocumentoWithAggregatesFilter<"Olimpistas"> | $Enums.TipoDocumento
    numero_documento?: StringWithAggregatesFilter<"Olimpistas"> | string
    unidad_educativa?: StringWithAggregatesFilter<"Olimpistas"> | string
    departamento?: StringWithAggregatesFilter<"Olimpistas"> | string
    grado?: StringNullableWithAggregatesFilter<"Olimpistas"> | string | null
    fecha_nacimiento?: DateTimeNullableWithAggregatesFilter<"Olimpistas"> | Date | string | null
    sexo?: EnumSexoNullableWithAggregatesFilter<"Olimpistas"> | $Enums.Sexo | null
    activo?: BoolWithAggregatesFilter<"Olimpistas"> | boolean
    creado_en?: DateTimeWithAggregatesFilter<"Olimpistas"> | Date | string
    tutor_id?: IntNullableWithAggregatesFilter<"Olimpistas"> | number | null
  }

  export type ParticipacionWhereInput = {
    AND?: ParticipacionWhereInput | ParticipacionWhereInput[]
    OR?: ParticipacionWhereInput[]
    NOT?: ParticipacionWhereInput | ParticipacionWhereInput[]
    id?: IntFilter<"Participacion"> | number
    olimpista_id?: IntFilter<"Participacion"> | number
    area_id?: IntFilter<"Participacion"> | number
    nivel_id?: IntFilter<"Participacion"> | number
    estado?: EnumEstadoParticipacionFilter<"Participacion"> | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFilter<"Participacion"> | $Enums.TipoParticipacion
    olimpista?: XOR<OlimpistasScalarRelationFilter, OlimpistasWhereInput>
    area?: XOR<AreasScalarRelationFilter, AreasWhereInput>
    nivel?: XOR<NivelesScalarRelationFilter, NivelesWhereInput>
    evaluaciones?: EvaluacionesListRelationFilter
  }

  export type ParticipacionOrderByWithRelationInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    estado?: SortOrder
    tipo?: SortOrder
    olimpista?: OlimpistasOrderByWithRelationInput
    area?: AreasOrderByWithRelationInput
    nivel?: NivelesOrderByWithRelationInput
    evaluaciones?: EvaluacionesOrderByRelationAggregateInput
  }

  export type ParticipacionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ParticipacionWhereInput | ParticipacionWhereInput[]
    OR?: ParticipacionWhereInput[]
    NOT?: ParticipacionWhereInput | ParticipacionWhereInput[]
    olimpista_id?: IntFilter<"Participacion"> | number
    area_id?: IntFilter<"Participacion"> | number
    nivel_id?: IntFilter<"Participacion"> | number
    estado?: EnumEstadoParticipacionFilter<"Participacion"> | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFilter<"Participacion"> | $Enums.TipoParticipacion
    olimpista?: XOR<OlimpistasScalarRelationFilter, OlimpistasWhereInput>
    area?: XOR<AreasScalarRelationFilter, AreasWhereInput>
    nivel?: XOR<NivelesScalarRelationFilter, NivelesWhereInput>
    evaluaciones?: EvaluacionesListRelationFilter
  }, "id">

  export type ParticipacionOrderByWithAggregationInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    estado?: SortOrder
    tipo?: SortOrder
    _count?: ParticipacionCountOrderByAggregateInput
    _avg?: ParticipacionAvgOrderByAggregateInput
    _max?: ParticipacionMaxOrderByAggregateInput
    _min?: ParticipacionMinOrderByAggregateInput
    _sum?: ParticipacionSumOrderByAggregateInput
  }

  export type ParticipacionScalarWhereWithAggregatesInput = {
    AND?: ParticipacionScalarWhereWithAggregatesInput | ParticipacionScalarWhereWithAggregatesInput[]
    OR?: ParticipacionScalarWhereWithAggregatesInput[]
    NOT?: ParticipacionScalarWhereWithAggregatesInput | ParticipacionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Participacion"> | number
    olimpista_id?: IntWithAggregatesFilter<"Participacion"> | number
    area_id?: IntWithAggregatesFilter<"Participacion"> | number
    nivel_id?: IntWithAggregatesFilter<"Participacion"> | number
    estado?: EnumEstadoParticipacionWithAggregatesFilter<"Participacion"> | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionWithAggregatesFilter<"Participacion"> | $Enums.TipoParticipacion
  }

  export type ReportesWhereInput = {
    AND?: ReportesWhereInput | ReportesWhereInput[]
    OR?: ReportesWhereInput[]
    NOT?: ReportesWhereInput | ReportesWhereInput[]
    id?: IntFilter<"Reportes"> | number
    tipo?: StringFilter<"Reportes"> | string
    parametros?: JsonNullableFilter<"Reportes">
    archivo?: StringNullableFilter<"Reportes"> | string | null
    generado_por?: IntFilter<"Reportes"> | number
    generado_en?: DateTimeNullableFilter<"Reportes"> | Date | string | null
    generadoPor?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
  }

  export type ReportesOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    parametros?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    generado_por?: SortOrder
    generado_en?: SortOrderInput | SortOrder
    generadoPor?: UsuariosOrderByWithRelationInput
  }

  export type ReportesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReportesWhereInput | ReportesWhereInput[]
    OR?: ReportesWhereInput[]
    NOT?: ReportesWhereInput | ReportesWhereInput[]
    tipo?: StringFilter<"Reportes"> | string
    parametros?: JsonNullableFilter<"Reportes">
    archivo?: StringNullableFilter<"Reportes"> | string | null
    generado_por?: IntFilter<"Reportes"> | number
    generado_en?: DateTimeNullableFilter<"Reportes"> | Date | string | null
    generadoPor?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
  }, "id">

  export type ReportesOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    parametros?: SortOrderInput | SortOrder
    archivo?: SortOrderInput | SortOrder
    generado_por?: SortOrder
    generado_en?: SortOrderInput | SortOrder
    _count?: ReportesCountOrderByAggregateInput
    _avg?: ReportesAvgOrderByAggregateInput
    _max?: ReportesMaxOrderByAggregateInput
    _min?: ReportesMinOrderByAggregateInput
    _sum?: ReportesSumOrderByAggregateInput
  }

  export type ReportesScalarWhereWithAggregatesInput = {
    AND?: ReportesScalarWhereWithAggregatesInput | ReportesScalarWhereWithAggregatesInput[]
    OR?: ReportesScalarWhereWithAggregatesInput[]
    NOT?: ReportesScalarWhereWithAggregatesInput | ReportesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reportes"> | number
    tipo?: StringWithAggregatesFilter<"Reportes"> | string
    parametros?: JsonNullableWithAggregatesFilter<"Reportes">
    archivo?: StringNullableWithAggregatesFilter<"Reportes"> | string | null
    generado_por?: IntWithAggregatesFilter<"Reportes"> | number
    generado_en?: DateTimeNullableWithAggregatesFilter<"Reportes"> | Date | string | null
  }

  export type RolesWhereInput = {
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    id?: IntFilter<"Roles"> | number
    nombre?: StringFilter<"Roles"> | string
    descripcion?: StringNullableFilter<"Roles"> | string | null
    usuario_rol?: UsuarioRolListRelationFilter
  }

  export type RolesOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    usuario_rol?: UsuarioRolOrderByRelationAggregateInput
  }

  export type RolesWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    nombre?: string
    AND?: RolesWhereInput | RolesWhereInput[]
    OR?: RolesWhereInput[]
    NOT?: RolesWhereInput | RolesWhereInput[]
    descripcion?: StringNullableFilter<"Roles"> | string | null
    usuario_rol?: UsuarioRolListRelationFilter
  }, "id" | "nombre">

  export type RolesOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    _count?: RolesCountOrderByAggregateInput
    _avg?: RolesAvgOrderByAggregateInput
    _max?: RolesMaxOrderByAggregateInput
    _min?: RolesMinOrderByAggregateInput
    _sum?: RolesSumOrderByAggregateInput
  }

  export type RolesScalarWhereWithAggregatesInput = {
    AND?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    OR?: RolesScalarWhereWithAggregatesInput[]
    NOT?: RolesScalarWhereWithAggregatesInput | RolesScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Roles"> | number
    nombre?: StringWithAggregatesFilter<"Roles"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Roles"> | string | null
  }

  export type TutoresWhereInput = {
    AND?: TutoresWhereInput | TutoresWhereInput[]
    OR?: TutoresWhereInput[]
    NOT?: TutoresWhereInput | TutoresWhereInput[]
    id?: IntFilter<"Tutores"> | number
    nombre?: StringFilter<"Tutores"> | string
    ap_paterno?: StringFilter<"Tutores"> | string
    ap_materno?: StringNullableFilter<"Tutores"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Tutores"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Tutores"> | string
    telefono?: StringNullableFilter<"Tutores"> | string | null
    correo?: StringNullableFilter<"Tutores"> | string | null
    unidad_educativa?: StringFilter<"Tutores"> | string
    profesion?: StringNullableFilter<"Tutores"> | string | null
    creado_en?: DateTimeFilter<"Tutores"> | Date | string
    olimpistas?: OlimpistasListRelationFilter
  }

  export type TutoresOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrderInput | SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    unidad_educativa?: SortOrder
    profesion?: SortOrderInput | SortOrder
    creado_en?: SortOrder
    olimpistas?: OlimpistasOrderByRelationAggregateInput
  }

  export type TutoresWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    tipo_documento_numero_documento?: TutoresTipo_documentoNumero_documentoCompoundUniqueInput
    AND?: TutoresWhereInput | TutoresWhereInput[]
    OR?: TutoresWhereInput[]
    NOT?: TutoresWhereInput | TutoresWhereInput[]
    nombre?: StringFilter<"Tutores"> | string
    ap_paterno?: StringFilter<"Tutores"> | string
    ap_materno?: StringNullableFilter<"Tutores"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Tutores"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Tutores"> | string
    telefono?: StringNullableFilter<"Tutores"> | string | null
    correo?: StringNullableFilter<"Tutores"> | string | null
    unidad_educativa?: StringFilter<"Tutores"> | string
    profesion?: StringNullableFilter<"Tutores"> | string | null
    creado_en?: DateTimeFilter<"Tutores"> | Date | string
    olimpistas?: OlimpistasListRelationFilter
  }, "id" | "tipo_documento_numero_documento">

  export type TutoresOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrderInput | SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    telefono?: SortOrderInput | SortOrder
    correo?: SortOrderInput | SortOrder
    unidad_educativa?: SortOrder
    profesion?: SortOrderInput | SortOrder
    creado_en?: SortOrder
    _count?: TutoresCountOrderByAggregateInput
    _avg?: TutoresAvgOrderByAggregateInput
    _max?: TutoresMaxOrderByAggregateInput
    _min?: TutoresMinOrderByAggregateInput
    _sum?: TutoresSumOrderByAggregateInput
  }

  export type TutoresScalarWhereWithAggregatesInput = {
    AND?: TutoresScalarWhereWithAggregatesInput | TutoresScalarWhereWithAggregatesInput[]
    OR?: TutoresScalarWhereWithAggregatesInput[]
    NOT?: TutoresScalarWhereWithAggregatesInput | TutoresScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Tutores"> | number
    nombre?: StringWithAggregatesFilter<"Tutores"> | string
    ap_paterno?: StringWithAggregatesFilter<"Tutores"> | string
    ap_materno?: StringNullableWithAggregatesFilter<"Tutores"> | string | null
    tipo_documento?: EnumTipoDocumentoWithAggregatesFilter<"Tutores"> | $Enums.TipoDocumento
    numero_documento?: StringWithAggregatesFilter<"Tutores"> | string
    telefono?: StringNullableWithAggregatesFilter<"Tutores"> | string | null
    correo?: StringNullableWithAggregatesFilter<"Tutores"> | string | null
    unidad_educativa?: StringWithAggregatesFilter<"Tutores"> | string
    profesion?: StringNullableWithAggregatesFilter<"Tutores"> | string | null
    creado_en?: DateTimeWithAggregatesFilter<"Tutores"> | Date | string
  }

  export type UsuarioRolWhereInput = {
    AND?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    OR?: UsuarioRolWhereInput[]
    NOT?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    id?: IntFilter<"UsuarioRol"> | number
    usuario_id?: IntNullableFilter<"UsuarioRol"> | number | null
    rol_id?: IntNullableFilter<"UsuarioRol"> | number | null
    usuario?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
    rol?: XOR<RolesNullableScalarRelationFilter, RolesWhereInput> | null
  }

  export type UsuarioRolOrderByWithRelationInput = {
    id?: SortOrder
    usuario_id?: SortOrderInput | SortOrder
    rol_id?: SortOrderInput | SortOrder
    usuario?: UsuariosOrderByWithRelationInput
    rol?: RolesOrderByWithRelationInput
  }

  export type UsuarioRolWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    OR?: UsuarioRolWhereInput[]
    NOT?: UsuarioRolWhereInput | UsuarioRolWhereInput[]
    usuario_id?: IntNullableFilter<"UsuarioRol"> | number | null
    rol_id?: IntNullableFilter<"UsuarioRol"> | number | null
    usuario?: XOR<UsuariosNullableScalarRelationFilter, UsuariosWhereInput> | null
    rol?: XOR<RolesNullableScalarRelationFilter, RolesWhereInput> | null
  }, "id">

  export type UsuarioRolOrderByWithAggregationInput = {
    id?: SortOrder
    usuario_id?: SortOrderInput | SortOrder
    rol_id?: SortOrderInput | SortOrder
    _count?: UsuarioRolCountOrderByAggregateInput
    _avg?: UsuarioRolAvgOrderByAggregateInput
    _max?: UsuarioRolMaxOrderByAggregateInput
    _min?: UsuarioRolMinOrderByAggregateInput
    _sum?: UsuarioRolSumOrderByAggregateInput
  }

  export type UsuarioRolScalarWhereWithAggregatesInput = {
    AND?: UsuarioRolScalarWhereWithAggregatesInput | UsuarioRolScalarWhereWithAggregatesInput[]
    OR?: UsuarioRolScalarWhereWithAggregatesInput[]
    NOT?: UsuarioRolScalarWhereWithAggregatesInput | UsuarioRolScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"UsuarioRol"> | number
    usuario_id?: IntNullableWithAggregatesFilter<"UsuarioRol"> | number | null
    rol_id?: IntNullableWithAggregatesFilter<"UsuarioRol"> | number | null
  }

  export type UsuariosWhereInput = {
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    id?: IntFilter<"Usuarios"> | number
    contrasena_hash?: StringFilter<"Usuarios"> | string
    nombre?: StringFilter<"Usuarios"> | string
    ap_paterno?: StringFilter<"Usuarios"> | string
    ap_materno?: StringNullableFilter<"Usuarios"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Usuarios"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Usuarios"> | string
    correo?: StringFilter<"Usuarios"> | string
    telefono?: StringNullableFilter<"Usuarios"> | string | null
    cargo?: StringNullableFilter<"Usuarios"> | string | null
    profesion?: StringNullableFilter<"Usuarios"> | string | null
    institucion?: StringNullableFilter<"Usuarios"> | string | null
    estado?: BoolFilter<"Usuarios"> | boolean
    creado_en?: DateTimeFilter<"Usuarios"> | Date | string
    actualizado_en?: DateTimeNullableFilter<"Usuarios"> | Date | string | null
    evaluaciones?: EvaluacionesListRelationFilter
    logs?: LogsListRelationFilter
    reportes?: ReportesListRelationFilter
    usuario_rol?: UsuarioRolListRelationFilter
  }

  export type UsuariosOrderByWithRelationInput = {
    id?: SortOrder
    contrasena_hash?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrderInput | SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    correo?: SortOrder
    telefono?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    profesion?: SortOrderInput | SortOrder
    institucion?: SortOrderInput | SortOrder
    estado?: SortOrder
    creado_en?: SortOrder
    actualizado_en?: SortOrderInput | SortOrder
    evaluaciones?: EvaluacionesOrderByRelationAggregateInput
    logs?: LogsOrderByRelationAggregateInput
    reportes?: ReportesOrderByRelationAggregateInput
    usuario_rol?: UsuarioRolOrderByRelationAggregateInput
  }

  export type UsuariosWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    correo?: string
    AND?: UsuariosWhereInput | UsuariosWhereInput[]
    OR?: UsuariosWhereInput[]
    NOT?: UsuariosWhereInput | UsuariosWhereInput[]
    contrasena_hash?: StringFilter<"Usuarios"> | string
    nombre?: StringFilter<"Usuarios"> | string
    ap_paterno?: StringFilter<"Usuarios"> | string
    ap_materno?: StringNullableFilter<"Usuarios"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Usuarios"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Usuarios"> | string
    telefono?: StringNullableFilter<"Usuarios"> | string | null
    cargo?: StringNullableFilter<"Usuarios"> | string | null
    profesion?: StringNullableFilter<"Usuarios"> | string | null
    institucion?: StringNullableFilter<"Usuarios"> | string | null
    estado?: BoolFilter<"Usuarios"> | boolean
    creado_en?: DateTimeFilter<"Usuarios"> | Date | string
    actualizado_en?: DateTimeNullableFilter<"Usuarios"> | Date | string | null
    evaluaciones?: EvaluacionesListRelationFilter
    logs?: LogsListRelationFilter
    reportes?: ReportesListRelationFilter
    usuario_rol?: UsuarioRolListRelationFilter
  }, "id" | "correo">

  export type UsuariosOrderByWithAggregationInput = {
    id?: SortOrder
    contrasena_hash?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrderInput | SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    correo?: SortOrder
    telefono?: SortOrderInput | SortOrder
    cargo?: SortOrderInput | SortOrder
    profesion?: SortOrderInput | SortOrder
    institucion?: SortOrderInput | SortOrder
    estado?: SortOrder
    creado_en?: SortOrder
    actualizado_en?: SortOrderInput | SortOrder
    _count?: UsuariosCountOrderByAggregateInput
    _avg?: UsuariosAvgOrderByAggregateInput
    _max?: UsuariosMaxOrderByAggregateInput
    _min?: UsuariosMinOrderByAggregateInput
    _sum?: UsuariosSumOrderByAggregateInput
  }

  export type UsuariosScalarWhereWithAggregatesInput = {
    AND?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    OR?: UsuariosScalarWhereWithAggregatesInput[]
    NOT?: UsuariosScalarWhereWithAggregatesInput | UsuariosScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Usuarios"> | number
    contrasena_hash?: StringWithAggregatesFilter<"Usuarios"> | string
    nombre?: StringWithAggregatesFilter<"Usuarios"> | string
    ap_paterno?: StringWithAggregatesFilter<"Usuarios"> | string
    ap_materno?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    tipo_documento?: EnumTipoDocumentoWithAggregatesFilter<"Usuarios"> | $Enums.TipoDocumento
    numero_documento?: StringWithAggregatesFilter<"Usuarios"> | string
    correo?: StringWithAggregatesFilter<"Usuarios"> | string
    telefono?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    cargo?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    profesion?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    institucion?: StringNullableWithAggregatesFilter<"Usuarios"> | string | null
    estado?: BoolWithAggregatesFilter<"Usuarios"> | boolean
    creado_en?: DateTimeWithAggregatesFilter<"Usuarios"> | Date | string
    actualizado_en?: DateTimeNullableWithAggregatesFilter<"Usuarios"> | Date | string | null
  }

  export type AreasCreateInput = {
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    config_medallas?: ConfigMedallasCreateNestedManyWithoutAreaInput
    participacion?: ParticipacionCreateNestedManyWithoutAreaInput
  }

  export type AreasUncheckedCreateInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    config_medallas?: ConfigMedallasUncheckedCreateNestedManyWithoutAreaInput
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreasUpdateInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    config_medallas?: ConfigMedallasUpdateManyWithoutAreaNestedInput
    participacion?: ParticipacionUpdateManyWithoutAreaNestedInput
  }

  export type AreasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    config_medallas?: ConfigMedallasUncheckedUpdateManyWithoutAreaNestedInput
    participacion?: ParticipacionUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type AreasCreateManyInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
  }

  export type AreasUpdateManyMutationInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AreasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ConfigMedallasCreateInput = {
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
    area: AreasCreateNestedOneWithoutConfig_medallasInput
    nivel: NivelesCreateNestedOneWithoutConfigMedallasInput
  }

  export type ConfigMedallasUncheckedCreateInput = {
    id?: number
    area_id: number
    nivel_id: number
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
  }

  export type ConfigMedallasUpdateInput = {
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
    area?: AreasUpdateOneRequiredWithoutConfig_medallasNestedInput
    nivel?: NivelesUpdateOneRequiredWithoutConfigMedallasNestedInput
  }

  export type ConfigMedallasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type ConfigMedallasCreateManyInput = {
    id?: number
    area_id: number
    nivel_id: number
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
  }

  export type ConfigMedallasUpdateManyMutationInput = {
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type ConfigMedallasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type EvaluacionesCreateInput = {
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
    participacion: ParticipacionCreateNestedOneWithoutEvaluacionesInput
    evaluador?: UsuariosCreateNestedOneWithoutEvaluacionesInput
    fase?: FasesCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionesUncheckedCreateInput = {
    id?: number
    participacion_id: number
    evaluador_id?: number | null
    fase_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesUpdateInput = {
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participacion?: ParticipacionUpdateOneRequiredWithoutEvaluacionesNestedInput
    evaluador?: UsuariosUpdateOneWithoutEvaluacionesNestedInput
    fase?: FasesUpdateOneWithoutEvaluacionesNestedInput
  }

  export type EvaluacionesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    participacion_id?: IntFieldUpdateOperationsInput | number
    evaluador_id?: NullableIntFieldUpdateOperationsInput | number | null
    fase_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluacionesCreateManyInput = {
    id?: number
    participacion_id: number
    evaluador_id?: number | null
    fase_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesUpdateManyMutationInput = {
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluacionesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    participacion_id?: IntFieldUpdateOperationsInput | number
    evaluador_id?: NullableIntFieldUpdateOperationsInput | number | null
    fase_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FasesCreateInput = {
    nombre: string
    descripcion?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    estado?: $Enums.EstadoFase
    evaluaciones?: EvaluacionesCreateNestedManyWithoutFaseInput
  }

  export type FasesUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    estado?: $Enums.EstadoFase
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutFaseInput
  }

  export type FasesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoFaseFieldUpdateOperationsInput | $Enums.EstadoFase
    evaluaciones?: EvaluacionesUpdateManyWithoutFaseNestedInput
  }

  export type FasesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoFaseFieldUpdateOperationsInput | $Enums.EstadoFase
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutFaseNestedInput
  }

  export type FasesCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    estado?: $Enums.EstadoFase
  }

  export type FasesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoFaseFieldUpdateOperationsInput | $Enums.EstadoFase
  }

  export type FasesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoFaseFieldUpdateOperationsInput | $Enums.EstadoFase
  }

  export type LogsCreateInput = {
    entidad: string
    entidad_id?: number | null
    campo?: string | null
    valor_anterior?: string | null
    valor_nuevo?: string | null
    fecha_cambio?: Date | string | null
    motivo?: string | null
    usuario?: UsuariosCreateNestedOneWithoutLogsInput
  }

  export type LogsUncheckedCreateInput = {
    id?: number
    entidad: string
    entidad_id?: number | null
    campo?: string | null
    valor_anterior?: string | null
    valor_nuevo?: string | null
    usuario_id: number
    fecha_cambio?: Date | string | null
    motivo?: string | null
  }

  export type LogsUpdateInput = {
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    usuario?: UsuariosUpdateOneWithoutLogsNestedInput
  }

  export type LogsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogsCreateManyInput = {
    id?: number
    entidad: string
    entidad_id?: number | null
    campo?: string | null
    valor_anterior?: string | null
    valor_nuevo?: string | null
    usuario_id: number
    fecha_cambio?: Date | string | null
    motivo?: string | null
  }

  export type LogsUpdateManyMutationInput = {
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_id?: IntFieldUpdateOperationsInput | number
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type MiembrosEquipoCreateInput = {
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
    olimpista: OlimpistasCreateNestedOneWithoutMiembros_equipoInput
  }

  export type MiembrosEquipoUncheckedCreateInput = {
    id?: number
    olimpista_id: number
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
  }

  export type MiembrosEquipoUpdateInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
    olimpista?: OlimpistasUpdateOneRequiredWithoutMiembros_equipoNestedInput
  }

  export type MiembrosEquipoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
  }

  export type MiembrosEquipoCreateManyInput = {
    id?: number
    olimpista_id: number
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
  }

  export type MiembrosEquipoUpdateManyMutationInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
  }

  export type MiembrosEquipoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
  }

  export type NivelesCreateInput = {
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    participacion?: ParticipacionCreateNestedManyWithoutNivelInput
    ConfigMedallas?: ConfigMedallasCreateNestedManyWithoutNivelInput
  }

  export type NivelesUncheckedCreateInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutNivelInput
    ConfigMedallas?: ConfigMedallasUncheckedCreateNestedManyWithoutNivelInput
  }

  export type NivelesUpdateInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    participacion?: ParticipacionUpdateManyWithoutNivelNestedInput
    ConfigMedallas?: ConfigMedallasUpdateManyWithoutNivelNestedInput
  }

  export type NivelesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    participacion?: ParticipacionUncheckedUpdateManyWithoutNivelNestedInput
    ConfigMedallas?: ConfigMedallasUncheckedUpdateManyWithoutNivelNestedInput
  }

  export type NivelesCreateManyInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
  }

  export type NivelesUpdateManyMutationInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type NivelesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
  }

  export type OlimpistasCreateInput = {
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor?: TutoresCreateNestedOneWithoutOlimpistasInput
    participacion?: ParticipacionCreateNestedManyWithoutOlimpistaInput
    miembros_equipo?: MiembrosEquipoCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasUncheckedCreateInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor_id?: number | null
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutOlimpistaInput
    miembros_equipo?: MiembrosEquipoUncheckedCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutoresUpdateOneWithoutOlimpistasNestedInput
    participacion?: ParticipacionUpdateManyWithoutOlimpistaNestedInput
    miembros_equipo?: MiembrosEquipoUpdateManyWithoutOlimpistaNestedInput
  }

  export type OlimpistasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor_id?: NullableIntFieldUpdateOperationsInput | number | null
    participacion?: ParticipacionUncheckedUpdateManyWithoutOlimpistaNestedInput
    miembros_equipo?: MiembrosEquipoUncheckedUpdateManyWithoutOlimpistaNestedInput
  }

  export type OlimpistasCreateManyInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor_id?: number | null
  }

  export type OlimpistasUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OlimpistasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ParticipacionCreateInput = {
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    olimpista: OlimpistasCreateNestedOneWithoutParticipacionInput
    area: AreasCreateNestedOneWithoutParticipacionInput
    nivel: NivelesCreateNestedOneWithoutParticipacionInput
    evaluaciones?: EvaluacionesCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionUncheckedCreateInput = {
    id?: number
    olimpista_id: number
    area_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionUpdateInput = {
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    olimpista?: OlimpistasUpdateOneRequiredWithoutParticipacionNestedInput
    area?: AreasUpdateOneRequiredWithoutParticipacionNestedInput
    nivel?: NivelesUpdateOneRequiredWithoutParticipacionNestedInput
    evaluaciones?: EvaluacionesUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionCreateManyInput = {
    id?: number
    olimpista_id: number
    area_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
  }

  export type ParticipacionUpdateManyMutationInput = {
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
  }

  export type ParticipacionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
  }

  export type ReportesCreateInput = {
    tipo: string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: string | null
    generado_en?: Date | string | null
    generadoPor?: UsuariosCreateNestedOneWithoutReportesInput
  }

  export type ReportesUncheckedCreateInput = {
    id?: number
    tipo: string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: string | null
    generado_por: number
    generado_en?: Date | string | null
  }

  export type ReportesUpdateInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    generadoPor?: UsuariosUpdateOneWithoutReportesNestedInput
  }

  export type ReportesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_por?: IntFieldUpdateOperationsInput | number
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportesCreateManyInput = {
    id?: number
    tipo: string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: string | null
    generado_por: number
    generado_en?: Date | string | null
  }

  export type ReportesUpdateManyMutationInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_por?: IntFieldUpdateOperationsInput | number
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RolesCreateInput = {
    nombre: string
    descripcion?: string | null
    usuario_rol?: UsuarioRolCreateNestedManyWithoutRolInput
  }

  export type RolesUncheckedCreateInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    usuario_rol?: UsuarioRolUncheckedCreateNestedManyWithoutRolInput
  }

  export type RolesUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_rol?: UsuarioRolUpdateManyWithoutRolNestedInput
  }

  export type RolesUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    usuario_rol?: UsuarioRolUncheckedUpdateManyWithoutRolNestedInput
  }

  export type RolesCreateManyInput = {
    id?: number
    nombre: string
    descripcion?: string | null
  }

  export type RolesUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolesUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TutoresCreateInput = {
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    telefono?: string | null
    correo?: string | null
    unidad_educativa: string
    profesion?: string | null
    creado_en?: Date | string
    olimpistas?: OlimpistasCreateNestedManyWithoutTutorInput
  }

  export type TutoresUncheckedCreateInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    telefono?: string | null
    correo?: string | null
    unidad_educativa: string
    profesion?: string | null
    creado_en?: Date | string
    olimpistas?: OlimpistasUncheckedCreateNestedManyWithoutTutorInput
  }

  export type TutoresUpdateInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    olimpistas?: OlimpistasUpdateManyWithoutTutorNestedInput
  }

  export type TutoresUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    olimpistas?: OlimpistasUncheckedUpdateManyWithoutTutorNestedInput
  }

  export type TutoresCreateManyInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    telefono?: string | null
    correo?: string | null
    unidad_educativa: string
    profesion?: string | null
    creado_en?: Date | string
  }

  export type TutoresUpdateManyMutationInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoresUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioRolCreateInput = {
    usuario?: UsuariosCreateNestedOneWithoutUsuario_rolInput
    rol?: RolesCreateNestedOneWithoutUsuario_rolInput
  }

  export type UsuarioRolUncheckedCreateInput = {
    id?: number
    usuario_id?: number | null
    rol_id?: number | null
  }

  export type UsuarioRolUpdateInput = {
    usuario?: UsuariosUpdateOneWithoutUsuario_rolNestedInput
    rol?: RolesUpdateOneWithoutUsuario_rolNestedInput
  }

  export type UsuarioRolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    rol_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioRolCreateManyInput = {
    id?: number
    usuario_id?: number | null
    rol_id?: number | null
  }

  export type UsuarioRolUpdateManyMutationInput = {

  }

  export type UsuarioRolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
    rol_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuariosCreateInput = {
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesCreateNestedManyWithoutEvaluadorInput
    logs?: LogsCreateNestedManyWithoutUsuarioInput
    reportes?: ReportesCreateNestedManyWithoutGeneradoPorInput
    usuario_rol?: UsuarioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosUncheckedCreateInput = {
    id?: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutEvaluadorInput
    logs?: LogsUncheckedCreateNestedManyWithoutUsuarioInput
    reportes?: ReportesUncheckedCreateNestedManyWithoutGeneradoPorInput
    usuario_rol?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosUpdateInput = {
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUpdateManyWithoutEvaluadorNestedInput
    logs?: LogsUpdateManyWithoutUsuarioNestedInput
    reportes?: ReportesUpdateManyWithoutGeneradoPorNestedInput
    usuario_rol?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuariosUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutEvaluadorNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUsuarioNestedInput
    reportes?: ReportesUncheckedUpdateManyWithoutGeneradoPorNestedInput
    usuario_rol?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuariosCreateManyInput = {
    id?: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
  }

  export type UsuariosUpdateManyMutationInput = {
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuariosUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ConfigMedallasListRelationFilter = {
    every?: ConfigMedallasWhereInput
    some?: ConfigMedallasWhereInput
    none?: ConfigMedallasWhereInput
  }

  export type ParticipacionListRelationFilter = {
    every?: ParticipacionWhereInput
    some?: ParticipacionWhereInput
    none?: ParticipacionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ConfigMedallasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ParticipacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AreasCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
  }

  export type AreasAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AreasMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
  }

  export type AreasMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
  }

  export type AreasSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type AreasScalarRelationFilter = {
    is?: AreasWhereInput
    isNot?: AreasWhereInput
  }

  export type NivelesScalarRelationFilter = {
    is?: NivelesWhereInput
    isNot?: NivelesWhereInput
  }

  export type ConfigMedallasCountOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
  }

  export type ConfigMedallasAvgOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
  }

  export type ConfigMedallasMaxOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
  }

  export type ConfigMedallasMinOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
  }

  export type ConfigMedallasSumOrderByAggregateInput = {
    id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    oros?: SortOrder
    platas?: SortOrder
    bronces?: SortOrder
    menciones?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type ParticipacionScalarRelationFilter = {
    is?: ParticipacionWhereInput
    isNot?: ParticipacionWhereInput
  }

  export type UsuariosNullableScalarRelationFilter = {
    is?: UsuariosWhereInput | null
    isNot?: UsuariosWhereInput | null
  }

  export type FasesNullableScalarRelationFilter = {
    is?: FasesWhereInput | null
    isNot?: FasesWhereInput | null
  }

  export type EvaluacionesCountOrderByAggregateInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrder
    fase_id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    creado_en?: SortOrder
    validado?: SortOrder
    ultima_modificacion?: SortOrder
  }

  export type EvaluacionesAvgOrderByAggregateInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrder
    fase_id?: SortOrder
    nota?: SortOrder
  }

  export type EvaluacionesMaxOrderByAggregateInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrder
    fase_id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    creado_en?: SortOrder
    validado?: SortOrder
    ultima_modificacion?: SortOrder
  }

  export type EvaluacionesMinOrderByAggregateInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrder
    fase_id?: SortOrder
    nota?: SortOrder
    comentario?: SortOrder
    creado_en?: SortOrder
    validado?: SortOrder
    ultima_modificacion?: SortOrder
  }

  export type EvaluacionesSumOrderByAggregateInput = {
    id?: SortOrder
    participacion_id?: SortOrder
    evaluador_id?: SortOrder
    fase_id?: SortOrder
    nota?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumEstadoFaseFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoFase | EnumEstadoFaseFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoFaseFilter<$PrismaModel> | $Enums.EstadoFase
  }

  export type EvaluacionesListRelationFilter = {
    every?: EvaluacionesWhereInput
    some?: EvaluacionesWhereInput
    none?: EvaluacionesWhereInput
  }

  export type EvaluacionesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FasesCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    estado?: SortOrder
  }

  export type FasesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FasesMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    estado?: SortOrder
  }

  export type FasesMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    inicio?: SortOrder
    fin?: SortOrder
    estado?: SortOrder
  }

  export type FasesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumEstadoFaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoFase | EnumEstadoFaseFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoFaseWithAggregatesFilter<$PrismaModel> | $Enums.EstadoFase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFaseFilter<$PrismaModel>
    _max?: NestedEnumEstadoFaseFilter<$PrismaModel>
  }

  export type LogsCountOrderByAggregateInput = {
    id?: SortOrder
    entidad?: SortOrder
    entidad_id?: SortOrder
    campo?: SortOrder
    valor_anterior?: SortOrder
    valor_nuevo?: SortOrder
    usuario_id?: SortOrder
    fecha_cambio?: SortOrder
    motivo?: SortOrder
  }

  export type LogsAvgOrderByAggregateInput = {
    id?: SortOrder
    entidad_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type LogsMaxOrderByAggregateInput = {
    id?: SortOrder
    entidad?: SortOrder
    entidad_id?: SortOrder
    campo?: SortOrder
    valor_anterior?: SortOrder
    valor_nuevo?: SortOrder
    usuario_id?: SortOrder
    fecha_cambio?: SortOrder
    motivo?: SortOrder
  }

  export type LogsMinOrderByAggregateInput = {
    id?: SortOrder
    entidad?: SortOrder
    entidad_id?: SortOrder
    campo?: SortOrder
    valor_anterior?: SortOrder
    valor_nuevo?: SortOrder
    usuario_id?: SortOrder
    fecha_cambio?: SortOrder
    motivo?: SortOrder
  }

  export type LogsSumOrderByAggregateInput = {
    id?: SortOrder
    entidad_id?: SortOrder
    usuario_id?: SortOrder
  }

  export type EnumRolEquipoFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEquipo | EnumRolEquipoFieldRefInput<$PrismaModel>
    in?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEquipoFilter<$PrismaModel> | $Enums.RolEquipo
  }

  export type OlimpistasScalarRelationFilter = {
    is?: OlimpistasWhereInput
    isNot?: OlimpistasWhereInput
  }

  export type MiembrosEquipoCountOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    nombre_equipo?: SortOrder
    rol_en_equipo?: SortOrder
  }

  export type MiembrosEquipoAvgOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
  }

  export type MiembrosEquipoMaxOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    nombre_equipo?: SortOrder
    rol_en_equipo?: SortOrder
  }

  export type MiembrosEquipoMinOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    nombre_equipo?: SortOrder
    rol_en_equipo?: SortOrder
  }

  export type MiembrosEquipoSumOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
  }

  export type EnumRolEquipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEquipo | EnumRolEquipoFieldRefInput<$PrismaModel>
    in?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEquipoWithAggregatesFilter<$PrismaModel> | $Enums.RolEquipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolEquipoFilter<$PrismaModel>
    _max?: NestedEnumRolEquipoFilter<$PrismaModel>
  }

  export type NivelesCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
  }

  export type NivelesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type NivelesMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
  }

  export type NivelesMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    estado?: SortOrder
  }

  export type NivelesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumTipoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoFilter<$PrismaModel> | $Enums.TipoDocumento
  }

  export type EnumSexoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableFilter<$PrismaModel> | $Enums.Sexo | null
  }

  export type TutoresNullableScalarRelationFilter = {
    is?: TutoresWhereInput | null
    isNot?: TutoresWhereInput | null
  }

  export type MiembrosEquipoListRelationFilter = {
    every?: MiembrosEquipoWhereInput
    some?: MiembrosEquipoWhereInput
    none?: MiembrosEquipoWhereInput
  }

  export type MiembrosEquipoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OlimpistasTipo_documentoNumero_documentoCompoundUniqueInput = {
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
  }

  export type OlimpistasCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    unidad_educativa?: SortOrder
    departamento?: SortOrder
    grado?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    activo?: SortOrder
    creado_en?: SortOrder
    tutor_id?: SortOrder
  }

  export type OlimpistasAvgOrderByAggregateInput = {
    id?: SortOrder
    tutor_id?: SortOrder
  }

  export type OlimpistasMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    unidad_educativa?: SortOrder
    departamento?: SortOrder
    grado?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    activo?: SortOrder
    creado_en?: SortOrder
    tutor_id?: SortOrder
  }

  export type OlimpistasMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    unidad_educativa?: SortOrder
    departamento?: SortOrder
    grado?: SortOrder
    fecha_nacimiento?: SortOrder
    sexo?: SortOrder
    activo?: SortOrder
    creado_en?: SortOrder
    tutor_id?: SortOrder
  }

  export type OlimpistasSumOrderByAggregateInput = {
    id?: SortOrder
    tutor_id?: SortOrder
  }

  export type EnumTipoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.TipoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumTipoDocumentoFilter<$PrismaModel>
  }

  export type EnumSexoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexoNullableFilter<$PrismaModel>
    _max?: NestedEnumSexoNullableFilter<$PrismaModel>
  }

  export type EnumEstadoParticipacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoParticipacion | EnumEstadoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoParticipacionFilter<$PrismaModel> | $Enums.EstadoParticipacion
  }

  export type EnumTipoParticipacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParticipacion | EnumTipoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParticipacionFilter<$PrismaModel> | $Enums.TipoParticipacion
  }

  export type ParticipacionCountOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    estado?: SortOrder
    tipo?: SortOrder
  }

  export type ParticipacionAvgOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
  }

  export type ParticipacionMaxOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    estado?: SortOrder
    tipo?: SortOrder
  }

  export type ParticipacionMinOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
    estado?: SortOrder
    tipo?: SortOrder
  }

  export type ParticipacionSumOrderByAggregateInput = {
    id?: SortOrder
    olimpista_id?: SortOrder
    area_id?: SortOrder
    nivel_id?: SortOrder
  }

  export type EnumEstadoParticipacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoParticipacion | EnumEstadoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoParticipacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoParticipacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoParticipacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoParticipacionFilter<$PrismaModel>
  }

  export type EnumTipoParticipacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParticipacion | EnumTipoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParticipacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoParticipacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoParticipacionFilter<$PrismaModel>
    _max?: NestedEnumTipoParticipacionFilter<$PrismaModel>
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ReportesCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    parametros?: SortOrder
    archivo?: SortOrder
    generado_por?: SortOrder
    generado_en?: SortOrder
  }

  export type ReportesAvgOrderByAggregateInput = {
    id?: SortOrder
    generado_por?: SortOrder
  }

  export type ReportesMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    archivo?: SortOrder
    generado_por?: SortOrder
    generado_en?: SortOrder
  }

  export type ReportesMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    archivo?: SortOrder
    generado_por?: SortOrder
    generado_en?: SortOrder
  }

  export type ReportesSumOrderByAggregateInput = {
    id?: SortOrder
    generado_por?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type UsuarioRolListRelationFilter = {
    every?: UsuarioRolWhereInput
    some?: UsuarioRolWhereInput
    none?: UsuarioRolWhereInput
  }

  export type UsuarioRolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RolesCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type RolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type RolesMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
  }

  export type RolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OlimpistasListRelationFilter = {
    every?: OlimpistasWhereInput
    some?: OlimpistasWhereInput
    none?: OlimpistasWhereInput
  }

  export type OlimpistasOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TutoresTipo_documentoNumero_documentoCompoundUniqueInput = {
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
  }

  export type TutoresCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    unidad_educativa?: SortOrder
    profesion?: SortOrder
    creado_en?: SortOrder
  }

  export type TutoresAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TutoresMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    unidad_educativa?: SortOrder
    profesion?: SortOrder
    creado_en?: SortOrder
  }

  export type TutoresMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    telefono?: SortOrder
    correo?: SortOrder
    unidad_educativa?: SortOrder
    profesion?: SortOrder
    creado_en?: SortOrder
  }

  export type TutoresSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type RolesNullableScalarRelationFilter = {
    is?: RolesWhereInput | null
    isNot?: RolesWhereInput | null
  }

  export type UsuarioRolCountOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol_id?: SortOrder
  }

  export type UsuarioRolAvgOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol_id?: SortOrder
  }

  export type UsuarioRolMaxOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol_id?: SortOrder
  }

  export type UsuarioRolMinOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol_id?: SortOrder
  }

  export type UsuarioRolSumOrderByAggregateInput = {
    id?: SortOrder
    usuario_id?: SortOrder
    rol_id?: SortOrder
  }

  export type LogsListRelationFilter = {
    every?: LogsWhereInput
    some?: LogsWhereInput
    none?: LogsWhereInput
  }

  export type ReportesListRelationFilter = {
    every?: ReportesWhereInput
    some?: ReportesWhereInput
    none?: ReportesWhereInput
  }

  export type LogsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReportesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuariosCountOrderByAggregateInput = {
    id?: SortOrder
    contrasena_hash?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    cargo?: SortOrder
    profesion?: SortOrder
    institucion?: SortOrder
    estado?: SortOrder
    creado_en?: SortOrder
    actualizado_en?: SortOrder
  }

  export type UsuariosAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UsuariosMaxOrderByAggregateInput = {
    id?: SortOrder
    contrasena_hash?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    cargo?: SortOrder
    profesion?: SortOrder
    institucion?: SortOrder
    estado?: SortOrder
    creado_en?: SortOrder
    actualizado_en?: SortOrder
  }

  export type UsuariosMinOrderByAggregateInput = {
    id?: SortOrder
    contrasena_hash?: SortOrder
    nombre?: SortOrder
    ap_paterno?: SortOrder
    ap_materno?: SortOrder
    tipo_documento?: SortOrder
    numero_documento?: SortOrder
    correo?: SortOrder
    telefono?: SortOrder
    cargo?: SortOrder
    profesion?: SortOrder
    institucion?: SortOrder
    estado?: SortOrder
    creado_en?: SortOrder
    actualizado_en?: SortOrder
  }

  export type UsuariosSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ConfigMedallasCreateNestedManyWithoutAreaInput = {
    create?: XOR<ConfigMedallasCreateWithoutAreaInput, ConfigMedallasUncheckedCreateWithoutAreaInput> | ConfigMedallasCreateWithoutAreaInput[] | ConfigMedallasUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutAreaInput | ConfigMedallasCreateOrConnectWithoutAreaInput[]
    createMany?: ConfigMedallasCreateManyAreaInputEnvelope
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
  }

  export type ParticipacionCreateNestedManyWithoutAreaInput = {
    create?: XOR<ParticipacionCreateWithoutAreaInput, ParticipacionUncheckedCreateWithoutAreaInput> | ParticipacionCreateWithoutAreaInput[] | ParticipacionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutAreaInput | ParticipacionCreateOrConnectWithoutAreaInput[]
    createMany?: ParticipacionCreateManyAreaInputEnvelope
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
  }

  export type ConfigMedallasUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ConfigMedallasCreateWithoutAreaInput, ConfigMedallasUncheckedCreateWithoutAreaInput> | ConfigMedallasCreateWithoutAreaInput[] | ConfigMedallasUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutAreaInput | ConfigMedallasCreateOrConnectWithoutAreaInput[]
    createMany?: ConfigMedallasCreateManyAreaInputEnvelope
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
  }

  export type ParticipacionUncheckedCreateNestedManyWithoutAreaInput = {
    create?: XOR<ParticipacionCreateWithoutAreaInput, ParticipacionUncheckedCreateWithoutAreaInput> | ParticipacionCreateWithoutAreaInput[] | ParticipacionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutAreaInput | ParticipacionCreateOrConnectWithoutAreaInput[]
    createMany?: ParticipacionCreateManyAreaInputEnvelope
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ConfigMedallasUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ConfigMedallasCreateWithoutAreaInput, ConfigMedallasUncheckedCreateWithoutAreaInput> | ConfigMedallasCreateWithoutAreaInput[] | ConfigMedallasUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutAreaInput | ConfigMedallasCreateOrConnectWithoutAreaInput[]
    upsert?: ConfigMedallasUpsertWithWhereUniqueWithoutAreaInput | ConfigMedallasUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ConfigMedallasCreateManyAreaInputEnvelope
    set?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    disconnect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    delete?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    update?: ConfigMedallasUpdateWithWhereUniqueWithoutAreaInput | ConfigMedallasUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ConfigMedallasUpdateManyWithWhereWithoutAreaInput | ConfigMedallasUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ConfigMedallasScalarWhereInput | ConfigMedallasScalarWhereInput[]
  }

  export type ParticipacionUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ParticipacionCreateWithoutAreaInput, ParticipacionUncheckedCreateWithoutAreaInput> | ParticipacionCreateWithoutAreaInput[] | ParticipacionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutAreaInput | ParticipacionCreateOrConnectWithoutAreaInput[]
    upsert?: ParticipacionUpsertWithWhereUniqueWithoutAreaInput | ParticipacionUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ParticipacionCreateManyAreaInputEnvelope
    set?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    disconnect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    delete?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    update?: ParticipacionUpdateWithWhereUniqueWithoutAreaInput | ParticipacionUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ParticipacionUpdateManyWithWhereWithoutAreaInput | ParticipacionUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ConfigMedallasUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ConfigMedallasCreateWithoutAreaInput, ConfigMedallasUncheckedCreateWithoutAreaInput> | ConfigMedallasCreateWithoutAreaInput[] | ConfigMedallasUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutAreaInput | ConfigMedallasCreateOrConnectWithoutAreaInput[]
    upsert?: ConfigMedallasUpsertWithWhereUniqueWithoutAreaInput | ConfigMedallasUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ConfigMedallasCreateManyAreaInputEnvelope
    set?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    disconnect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    delete?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    update?: ConfigMedallasUpdateWithWhereUniqueWithoutAreaInput | ConfigMedallasUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ConfigMedallasUpdateManyWithWhereWithoutAreaInput | ConfigMedallasUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ConfigMedallasScalarWhereInput | ConfigMedallasScalarWhereInput[]
  }

  export type ParticipacionUncheckedUpdateManyWithoutAreaNestedInput = {
    create?: XOR<ParticipacionCreateWithoutAreaInput, ParticipacionUncheckedCreateWithoutAreaInput> | ParticipacionCreateWithoutAreaInput[] | ParticipacionUncheckedCreateWithoutAreaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutAreaInput | ParticipacionCreateOrConnectWithoutAreaInput[]
    upsert?: ParticipacionUpsertWithWhereUniqueWithoutAreaInput | ParticipacionUpsertWithWhereUniqueWithoutAreaInput[]
    createMany?: ParticipacionCreateManyAreaInputEnvelope
    set?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    disconnect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    delete?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    update?: ParticipacionUpdateWithWhereUniqueWithoutAreaInput | ParticipacionUpdateWithWhereUniqueWithoutAreaInput[]
    updateMany?: ParticipacionUpdateManyWithWhereWithoutAreaInput | ParticipacionUpdateManyWithWhereWithoutAreaInput[]
    deleteMany?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
  }

  export type AreasCreateNestedOneWithoutConfig_medallasInput = {
    create?: XOR<AreasCreateWithoutConfig_medallasInput, AreasUncheckedCreateWithoutConfig_medallasInput>
    connectOrCreate?: AreasCreateOrConnectWithoutConfig_medallasInput
    connect?: AreasWhereUniqueInput
  }

  export type NivelesCreateNestedOneWithoutConfigMedallasInput = {
    create?: XOR<NivelesCreateWithoutConfigMedallasInput, NivelesUncheckedCreateWithoutConfigMedallasInput>
    connectOrCreate?: NivelesCreateOrConnectWithoutConfigMedallasInput
    connect?: NivelesWhereUniqueInput
  }

  export type AreasUpdateOneRequiredWithoutConfig_medallasNestedInput = {
    create?: XOR<AreasCreateWithoutConfig_medallasInput, AreasUncheckedCreateWithoutConfig_medallasInput>
    connectOrCreate?: AreasCreateOrConnectWithoutConfig_medallasInput
    upsert?: AreasUpsertWithoutConfig_medallasInput
    connect?: AreasWhereUniqueInput
    update?: XOR<XOR<AreasUpdateToOneWithWhereWithoutConfig_medallasInput, AreasUpdateWithoutConfig_medallasInput>, AreasUncheckedUpdateWithoutConfig_medallasInput>
  }

  export type NivelesUpdateOneRequiredWithoutConfigMedallasNestedInput = {
    create?: XOR<NivelesCreateWithoutConfigMedallasInput, NivelesUncheckedCreateWithoutConfigMedallasInput>
    connectOrCreate?: NivelesCreateOrConnectWithoutConfigMedallasInput
    upsert?: NivelesUpsertWithoutConfigMedallasInput
    connect?: NivelesWhereUniqueInput
    update?: XOR<XOR<NivelesUpdateToOneWithWhereWithoutConfigMedallasInput, NivelesUpdateWithoutConfigMedallasInput>, NivelesUncheckedUpdateWithoutConfigMedallasInput>
  }

  export type ParticipacionCreateNestedOneWithoutEvaluacionesInput = {
    create?: XOR<ParticipacionCreateWithoutEvaluacionesInput, ParticipacionUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: ParticipacionCreateOrConnectWithoutEvaluacionesInput
    connect?: ParticipacionWhereUniqueInput
  }

  export type UsuariosCreateNestedOneWithoutEvaluacionesInput = {
    create?: XOR<UsuariosCreateWithoutEvaluacionesInput, UsuariosUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutEvaluacionesInput
    connect?: UsuariosWhereUniqueInput
  }

  export type FasesCreateNestedOneWithoutEvaluacionesInput = {
    create?: XOR<FasesCreateWithoutEvaluacionesInput, FasesUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: FasesCreateOrConnectWithoutEvaluacionesInput
    connect?: FasesWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ParticipacionUpdateOneRequiredWithoutEvaluacionesNestedInput = {
    create?: XOR<ParticipacionCreateWithoutEvaluacionesInput, ParticipacionUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: ParticipacionCreateOrConnectWithoutEvaluacionesInput
    upsert?: ParticipacionUpsertWithoutEvaluacionesInput
    connect?: ParticipacionWhereUniqueInput
    update?: XOR<XOR<ParticipacionUpdateToOneWithWhereWithoutEvaluacionesInput, ParticipacionUpdateWithoutEvaluacionesInput>, ParticipacionUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type UsuariosUpdateOneWithoutEvaluacionesNestedInput = {
    create?: XOR<UsuariosCreateWithoutEvaluacionesInput, UsuariosUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutEvaluacionesInput
    upsert?: UsuariosUpsertWithoutEvaluacionesInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutEvaluacionesInput, UsuariosUpdateWithoutEvaluacionesInput>, UsuariosUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type FasesUpdateOneWithoutEvaluacionesNestedInput = {
    create?: XOR<FasesCreateWithoutEvaluacionesInput, FasesUncheckedCreateWithoutEvaluacionesInput>
    connectOrCreate?: FasesCreateOrConnectWithoutEvaluacionesInput
    upsert?: FasesUpsertWithoutEvaluacionesInput
    disconnect?: FasesWhereInput | boolean
    delete?: FasesWhereInput | boolean
    connect?: FasesWhereUniqueInput
    update?: XOR<XOR<FasesUpdateToOneWithWhereWithoutEvaluacionesInput, FasesUpdateWithoutEvaluacionesInput>, FasesUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EvaluacionesCreateNestedManyWithoutFaseInput = {
    create?: XOR<EvaluacionesCreateWithoutFaseInput, EvaluacionesUncheckedCreateWithoutFaseInput> | EvaluacionesCreateWithoutFaseInput[] | EvaluacionesUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutFaseInput | EvaluacionesCreateOrConnectWithoutFaseInput[]
    createMany?: EvaluacionesCreateManyFaseInputEnvelope
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
  }

  export type EvaluacionesUncheckedCreateNestedManyWithoutFaseInput = {
    create?: XOR<EvaluacionesCreateWithoutFaseInput, EvaluacionesUncheckedCreateWithoutFaseInput> | EvaluacionesCreateWithoutFaseInput[] | EvaluacionesUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutFaseInput | EvaluacionesCreateOrConnectWithoutFaseInput[]
    createMany?: EvaluacionesCreateManyFaseInputEnvelope
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
  }

  export type EnumEstadoFaseFieldUpdateOperationsInput = {
    set?: $Enums.EstadoFase
  }

  export type EvaluacionesUpdateManyWithoutFaseNestedInput = {
    create?: XOR<EvaluacionesCreateWithoutFaseInput, EvaluacionesUncheckedCreateWithoutFaseInput> | EvaluacionesCreateWithoutFaseInput[] | EvaluacionesUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutFaseInput | EvaluacionesCreateOrConnectWithoutFaseInput[]
    upsert?: EvaluacionesUpsertWithWhereUniqueWithoutFaseInput | EvaluacionesUpsertWithWhereUniqueWithoutFaseInput[]
    createMany?: EvaluacionesCreateManyFaseInputEnvelope
    set?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    disconnect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    delete?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    update?: EvaluacionesUpdateWithWhereUniqueWithoutFaseInput | EvaluacionesUpdateWithWhereUniqueWithoutFaseInput[]
    updateMany?: EvaluacionesUpdateManyWithWhereWithoutFaseInput | EvaluacionesUpdateManyWithWhereWithoutFaseInput[]
    deleteMany?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
  }

  export type EvaluacionesUncheckedUpdateManyWithoutFaseNestedInput = {
    create?: XOR<EvaluacionesCreateWithoutFaseInput, EvaluacionesUncheckedCreateWithoutFaseInput> | EvaluacionesCreateWithoutFaseInput[] | EvaluacionesUncheckedCreateWithoutFaseInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutFaseInput | EvaluacionesCreateOrConnectWithoutFaseInput[]
    upsert?: EvaluacionesUpsertWithWhereUniqueWithoutFaseInput | EvaluacionesUpsertWithWhereUniqueWithoutFaseInput[]
    createMany?: EvaluacionesCreateManyFaseInputEnvelope
    set?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    disconnect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    delete?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    update?: EvaluacionesUpdateWithWhereUniqueWithoutFaseInput | EvaluacionesUpdateWithWhereUniqueWithoutFaseInput[]
    updateMany?: EvaluacionesUpdateManyWithWhereWithoutFaseInput | EvaluacionesUpdateManyWithWhereWithoutFaseInput[]
    deleteMany?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
  }

  export type UsuariosCreateNestedOneWithoutLogsInput = {
    create?: XOR<UsuariosCreateWithoutLogsInput, UsuariosUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutLogsInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutLogsNestedInput = {
    create?: XOR<UsuariosCreateWithoutLogsInput, UsuariosUncheckedCreateWithoutLogsInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutLogsInput
    upsert?: UsuariosUpsertWithoutLogsInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutLogsInput, UsuariosUpdateWithoutLogsInput>, UsuariosUncheckedUpdateWithoutLogsInput>
  }

  export type OlimpistasCreateNestedOneWithoutMiembros_equipoInput = {
    create?: XOR<OlimpistasCreateWithoutMiembros_equipoInput, OlimpistasUncheckedCreateWithoutMiembros_equipoInput>
    connectOrCreate?: OlimpistasCreateOrConnectWithoutMiembros_equipoInput
    connect?: OlimpistasWhereUniqueInput
  }

  export type EnumRolEquipoFieldUpdateOperationsInput = {
    set?: $Enums.RolEquipo
  }

  export type OlimpistasUpdateOneRequiredWithoutMiembros_equipoNestedInput = {
    create?: XOR<OlimpistasCreateWithoutMiembros_equipoInput, OlimpistasUncheckedCreateWithoutMiembros_equipoInput>
    connectOrCreate?: OlimpistasCreateOrConnectWithoutMiembros_equipoInput
    upsert?: OlimpistasUpsertWithoutMiembros_equipoInput
    connect?: OlimpistasWhereUniqueInput
    update?: XOR<XOR<OlimpistasUpdateToOneWithWhereWithoutMiembros_equipoInput, OlimpistasUpdateWithoutMiembros_equipoInput>, OlimpistasUncheckedUpdateWithoutMiembros_equipoInput>
  }

  export type ParticipacionCreateNestedManyWithoutNivelInput = {
    create?: XOR<ParticipacionCreateWithoutNivelInput, ParticipacionUncheckedCreateWithoutNivelInput> | ParticipacionCreateWithoutNivelInput[] | ParticipacionUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutNivelInput | ParticipacionCreateOrConnectWithoutNivelInput[]
    createMany?: ParticipacionCreateManyNivelInputEnvelope
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
  }

  export type ConfigMedallasCreateNestedManyWithoutNivelInput = {
    create?: XOR<ConfigMedallasCreateWithoutNivelInput, ConfigMedallasUncheckedCreateWithoutNivelInput> | ConfigMedallasCreateWithoutNivelInput[] | ConfigMedallasUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutNivelInput | ConfigMedallasCreateOrConnectWithoutNivelInput[]
    createMany?: ConfigMedallasCreateManyNivelInputEnvelope
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
  }

  export type ParticipacionUncheckedCreateNestedManyWithoutNivelInput = {
    create?: XOR<ParticipacionCreateWithoutNivelInput, ParticipacionUncheckedCreateWithoutNivelInput> | ParticipacionCreateWithoutNivelInput[] | ParticipacionUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutNivelInput | ParticipacionCreateOrConnectWithoutNivelInput[]
    createMany?: ParticipacionCreateManyNivelInputEnvelope
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
  }

  export type ConfigMedallasUncheckedCreateNestedManyWithoutNivelInput = {
    create?: XOR<ConfigMedallasCreateWithoutNivelInput, ConfigMedallasUncheckedCreateWithoutNivelInput> | ConfigMedallasCreateWithoutNivelInput[] | ConfigMedallasUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutNivelInput | ConfigMedallasCreateOrConnectWithoutNivelInput[]
    createMany?: ConfigMedallasCreateManyNivelInputEnvelope
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
  }

  export type ParticipacionUpdateManyWithoutNivelNestedInput = {
    create?: XOR<ParticipacionCreateWithoutNivelInput, ParticipacionUncheckedCreateWithoutNivelInput> | ParticipacionCreateWithoutNivelInput[] | ParticipacionUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutNivelInput | ParticipacionCreateOrConnectWithoutNivelInput[]
    upsert?: ParticipacionUpsertWithWhereUniqueWithoutNivelInput | ParticipacionUpsertWithWhereUniqueWithoutNivelInput[]
    createMany?: ParticipacionCreateManyNivelInputEnvelope
    set?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    disconnect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    delete?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    update?: ParticipacionUpdateWithWhereUniqueWithoutNivelInput | ParticipacionUpdateWithWhereUniqueWithoutNivelInput[]
    updateMany?: ParticipacionUpdateManyWithWhereWithoutNivelInput | ParticipacionUpdateManyWithWhereWithoutNivelInput[]
    deleteMany?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
  }

  export type ConfigMedallasUpdateManyWithoutNivelNestedInput = {
    create?: XOR<ConfigMedallasCreateWithoutNivelInput, ConfigMedallasUncheckedCreateWithoutNivelInput> | ConfigMedallasCreateWithoutNivelInput[] | ConfigMedallasUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutNivelInput | ConfigMedallasCreateOrConnectWithoutNivelInput[]
    upsert?: ConfigMedallasUpsertWithWhereUniqueWithoutNivelInput | ConfigMedallasUpsertWithWhereUniqueWithoutNivelInput[]
    createMany?: ConfigMedallasCreateManyNivelInputEnvelope
    set?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    disconnect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    delete?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    update?: ConfigMedallasUpdateWithWhereUniqueWithoutNivelInput | ConfigMedallasUpdateWithWhereUniqueWithoutNivelInput[]
    updateMany?: ConfigMedallasUpdateManyWithWhereWithoutNivelInput | ConfigMedallasUpdateManyWithWhereWithoutNivelInput[]
    deleteMany?: ConfigMedallasScalarWhereInput | ConfigMedallasScalarWhereInput[]
  }

  export type ParticipacionUncheckedUpdateManyWithoutNivelNestedInput = {
    create?: XOR<ParticipacionCreateWithoutNivelInput, ParticipacionUncheckedCreateWithoutNivelInput> | ParticipacionCreateWithoutNivelInput[] | ParticipacionUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutNivelInput | ParticipacionCreateOrConnectWithoutNivelInput[]
    upsert?: ParticipacionUpsertWithWhereUniqueWithoutNivelInput | ParticipacionUpsertWithWhereUniqueWithoutNivelInput[]
    createMany?: ParticipacionCreateManyNivelInputEnvelope
    set?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    disconnect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    delete?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    update?: ParticipacionUpdateWithWhereUniqueWithoutNivelInput | ParticipacionUpdateWithWhereUniqueWithoutNivelInput[]
    updateMany?: ParticipacionUpdateManyWithWhereWithoutNivelInput | ParticipacionUpdateManyWithWhereWithoutNivelInput[]
    deleteMany?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
  }

  export type ConfigMedallasUncheckedUpdateManyWithoutNivelNestedInput = {
    create?: XOR<ConfigMedallasCreateWithoutNivelInput, ConfigMedallasUncheckedCreateWithoutNivelInput> | ConfigMedallasCreateWithoutNivelInput[] | ConfigMedallasUncheckedCreateWithoutNivelInput[]
    connectOrCreate?: ConfigMedallasCreateOrConnectWithoutNivelInput | ConfigMedallasCreateOrConnectWithoutNivelInput[]
    upsert?: ConfigMedallasUpsertWithWhereUniqueWithoutNivelInput | ConfigMedallasUpsertWithWhereUniqueWithoutNivelInput[]
    createMany?: ConfigMedallasCreateManyNivelInputEnvelope
    set?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    disconnect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    delete?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    connect?: ConfigMedallasWhereUniqueInput | ConfigMedallasWhereUniqueInput[]
    update?: ConfigMedallasUpdateWithWhereUniqueWithoutNivelInput | ConfigMedallasUpdateWithWhereUniqueWithoutNivelInput[]
    updateMany?: ConfigMedallasUpdateManyWithWhereWithoutNivelInput | ConfigMedallasUpdateManyWithWhereWithoutNivelInput[]
    deleteMany?: ConfigMedallasScalarWhereInput | ConfigMedallasScalarWhereInput[]
  }

  export type TutoresCreateNestedOneWithoutOlimpistasInput = {
    create?: XOR<TutoresCreateWithoutOlimpistasInput, TutoresUncheckedCreateWithoutOlimpistasInput>
    connectOrCreate?: TutoresCreateOrConnectWithoutOlimpistasInput
    connect?: TutoresWhereUniqueInput
  }

  export type ParticipacionCreateNestedManyWithoutOlimpistaInput = {
    create?: XOR<ParticipacionCreateWithoutOlimpistaInput, ParticipacionUncheckedCreateWithoutOlimpistaInput> | ParticipacionCreateWithoutOlimpistaInput[] | ParticipacionUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutOlimpistaInput | ParticipacionCreateOrConnectWithoutOlimpistaInput[]
    createMany?: ParticipacionCreateManyOlimpistaInputEnvelope
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
  }

  export type MiembrosEquipoCreateNestedManyWithoutOlimpistaInput = {
    create?: XOR<MiembrosEquipoCreateWithoutOlimpistaInput, MiembrosEquipoUncheckedCreateWithoutOlimpistaInput> | MiembrosEquipoCreateWithoutOlimpistaInput[] | MiembrosEquipoUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: MiembrosEquipoCreateOrConnectWithoutOlimpistaInput | MiembrosEquipoCreateOrConnectWithoutOlimpistaInput[]
    createMany?: MiembrosEquipoCreateManyOlimpistaInputEnvelope
    connect?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
  }

  export type ParticipacionUncheckedCreateNestedManyWithoutOlimpistaInput = {
    create?: XOR<ParticipacionCreateWithoutOlimpistaInput, ParticipacionUncheckedCreateWithoutOlimpistaInput> | ParticipacionCreateWithoutOlimpistaInput[] | ParticipacionUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutOlimpistaInput | ParticipacionCreateOrConnectWithoutOlimpistaInput[]
    createMany?: ParticipacionCreateManyOlimpistaInputEnvelope
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
  }

  export type MiembrosEquipoUncheckedCreateNestedManyWithoutOlimpistaInput = {
    create?: XOR<MiembrosEquipoCreateWithoutOlimpistaInput, MiembrosEquipoUncheckedCreateWithoutOlimpistaInput> | MiembrosEquipoCreateWithoutOlimpistaInput[] | MiembrosEquipoUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: MiembrosEquipoCreateOrConnectWithoutOlimpistaInput | MiembrosEquipoCreateOrConnectWithoutOlimpistaInput[]
    createMany?: MiembrosEquipoCreateManyOlimpistaInputEnvelope
    connect?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
  }

  export type EnumTipoDocumentoFieldUpdateOperationsInput = {
    set?: $Enums.TipoDocumento
  }

  export type NullableEnumSexoFieldUpdateOperationsInput = {
    set?: $Enums.Sexo | null
  }

  export type TutoresUpdateOneWithoutOlimpistasNestedInput = {
    create?: XOR<TutoresCreateWithoutOlimpistasInput, TutoresUncheckedCreateWithoutOlimpistasInput>
    connectOrCreate?: TutoresCreateOrConnectWithoutOlimpistasInput
    upsert?: TutoresUpsertWithoutOlimpistasInput
    disconnect?: TutoresWhereInput | boolean
    delete?: TutoresWhereInput | boolean
    connect?: TutoresWhereUniqueInput
    update?: XOR<XOR<TutoresUpdateToOneWithWhereWithoutOlimpistasInput, TutoresUpdateWithoutOlimpistasInput>, TutoresUncheckedUpdateWithoutOlimpistasInput>
  }

  export type ParticipacionUpdateManyWithoutOlimpistaNestedInput = {
    create?: XOR<ParticipacionCreateWithoutOlimpistaInput, ParticipacionUncheckedCreateWithoutOlimpistaInput> | ParticipacionCreateWithoutOlimpistaInput[] | ParticipacionUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutOlimpistaInput | ParticipacionCreateOrConnectWithoutOlimpistaInput[]
    upsert?: ParticipacionUpsertWithWhereUniqueWithoutOlimpistaInput | ParticipacionUpsertWithWhereUniqueWithoutOlimpistaInput[]
    createMany?: ParticipacionCreateManyOlimpistaInputEnvelope
    set?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    disconnect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    delete?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    update?: ParticipacionUpdateWithWhereUniqueWithoutOlimpistaInput | ParticipacionUpdateWithWhereUniqueWithoutOlimpistaInput[]
    updateMany?: ParticipacionUpdateManyWithWhereWithoutOlimpistaInput | ParticipacionUpdateManyWithWhereWithoutOlimpistaInput[]
    deleteMany?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
  }

  export type MiembrosEquipoUpdateManyWithoutOlimpistaNestedInput = {
    create?: XOR<MiembrosEquipoCreateWithoutOlimpistaInput, MiembrosEquipoUncheckedCreateWithoutOlimpistaInput> | MiembrosEquipoCreateWithoutOlimpistaInput[] | MiembrosEquipoUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: MiembrosEquipoCreateOrConnectWithoutOlimpistaInput | MiembrosEquipoCreateOrConnectWithoutOlimpistaInput[]
    upsert?: MiembrosEquipoUpsertWithWhereUniqueWithoutOlimpistaInput | MiembrosEquipoUpsertWithWhereUniqueWithoutOlimpistaInput[]
    createMany?: MiembrosEquipoCreateManyOlimpistaInputEnvelope
    set?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    disconnect?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    delete?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    connect?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    update?: MiembrosEquipoUpdateWithWhereUniqueWithoutOlimpistaInput | MiembrosEquipoUpdateWithWhereUniqueWithoutOlimpistaInput[]
    updateMany?: MiembrosEquipoUpdateManyWithWhereWithoutOlimpistaInput | MiembrosEquipoUpdateManyWithWhereWithoutOlimpistaInput[]
    deleteMany?: MiembrosEquipoScalarWhereInput | MiembrosEquipoScalarWhereInput[]
  }

  export type ParticipacionUncheckedUpdateManyWithoutOlimpistaNestedInput = {
    create?: XOR<ParticipacionCreateWithoutOlimpistaInput, ParticipacionUncheckedCreateWithoutOlimpistaInput> | ParticipacionCreateWithoutOlimpistaInput[] | ParticipacionUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: ParticipacionCreateOrConnectWithoutOlimpistaInput | ParticipacionCreateOrConnectWithoutOlimpistaInput[]
    upsert?: ParticipacionUpsertWithWhereUniqueWithoutOlimpistaInput | ParticipacionUpsertWithWhereUniqueWithoutOlimpistaInput[]
    createMany?: ParticipacionCreateManyOlimpistaInputEnvelope
    set?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    disconnect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    delete?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    connect?: ParticipacionWhereUniqueInput | ParticipacionWhereUniqueInput[]
    update?: ParticipacionUpdateWithWhereUniqueWithoutOlimpistaInput | ParticipacionUpdateWithWhereUniqueWithoutOlimpistaInput[]
    updateMany?: ParticipacionUpdateManyWithWhereWithoutOlimpistaInput | ParticipacionUpdateManyWithWhereWithoutOlimpistaInput[]
    deleteMany?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
  }

  export type MiembrosEquipoUncheckedUpdateManyWithoutOlimpistaNestedInput = {
    create?: XOR<MiembrosEquipoCreateWithoutOlimpistaInput, MiembrosEquipoUncheckedCreateWithoutOlimpistaInput> | MiembrosEquipoCreateWithoutOlimpistaInput[] | MiembrosEquipoUncheckedCreateWithoutOlimpistaInput[]
    connectOrCreate?: MiembrosEquipoCreateOrConnectWithoutOlimpistaInput | MiembrosEquipoCreateOrConnectWithoutOlimpistaInput[]
    upsert?: MiembrosEquipoUpsertWithWhereUniqueWithoutOlimpistaInput | MiembrosEquipoUpsertWithWhereUniqueWithoutOlimpistaInput[]
    createMany?: MiembrosEquipoCreateManyOlimpistaInputEnvelope
    set?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    disconnect?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    delete?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    connect?: MiembrosEquipoWhereUniqueInput | MiembrosEquipoWhereUniqueInput[]
    update?: MiembrosEquipoUpdateWithWhereUniqueWithoutOlimpistaInput | MiembrosEquipoUpdateWithWhereUniqueWithoutOlimpistaInput[]
    updateMany?: MiembrosEquipoUpdateManyWithWhereWithoutOlimpistaInput | MiembrosEquipoUpdateManyWithWhereWithoutOlimpistaInput[]
    deleteMany?: MiembrosEquipoScalarWhereInput | MiembrosEquipoScalarWhereInput[]
  }

  export type OlimpistasCreateNestedOneWithoutParticipacionInput = {
    create?: XOR<OlimpistasCreateWithoutParticipacionInput, OlimpistasUncheckedCreateWithoutParticipacionInput>
    connectOrCreate?: OlimpistasCreateOrConnectWithoutParticipacionInput
    connect?: OlimpistasWhereUniqueInput
  }

  export type AreasCreateNestedOneWithoutParticipacionInput = {
    create?: XOR<AreasCreateWithoutParticipacionInput, AreasUncheckedCreateWithoutParticipacionInput>
    connectOrCreate?: AreasCreateOrConnectWithoutParticipacionInput
    connect?: AreasWhereUniqueInput
  }

  export type NivelesCreateNestedOneWithoutParticipacionInput = {
    create?: XOR<NivelesCreateWithoutParticipacionInput, NivelesUncheckedCreateWithoutParticipacionInput>
    connectOrCreate?: NivelesCreateOrConnectWithoutParticipacionInput
    connect?: NivelesWhereUniqueInput
  }

  export type EvaluacionesCreateNestedManyWithoutParticipacionInput = {
    create?: XOR<EvaluacionesCreateWithoutParticipacionInput, EvaluacionesUncheckedCreateWithoutParticipacionInput> | EvaluacionesCreateWithoutParticipacionInput[] | EvaluacionesUncheckedCreateWithoutParticipacionInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutParticipacionInput | EvaluacionesCreateOrConnectWithoutParticipacionInput[]
    createMany?: EvaluacionesCreateManyParticipacionInputEnvelope
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
  }

  export type EvaluacionesUncheckedCreateNestedManyWithoutParticipacionInput = {
    create?: XOR<EvaluacionesCreateWithoutParticipacionInput, EvaluacionesUncheckedCreateWithoutParticipacionInput> | EvaluacionesCreateWithoutParticipacionInput[] | EvaluacionesUncheckedCreateWithoutParticipacionInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutParticipacionInput | EvaluacionesCreateOrConnectWithoutParticipacionInput[]
    createMany?: EvaluacionesCreateManyParticipacionInputEnvelope
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
  }

  export type EnumEstadoParticipacionFieldUpdateOperationsInput = {
    set?: $Enums.EstadoParticipacion
  }

  export type EnumTipoParticipacionFieldUpdateOperationsInput = {
    set?: $Enums.TipoParticipacion
  }

  export type OlimpistasUpdateOneRequiredWithoutParticipacionNestedInput = {
    create?: XOR<OlimpistasCreateWithoutParticipacionInput, OlimpistasUncheckedCreateWithoutParticipacionInput>
    connectOrCreate?: OlimpistasCreateOrConnectWithoutParticipacionInput
    upsert?: OlimpistasUpsertWithoutParticipacionInput
    connect?: OlimpistasWhereUniqueInput
    update?: XOR<XOR<OlimpistasUpdateToOneWithWhereWithoutParticipacionInput, OlimpistasUpdateWithoutParticipacionInput>, OlimpistasUncheckedUpdateWithoutParticipacionInput>
  }

  export type AreasUpdateOneRequiredWithoutParticipacionNestedInput = {
    create?: XOR<AreasCreateWithoutParticipacionInput, AreasUncheckedCreateWithoutParticipacionInput>
    connectOrCreate?: AreasCreateOrConnectWithoutParticipacionInput
    upsert?: AreasUpsertWithoutParticipacionInput
    connect?: AreasWhereUniqueInput
    update?: XOR<XOR<AreasUpdateToOneWithWhereWithoutParticipacionInput, AreasUpdateWithoutParticipacionInput>, AreasUncheckedUpdateWithoutParticipacionInput>
  }

  export type NivelesUpdateOneRequiredWithoutParticipacionNestedInput = {
    create?: XOR<NivelesCreateWithoutParticipacionInput, NivelesUncheckedCreateWithoutParticipacionInput>
    connectOrCreate?: NivelesCreateOrConnectWithoutParticipacionInput
    upsert?: NivelesUpsertWithoutParticipacionInput
    connect?: NivelesWhereUniqueInput
    update?: XOR<XOR<NivelesUpdateToOneWithWhereWithoutParticipacionInput, NivelesUpdateWithoutParticipacionInput>, NivelesUncheckedUpdateWithoutParticipacionInput>
  }

  export type EvaluacionesUpdateManyWithoutParticipacionNestedInput = {
    create?: XOR<EvaluacionesCreateWithoutParticipacionInput, EvaluacionesUncheckedCreateWithoutParticipacionInput> | EvaluacionesCreateWithoutParticipacionInput[] | EvaluacionesUncheckedCreateWithoutParticipacionInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutParticipacionInput | EvaluacionesCreateOrConnectWithoutParticipacionInput[]
    upsert?: EvaluacionesUpsertWithWhereUniqueWithoutParticipacionInput | EvaluacionesUpsertWithWhereUniqueWithoutParticipacionInput[]
    createMany?: EvaluacionesCreateManyParticipacionInputEnvelope
    set?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    disconnect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    delete?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    update?: EvaluacionesUpdateWithWhereUniqueWithoutParticipacionInput | EvaluacionesUpdateWithWhereUniqueWithoutParticipacionInput[]
    updateMany?: EvaluacionesUpdateManyWithWhereWithoutParticipacionInput | EvaluacionesUpdateManyWithWhereWithoutParticipacionInput[]
    deleteMany?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
  }

  export type EvaluacionesUncheckedUpdateManyWithoutParticipacionNestedInput = {
    create?: XOR<EvaluacionesCreateWithoutParticipacionInput, EvaluacionesUncheckedCreateWithoutParticipacionInput> | EvaluacionesCreateWithoutParticipacionInput[] | EvaluacionesUncheckedCreateWithoutParticipacionInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutParticipacionInput | EvaluacionesCreateOrConnectWithoutParticipacionInput[]
    upsert?: EvaluacionesUpsertWithWhereUniqueWithoutParticipacionInput | EvaluacionesUpsertWithWhereUniqueWithoutParticipacionInput[]
    createMany?: EvaluacionesCreateManyParticipacionInputEnvelope
    set?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    disconnect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    delete?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    update?: EvaluacionesUpdateWithWhereUniqueWithoutParticipacionInput | EvaluacionesUpdateWithWhereUniqueWithoutParticipacionInput[]
    updateMany?: EvaluacionesUpdateManyWithWhereWithoutParticipacionInput | EvaluacionesUpdateManyWithWhereWithoutParticipacionInput[]
    deleteMany?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
  }

  export type UsuariosCreateNestedOneWithoutReportesInput = {
    create?: XOR<UsuariosCreateWithoutReportesInput, UsuariosUncheckedCreateWithoutReportesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutReportesInput
    connect?: UsuariosWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutReportesNestedInput = {
    create?: XOR<UsuariosCreateWithoutReportesInput, UsuariosUncheckedCreateWithoutReportesInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutReportesInput
    upsert?: UsuariosUpsertWithoutReportesInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutReportesInput, UsuariosUpdateWithoutReportesInput>, UsuariosUncheckedUpdateWithoutReportesInput>
  }

  export type UsuarioRolCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type UsuarioRolUncheckedCreateNestedManyWithoutRolInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type UsuarioRolUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutRolInput | UsuarioRolUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutRolInput | UsuarioRolUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutRolInput | UsuarioRolUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type UsuarioRolUncheckedUpdateManyWithoutRolNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput> | UsuarioRolCreateWithoutRolInput[] | UsuarioRolUncheckedCreateWithoutRolInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutRolInput | UsuarioRolCreateOrConnectWithoutRolInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutRolInput | UsuarioRolUpsertWithWhereUniqueWithoutRolInput[]
    createMany?: UsuarioRolCreateManyRolInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutRolInput | UsuarioRolUpdateWithWhereUniqueWithoutRolInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutRolInput | UsuarioRolUpdateManyWithWhereWithoutRolInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type OlimpistasCreateNestedManyWithoutTutorInput = {
    create?: XOR<OlimpistasCreateWithoutTutorInput, OlimpistasUncheckedCreateWithoutTutorInput> | OlimpistasCreateWithoutTutorInput[] | OlimpistasUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: OlimpistasCreateOrConnectWithoutTutorInput | OlimpistasCreateOrConnectWithoutTutorInput[]
    createMany?: OlimpistasCreateManyTutorInputEnvelope
    connect?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
  }

  export type OlimpistasUncheckedCreateNestedManyWithoutTutorInput = {
    create?: XOR<OlimpistasCreateWithoutTutorInput, OlimpistasUncheckedCreateWithoutTutorInput> | OlimpistasCreateWithoutTutorInput[] | OlimpistasUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: OlimpistasCreateOrConnectWithoutTutorInput | OlimpistasCreateOrConnectWithoutTutorInput[]
    createMany?: OlimpistasCreateManyTutorInputEnvelope
    connect?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
  }

  export type OlimpistasUpdateManyWithoutTutorNestedInput = {
    create?: XOR<OlimpistasCreateWithoutTutorInput, OlimpistasUncheckedCreateWithoutTutorInput> | OlimpistasCreateWithoutTutorInput[] | OlimpistasUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: OlimpistasCreateOrConnectWithoutTutorInput | OlimpistasCreateOrConnectWithoutTutorInput[]
    upsert?: OlimpistasUpsertWithWhereUniqueWithoutTutorInput | OlimpistasUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: OlimpistasCreateManyTutorInputEnvelope
    set?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    disconnect?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    delete?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    connect?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    update?: OlimpistasUpdateWithWhereUniqueWithoutTutorInput | OlimpistasUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: OlimpistasUpdateManyWithWhereWithoutTutorInput | OlimpistasUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: OlimpistasScalarWhereInput | OlimpistasScalarWhereInput[]
  }

  export type OlimpistasUncheckedUpdateManyWithoutTutorNestedInput = {
    create?: XOR<OlimpistasCreateWithoutTutorInput, OlimpistasUncheckedCreateWithoutTutorInput> | OlimpistasCreateWithoutTutorInput[] | OlimpistasUncheckedCreateWithoutTutorInput[]
    connectOrCreate?: OlimpistasCreateOrConnectWithoutTutorInput | OlimpistasCreateOrConnectWithoutTutorInput[]
    upsert?: OlimpistasUpsertWithWhereUniqueWithoutTutorInput | OlimpistasUpsertWithWhereUniqueWithoutTutorInput[]
    createMany?: OlimpistasCreateManyTutorInputEnvelope
    set?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    disconnect?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    delete?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    connect?: OlimpistasWhereUniqueInput | OlimpistasWhereUniqueInput[]
    update?: OlimpistasUpdateWithWhereUniqueWithoutTutorInput | OlimpistasUpdateWithWhereUniqueWithoutTutorInput[]
    updateMany?: OlimpistasUpdateManyWithWhereWithoutTutorInput | OlimpistasUpdateManyWithWhereWithoutTutorInput[]
    deleteMany?: OlimpistasScalarWhereInput | OlimpistasScalarWhereInput[]
  }

  export type UsuariosCreateNestedOneWithoutUsuario_rolInput = {
    create?: XOR<UsuariosCreateWithoutUsuario_rolInput, UsuariosUncheckedCreateWithoutUsuario_rolInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutUsuario_rolInput
    connect?: UsuariosWhereUniqueInput
  }

  export type RolesCreateNestedOneWithoutUsuario_rolInput = {
    create?: XOR<RolesCreateWithoutUsuario_rolInput, RolesUncheckedCreateWithoutUsuario_rolInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsuario_rolInput
    connect?: RolesWhereUniqueInput
  }

  export type UsuariosUpdateOneWithoutUsuario_rolNestedInput = {
    create?: XOR<UsuariosCreateWithoutUsuario_rolInput, UsuariosUncheckedCreateWithoutUsuario_rolInput>
    connectOrCreate?: UsuariosCreateOrConnectWithoutUsuario_rolInput
    upsert?: UsuariosUpsertWithoutUsuario_rolInput
    disconnect?: UsuariosWhereInput | boolean
    delete?: UsuariosWhereInput | boolean
    connect?: UsuariosWhereUniqueInput
    update?: XOR<XOR<UsuariosUpdateToOneWithWhereWithoutUsuario_rolInput, UsuariosUpdateWithoutUsuario_rolInput>, UsuariosUncheckedUpdateWithoutUsuario_rolInput>
  }

  export type RolesUpdateOneWithoutUsuario_rolNestedInput = {
    create?: XOR<RolesCreateWithoutUsuario_rolInput, RolesUncheckedCreateWithoutUsuario_rolInput>
    connectOrCreate?: RolesCreateOrConnectWithoutUsuario_rolInput
    upsert?: RolesUpsertWithoutUsuario_rolInput
    disconnect?: RolesWhereInput | boolean
    delete?: RolesWhereInput | boolean
    connect?: RolesWhereUniqueInput
    update?: XOR<XOR<RolesUpdateToOneWithWhereWithoutUsuario_rolInput, RolesUpdateWithoutUsuario_rolInput>, RolesUncheckedUpdateWithoutUsuario_rolInput>
  }

  export type EvaluacionesCreateNestedManyWithoutEvaluadorInput = {
    create?: XOR<EvaluacionesCreateWithoutEvaluadorInput, EvaluacionesUncheckedCreateWithoutEvaluadorInput> | EvaluacionesCreateWithoutEvaluadorInput[] | EvaluacionesUncheckedCreateWithoutEvaluadorInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutEvaluadorInput | EvaluacionesCreateOrConnectWithoutEvaluadorInput[]
    createMany?: EvaluacionesCreateManyEvaluadorInputEnvelope
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
  }

  export type LogsCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LogsCreateWithoutUsuarioInput, LogsUncheckedCreateWithoutUsuarioInput> | LogsCreateWithoutUsuarioInput[] | LogsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUsuarioInput | LogsCreateOrConnectWithoutUsuarioInput[]
    createMany?: LogsCreateManyUsuarioInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type ReportesCreateNestedManyWithoutGeneradoPorInput = {
    create?: XOR<ReportesCreateWithoutGeneradoPorInput, ReportesUncheckedCreateWithoutGeneradoPorInput> | ReportesCreateWithoutGeneradoPorInput[] | ReportesUncheckedCreateWithoutGeneradoPorInput[]
    connectOrCreate?: ReportesCreateOrConnectWithoutGeneradoPorInput | ReportesCreateOrConnectWithoutGeneradoPorInput[]
    createMany?: ReportesCreateManyGeneradoPorInputEnvelope
    connect?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
  }

  export type UsuarioRolCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type EvaluacionesUncheckedCreateNestedManyWithoutEvaluadorInput = {
    create?: XOR<EvaluacionesCreateWithoutEvaluadorInput, EvaluacionesUncheckedCreateWithoutEvaluadorInput> | EvaluacionesCreateWithoutEvaluadorInput[] | EvaluacionesUncheckedCreateWithoutEvaluadorInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutEvaluadorInput | EvaluacionesCreateOrConnectWithoutEvaluadorInput[]
    createMany?: EvaluacionesCreateManyEvaluadorInputEnvelope
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
  }

  export type LogsUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<LogsCreateWithoutUsuarioInput, LogsUncheckedCreateWithoutUsuarioInput> | LogsCreateWithoutUsuarioInput[] | LogsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUsuarioInput | LogsCreateOrConnectWithoutUsuarioInput[]
    createMany?: LogsCreateManyUsuarioInputEnvelope
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
  }

  export type ReportesUncheckedCreateNestedManyWithoutGeneradoPorInput = {
    create?: XOR<ReportesCreateWithoutGeneradoPorInput, ReportesUncheckedCreateWithoutGeneradoPorInput> | ReportesCreateWithoutGeneradoPorInput[] | ReportesUncheckedCreateWithoutGeneradoPorInput[]
    connectOrCreate?: ReportesCreateOrConnectWithoutGeneradoPorInput | ReportesCreateOrConnectWithoutGeneradoPorInput[]
    createMany?: ReportesCreateManyGeneradoPorInputEnvelope
    connect?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
  }

  export type UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
  }

  export type EvaluacionesUpdateManyWithoutEvaluadorNestedInput = {
    create?: XOR<EvaluacionesCreateWithoutEvaluadorInput, EvaluacionesUncheckedCreateWithoutEvaluadorInput> | EvaluacionesCreateWithoutEvaluadorInput[] | EvaluacionesUncheckedCreateWithoutEvaluadorInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutEvaluadorInput | EvaluacionesCreateOrConnectWithoutEvaluadorInput[]
    upsert?: EvaluacionesUpsertWithWhereUniqueWithoutEvaluadorInput | EvaluacionesUpsertWithWhereUniqueWithoutEvaluadorInput[]
    createMany?: EvaluacionesCreateManyEvaluadorInputEnvelope
    set?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    disconnect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    delete?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    update?: EvaluacionesUpdateWithWhereUniqueWithoutEvaluadorInput | EvaluacionesUpdateWithWhereUniqueWithoutEvaluadorInput[]
    updateMany?: EvaluacionesUpdateManyWithWhereWithoutEvaluadorInput | EvaluacionesUpdateManyWithWhereWithoutEvaluadorInput[]
    deleteMany?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
  }

  export type LogsUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LogsCreateWithoutUsuarioInput, LogsUncheckedCreateWithoutUsuarioInput> | LogsCreateWithoutUsuarioInput[] | LogsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUsuarioInput | LogsCreateOrConnectWithoutUsuarioInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUsuarioInput | LogsUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LogsCreateManyUsuarioInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUsuarioInput | LogsUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUsuarioInput | LogsUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type ReportesUpdateManyWithoutGeneradoPorNestedInput = {
    create?: XOR<ReportesCreateWithoutGeneradoPorInput, ReportesUncheckedCreateWithoutGeneradoPorInput> | ReportesCreateWithoutGeneradoPorInput[] | ReportesUncheckedCreateWithoutGeneradoPorInput[]
    connectOrCreate?: ReportesCreateOrConnectWithoutGeneradoPorInput | ReportesCreateOrConnectWithoutGeneradoPorInput[]
    upsert?: ReportesUpsertWithWhereUniqueWithoutGeneradoPorInput | ReportesUpsertWithWhereUniqueWithoutGeneradoPorInput[]
    createMany?: ReportesCreateManyGeneradoPorInputEnvelope
    set?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    disconnect?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    delete?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    connect?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    update?: ReportesUpdateWithWhereUniqueWithoutGeneradoPorInput | ReportesUpdateWithWhereUniqueWithoutGeneradoPorInput[]
    updateMany?: ReportesUpdateManyWithWhereWithoutGeneradoPorInput | ReportesUpdateManyWithWhereWithoutGeneradoPorInput[]
    deleteMany?: ReportesScalarWhereInput | ReportesScalarWhereInput[]
  }

  export type UsuarioRolUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutUsuarioInput | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type EvaluacionesUncheckedUpdateManyWithoutEvaluadorNestedInput = {
    create?: XOR<EvaluacionesCreateWithoutEvaluadorInput, EvaluacionesUncheckedCreateWithoutEvaluadorInput> | EvaluacionesCreateWithoutEvaluadorInput[] | EvaluacionesUncheckedCreateWithoutEvaluadorInput[]
    connectOrCreate?: EvaluacionesCreateOrConnectWithoutEvaluadorInput | EvaluacionesCreateOrConnectWithoutEvaluadorInput[]
    upsert?: EvaluacionesUpsertWithWhereUniqueWithoutEvaluadorInput | EvaluacionesUpsertWithWhereUniqueWithoutEvaluadorInput[]
    createMany?: EvaluacionesCreateManyEvaluadorInputEnvelope
    set?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    disconnect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    delete?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    connect?: EvaluacionesWhereUniqueInput | EvaluacionesWhereUniqueInput[]
    update?: EvaluacionesUpdateWithWhereUniqueWithoutEvaluadorInput | EvaluacionesUpdateWithWhereUniqueWithoutEvaluadorInput[]
    updateMany?: EvaluacionesUpdateManyWithWhereWithoutEvaluadorInput | EvaluacionesUpdateManyWithWhereWithoutEvaluadorInput[]
    deleteMany?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
  }

  export type LogsUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<LogsCreateWithoutUsuarioInput, LogsUncheckedCreateWithoutUsuarioInput> | LogsCreateWithoutUsuarioInput[] | LogsUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: LogsCreateOrConnectWithoutUsuarioInput | LogsCreateOrConnectWithoutUsuarioInput[]
    upsert?: LogsUpsertWithWhereUniqueWithoutUsuarioInput | LogsUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: LogsCreateManyUsuarioInputEnvelope
    set?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    disconnect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    delete?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    connect?: LogsWhereUniqueInput | LogsWhereUniqueInput[]
    update?: LogsUpdateWithWhereUniqueWithoutUsuarioInput | LogsUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: LogsUpdateManyWithWhereWithoutUsuarioInput | LogsUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: LogsScalarWhereInput | LogsScalarWhereInput[]
  }

  export type ReportesUncheckedUpdateManyWithoutGeneradoPorNestedInput = {
    create?: XOR<ReportesCreateWithoutGeneradoPorInput, ReportesUncheckedCreateWithoutGeneradoPorInput> | ReportesCreateWithoutGeneradoPorInput[] | ReportesUncheckedCreateWithoutGeneradoPorInput[]
    connectOrCreate?: ReportesCreateOrConnectWithoutGeneradoPorInput | ReportesCreateOrConnectWithoutGeneradoPorInput[]
    upsert?: ReportesUpsertWithWhereUniqueWithoutGeneradoPorInput | ReportesUpsertWithWhereUniqueWithoutGeneradoPorInput[]
    createMany?: ReportesCreateManyGeneradoPorInputEnvelope
    set?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    disconnect?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    delete?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    connect?: ReportesWhereUniqueInput | ReportesWhereUniqueInput[]
    update?: ReportesUpdateWithWhereUniqueWithoutGeneradoPorInput | ReportesUpdateWithWhereUniqueWithoutGeneradoPorInput[]
    updateMany?: ReportesUpdateManyWithWhereWithoutGeneradoPorInput | ReportesUpdateManyWithWhereWithoutGeneradoPorInput[]
    deleteMany?: ReportesScalarWhereInput | ReportesScalarWhereInput[]
  }

  export type UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput> | UsuarioRolCreateWithoutUsuarioInput[] | UsuarioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: UsuarioRolCreateOrConnectWithoutUsuarioInput | UsuarioRolCreateOrConnectWithoutUsuarioInput[]
    upsert?: UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: UsuarioRolCreateManyUsuarioInputEnvelope
    set?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    disconnect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    delete?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    connect?: UsuarioRolWhereUniqueInput | UsuarioRolWhereUniqueInput[]
    update?: UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput | UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: UsuarioRolUpdateManyWithWhereWithoutUsuarioInput | UsuarioRolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumEstadoFaseFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoFase | EnumEstadoFaseFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoFaseFilter<$PrismaModel> | $Enums.EstadoFase
  }

  export type NestedEnumEstadoFaseWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoFase | EnumEstadoFaseFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoFase[] | ListEnumEstadoFaseFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoFaseWithAggregatesFilter<$PrismaModel> | $Enums.EstadoFase
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoFaseFilter<$PrismaModel>
    _max?: NestedEnumEstadoFaseFilter<$PrismaModel>
  }

  export type NestedEnumRolEquipoFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEquipo | EnumRolEquipoFieldRefInput<$PrismaModel>
    in?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEquipoFilter<$PrismaModel> | $Enums.RolEquipo
  }

  export type NestedEnumRolEquipoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RolEquipo | EnumRolEquipoFieldRefInput<$PrismaModel>
    in?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    notIn?: $Enums.RolEquipo[] | ListEnumRolEquipoFieldRefInput<$PrismaModel>
    not?: NestedEnumRolEquipoWithAggregatesFilter<$PrismaModel> | $Enums.RolEquipo
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolEquipoFilter<$PrismaModel>
    _max?: NestedEnumRolEquipoFilter<$PrismaModel>
  }

  export type NestedEnumTipoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoFilter<$PrismaModel> | $Enums.TipoDocumento
  }

  export type NestedEnumSexoNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableFilter<$PrismaModel> | $Enums.Sexo | null
  }

  export type NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.TipoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumTipoDocumentoFilter<$PrismaModel>
  }

  export type NestedEnumSexoNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Sexo | EnumSexoFieldRefInput<$PrismaModel> | null
    in?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Sexo[] | ListEnumSexoFieldRefInput<$PrismaModel> | null
    not?: NestedEnumSexoNullableWithAggregatesFilter<$PrismaModel> | $Enums.Sexo | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumSexoNullableFilter<$PrismaModel>
    _max?: NestedEnumSexoNullableFilter<$PrismaModel>
  }

  export type NestedEnumEstadoParticipacionFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoParticipacion | EnumEstadoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoParticipacionFilter<$PrismaModel> | $Enums.EstadoParticipacion
  }

  export type NestedEnumTipoParticipacionFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParticipacion | EnumTipoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParticipacionFilter<$PrismaModel> | $Enums.TipoParticipacion
  }

  export type NestedEnumEstadoParticipacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoParticipacion | EnumEstadoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoParticipacion[] | ListEnumEstadoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoParticipacionWithAggregatesFilter<$PrismaModel> | $Enums.EstadoParticipacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoParticipacionFilter<$PrismaModel>
    _max?: NestedEnumEstadoParticipacionFilter<$PrismaModel>
  }

  export type NestedEnumTipoParticipacionWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoParticipacion | EnumTipoParticipacionFieldRefInput<$PrismaModel>
    in?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoParticipacion[] | ListEnumTipoParticipacionFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoParticipacionWithAggregatesFilter<$PrismaModel> | $Enums.TipoParticipacion
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoParticipacionFilter<$PrismaModel>
    _max?: NestedEnumTipoParticipacionFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type ConfigMedallasCreateWithoutAreaInput = {
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
    nivel: NivelesCreateNestedOneWithoutConfigMedallasInput
  }

  export type ConfigMedallasUncheckedCreateWithoutAreaInput = {
    id?: number
    nivel_id: number
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
  }

  export type ConfigMedallasCreateOrConnectWithoutAreaInput = {
    where: ConfigMedallasWhereUniqueInput
    create: XOR<ConfigMedallasCreateWithoutAreaInput, ConfigMedallasUncheckedCreateWithoutAreaInput>
  }

  export type ConfigMedallasCreateManyAreaInputEnvelope = {
    data: ConfigMedallasCreateManyAreaInput | ConfigMedallasCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ParticipacionCreateWithoutAreaInput = {
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    olimpista: OlimpistasCreateNestedOneWithoutParticipacionInput
    nivel: NivelesCreateNestedOneWithoutParticipacionInput
    evaluaciones?: EvaluacionesCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionUncheckedCreateWithoutAreaInput = {
    id?: number
    olimpista_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionCreateOrConnectWithoutAreaInput = {
    where: ParticipacionWhereUniqueInput
    create: XOR<ParticipacionCreateWithoutAreaInput, ParticipacionUncheckedCreateWithoutAreaInput>
  }

  export type ParticipacionCreateManyAreaInputEnvelope = {
    data: ParticipacionCreateManyAreaInput | ParticipacionCreateManyAreaInput[]
    skipDuplicates?: boolean
  }

  export type ConfigMedallasUpsertWithWhereUniqueWithoutAreaInput = {
    where: ConfigMedallasWhereUniqueInput
    update: XOR<ConfigMedallasUpdateWithoutAreaInput, ConfigMedallasUncheckedUpdateWithoutAreaInput>
    create: XOR<ConfigMedallasCreateWithoutAreaInput, ConfigMedallasUncheckedCreateWithoutAreaInput>
  }

  export type ConfigMedallasUpdateWithWhereUniqueWithoutAreaInput = {
    where: ConfigMedallasWhereUniqueInput
    data: XOR<ConfigMedallasUpdateWithoutAreaInput, ConfigMedallasUncheckedUpdateWithoutAreaInput>
  }

  export type ConfigMedallasUpdateManyWithWhereWithoutAreaInput = {
    where: ConfigMedallasScalarWhereInput
    data: XOR<ConfigMedallasUpdateManyMutationInput, ConfigMedallasUncheckedUpdateManyWithoutAreaInput>
  }

  export type ConfigMedallasScalarWhereInput = {
    AND?: ConfigMedallasScalarWhereInput | ConfigMedallasScalarWhereInput[]
    OR?: ConfigMedallasScalarWhereInput[]
    NOT?: ConfigMedallasScalarWhereInput | ConfigMedallasScalarWhereInput[]
    id?: IntFilter<"ConfigMedallas"> | number
    area_id?: IntFilter<"ConfigMedallas"> | number
    nivel_id?: IntFilter<"ConfigMedallas"> | number
    oros?: IntFilter<"ConfigMedallas"> | number
    platas?: IntFilter<"ConfigMedallas"> | number
    bronces?: IntFilter<"ConfigMedallas"> | number
    menciones?: IntFilter<"ConfigMedallas"> | number
  }

  export type ParticipacionUpsertWithWhereUniqueWithoutAreaInput = {
    where: ParticipacionWhereUniqueInput
    update: XOR<ParticipacionUpdateWithoutAreaInput, ParticipacionUncheckedUpdateWithoutAreaInput>
    create: XOR<ParticipacionCreateWithoutAreaInput, ParticipacionUncheckedCreateWithoutAreaInput>
  }

  export type ParticipacionUpdateWithWhereUniqueWithoutAreaInput = {
    where: ParticipacionWhereUniqueInput
    data: XOR<ParticipacionUpdateWithoutAreaInput, ParticipacionUncheckedUpdateWithoutAreaInput>
  }

  export type ParticipacionUpdateManyWithWhereWithoutAreaInput = {
    where: ParticipacionScalarWhereInput
    data: XOR<ParticipacionUpdateManyMutationInput, ParticipacionUncheckedUpdateManyWithoutAreaInput>
  }

  export type ParticipacionScalarWhereInput = {
    AND?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
    OR?: ParticipacionScalarWhereInput[]
    NOT?: ParticipacionScalarWhereInput | ParticipacionScalarWhereInput[]
    id?: IntFilter<"Participacion"> | number
    olimpista_id?: IntFilter<"Participacion"> | number
    area_id?: IntFilter<"Participacion"> | number
    nivel_id?: IntFilter<"Participacion"> | number
    estado?: EnumEstadoParticipacionFilter<"Participacion"> | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFilter<"Participacion"> | $Enums.TipoParticipacion
  }

  export type AreasCreateWithoutConfig_medallasInput = {
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    participacion?: ParticipacionCreateNestedManyWithoutAreaInput
  }

  export type AreasUncheckedCreateWithoutConfig_medallasInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreasCreateOrConnectWithoutConfig_medallasInput = {
    where: AreasWhereUniqueInput
    create: XOR<AreasCreateWithoutConfig_medallasInput, AreasUncheckedCreateWithoutConfig_medallasInput>
  }

  export type NivelesCreateWithoutConfigMedallasInput = {
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    participacion?: ParticipacionCreateNestedManyWithoutNivelInput
  }

  export type NivelesUncheckedCreateWithoutConfigMedallasInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutNivelInput
  }

  export type NivelesCreateOrConnectWithoutConfigMedallasInput = {
    where: NivelesWhereUniqueInput
    create: XOR<NivelesCreateWithoutConfigMedallasInput, NivelesUncheckedCreateWithoutConfigMedallasInput>
  }

  export type AreasUpsertWithoutConfig_medallasInput = {
    update: XOR<AreasUpdateWithoutConfig_medallasInput, AreasUncheckedUpdateWithoutConfig_medallasInput>
    create: XOR<AreasCreateWithoutConfig_medallasInput, AreasUncheckedCreateWithoutConfig_medallasInput>
    where?: AreasWhereInput
  }

  export type AreasUpdateToOneWithWhereWithoutConfig_medallasInput = {
    where?: AreasWhereInput
    data: XOR<AreasUpdateWithoutConfig_medallasInput, AreasUncheckedUpdateWithoutConfig_medallasInput>
  }

  export type AreasUpdateWithoutConfig_medallasInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    participacion?: ParticipacionUpdateManyWithoutAreaNestedInput
  }

  export type AreasUncheckedUpdateWithoutConfig_medallasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    participacion?: ParticipacionUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type NivelesUpsertWithoutConfigMedallasInput = {
    update: XOR<NivelesUpdateWithoutConfigMedallasInput, NivelesUncheckedUpdateWithoutConfigMedallasInput>
    create: XOR<NivelesCreateWithoutConfigMedallasInput, NivelesUncheckedCreateWithoutConfigMedallasInput>
    where?: NivelesWhereInput
  }

  export type NivelesUpdateToOneWithWhereWithoutConfigMedallasInput = {
    where?: NivelesWhereInput
    data: XOR<NivelesUpdateWithoutConfigMedallasInput, NivelesUncheckedUpdateWithoutConfigMedallasInput>
  }

  export type NivelesUpdateWithoutConfigMedallasInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    participacion?: ParticipacionUpdateManyWithoutNivelNestedInput
  }

  export type NivelesUncheckedUpdateWithoutConfigMedallasInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    participacion?: ParticipacionUncheckedUpdateManyWithoutNivelNestedInput
  }

  export type ParticipacionCreateWithoutEvaluacionesInput = {
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    olimpista: OlimpistasCreateNestedOneWithoutParticipacionInput
    area: AreasCreateNestedOneWithoutParticipacionInput
    nivel: NivelesCreateNestedOneWithoutParticipacionInput
  }

  export type ParticipacionUncheckedCreateWithoutEvaluacionesInput = {
    id?: number
    olimpista_id: number
    area_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
  }

  export type ParticipacionCreateOrConnectWithoutEvaluacionesInput = {
    where: ParticipacionWhereUniqueInput
    create: XOR<ParticipacionCreateWithoutEvaluacionesInput, ParticipacionUncheckedCreateWithoutEvaluacionesInput>
  }

  export type UsuariosCreateWithoutEvaluacionesInput = {
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    logs?: LogsCreateNestedManyWithoutUsuarioInput
    reportes?: ReportesCreateNestedManyWithoutGeneradoPorInput
    usuario_rol?: UsuarioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosUncheckedCreateWithoutEvaluacionesInput = {
    id?: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    logs?: LogsUncheckedCreateNestedManyWithoutUsuarioInput
    reportes?: ReportesUncheckedCreateNestedManyWithoutGeneradoPorInput
    usuario_rol?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosCreateOrConnectWithoutEvaluacionesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutEvaluacionesInput, UsuariosUncheckedCreateWithoutEvaluacionesInput>
  }

  export type FasesCreateWithoutEvaluacionesInput = {
    nombre: string
    descripcion?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    estado?: $Enums.EstadoFase
  }

  export type FasesUncheckedCreateWithoutEvaluacionesInput = {
    id?: number
    nombre: string
    descripcion?: string | null
    inicio?: Date | string | null
    fin?: Date | string | null
    estado?: $Enums.EstadoFase
  }

  export type FasesCreateOrConnectWithoutEvaluacionesInput = {
    where: FasesWhereUniqueInput
    create: XOR<FasesCreateWithoutEvaluacionesInput, FasesUncheckedCreateWithoutEvaluacionesInput>
  }

  export type ParticipacionUpsertWithoutEvaluacionesInput = {
    update: XOR<ParticipacionUpdateWithoutEvaluacionesInput, ParticipacionUncheckedUpdateWithoutEvaluacionesInput>
    create: XOR<ParticipacionCreateWithoutEvaluacionesInput, ParticipacionUncheckedCreateWithoutEvaluacionesInput>
    where?: ParticipacionWhereInput
  }

  export type ParticipacionUpdateToOneWithWhereWithoutEvaluacionesInput = {
    where?: ParticipacionWhereInput
    data: XOR<ParticipacionUpdateWithoutEvaluacionesInput, ParticipacionUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type ParticipacionUpdateWithoutEvaluacionesInput = {
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    olimpista?: OlimpistasUpdateOneRequiredWithoutParticipacionNestedInput
    area?: AreasUpdateOneRequiredWithoutParticipacionNestedInput
    nivel?: NivelesUpdateOneRequiredWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateWithoutEvaluacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
  }

  export type UsuariosUpsertWithoutEvaluacionesInput = {
    update: XOR<UsuariosUpdateWithoutEvaluacionesInput, UsuariosUncheckedUpdateWithoutEvaluacionesInput>
    create: XOR<UsuariosCreateWithoutEvaluacionesInput, UsuariosUncheckedCreateWithoutEvaluacionesInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutEvaluacionesInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutEvaluacionesInput, UsuariosUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type UsuariosUpdateWithoutEvaluacionesInput = {
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogsUpdateManyWithoutUsuarioNestedInput
    reportes?: ReportesUpdateManyWithoutGeneradoPorNestedInput
    usuario_rol?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutEvaluacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    logs?: LogsUncheckedUpdateManyWithoutUsuarioNestedInput
    reportes?: ReportesUncheckedUpdateManyWithoutGeneradoPorNestedInput
    usuario_rol?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type FasesUpsertWithoutEvaluacionesInput = {
    update: XOR<FasesUpdateWithoutEvaluacionesInput, FasesUncheckedUpdateWithoutEvaluacionesInput>
    create: XOR<FasesCreateWithoutEvaluacionesInput, FasesUncheckedCreateWithoutEvaluacionesInput>
    where?: FasesWhereInput
  }

  export type FasesUpdateToOneWithWhereWithoutEvaluacionesInput = {
    where?: FasesWhereInput
    data: XOR<FasesUpdateWithoutEvaluacionesInput, FasesUncheckedUpdateWithoutEvaluacionesInput>
  }

  export type FasesUpdateWithoutEvaluacionesInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoFaseFieldUpdateOperationsInput | $Enums.EstadoFase
  }

  export type FasesUncheckedUpdateWithoutEvaluacionesInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    inicio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    fin?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    estado?: EnumEstadoFaseFieldUpdateOperationsInput | $Enums.EstadoFase
  }

  export type EvaluacionesCreateWithoutFaseInput = {
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
    participacion: ParticipacionCreateNestedOneWithoutEvaluacionesInput
    evaluador?: UsuariosCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionesUncheckedCreateWithoutFaseInput = {
    id?: number
    participacion_id: number
    evaluador_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesCreateOrConnectWithoutFaseInput = {
    where: EvaluacionesWhereUniqueInput
    create: XOR<EvaluacionesCreateWithoutFaseInput, EvaluacionesUncheckedCreateWithoutFaseInput>
  }

  export type EvaluacionesCreateManyFaseInputEnvelope = {
    data: EvaluacionesCreateManyFaseInput | EvaluacionesCreateManyFaseInput[]
    skipDuplicates?: boolean
  }

  export type EvaluacionesUpsertWithWhereUniqueWithoutFaseInput = {
    where: EvaluacionesWhereUniqueInput
    update: XOR<EvaluacionesUpdateWithoutFaseInput, EvaluacionesUncheckedUpdateWithoutFaseInput>
    create: XOR<EvaluacionesCreateWithoutFaseInput, EvaluacionesUncheckedCreateWithoutFaseInput>
  }

  export type EvaluacionesUpdateWithWhereUniqueWithoutFaseInput = {
    where: EvaluacionesWhereUniqueInput
    data: XOR<EvaluacionesUpdateWithoutFaseInput, EvaluacionesUncheckedUpdateWithoutFaseInput>
  }

  export type EvaluacionesUpdateManyWithWhereWithoutFaseInput = {
    where: EvaluacionesScalarWhereInput
    data: XOR<EvaluacionesUpdateManyMutationInput, EvaluacionesUncheckedUpdateManyWithoutFaseInput>
  }

  export type EvaluacionesScalarWhereInput = {
    AND?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
    OR?: EvaluacionesScalarWhereInput[]
    NOT?: EvaluacionesScalarWhereInput | EvaluacionesScalarWhereInput[]
    id?: IntFilter<"Evaluaciones"> | number
    participacion_id?: IntFilter<"Evaluaciones"> | number
    evaluador_id?: IntNullableFilter<"Evaluaciones"> | number | null
    fase_id?: IntNullableFilter<"Evaluaciones"> | number | null
    nota?: DecimalFilter<"Evaluaciones"> | Decimal | DecimalJsLike | number | string
    comentario?: StringNullableFilter<"Evaluaciones"> | string | null
    creado_en?: DateTimeFilter<"Evaluaciones"> | Date | string
    validado?: BoolNullableFilter<"Evaluaciones"> | boolean | null
    ultima_modificacion?: DateTimeNullableFilter<"Evaluaciones"> | Date | string | null
  }

  export type UsuariosCreateWithoutLogsInput = {
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesCreateNestedManyWithoutEvaluadorInput
    reportes?: ReportesCreateNestedManyWithoutGeneradoPorInput
    usuario_rol?: UsuarioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosUncheckedCreateWithoutLogsInput = {
    id?: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutEvaluadorInput
    reportes?: ReportesUncheckedCreateNestedManyWithoutGeneradoPorInput
    usuario_rol?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosCreateOrConnectWithoutLogsInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutLogsInput, UsuariosUncheckedCreateWithoutLogsInput>
  }

  export type UsuariosUpsertWithoutLogsInput = {
    update: XOR<UsuariosUpdateWithoutLogsInput, UsuariosUncheckedUpdateWithoutLogsInput>
    create: XOR<UsuariosCreateWithoutLogsInput, UsuariosUncheckedCreateWithoutLogsInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutLogsInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutLogsInput, UsuariosUncheckedUpdateWithoutLogsInput>
  }

  export type UsuariosUpdateWithoutLogsInput = {
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUpdateManyWithoutEvaluadorNestedInput
    reportes?: ReportesUpdateManyWithoutGeneradoPorNestedInput
    usuario_rol?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutEvaluadorNestedInput
    reportes?: ReportesUncheckedUpdateManyWithoutGeneradoPorNestedInput
    usuario_rol?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type OlimpistasCreateWithoutMiembros_equipoInput = {
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor?: TutoresCreateNestedOneWithoutOlimpistasInput
    participacion?: ParticipacionCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasUncheckedCreateWithoutMiembros_equipoInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor_id?: number | null
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasCreateOrConnectWithoutMiembros_equipoInput = {
    where: OlimpistasWhereUniqueInput
    create: XOR<OlimpistasCreateWithoutMiembros_equipoInput, OlimpistasUncheckedCreateWithoutMiembros_equipoInput>
  }

  export type OlimpistasUpsertWithoutMiembros_equipoInput = {
    update: XOR<OlimpistasUpdateWithoutMiembros_equipoInput, OlimpistasUncheckedUpdateWithoutMiembros_equipoInput>
    create: XOR<OlimpistasCreateWithoutMiembros_equipoInput, OlimpistasUncheckedCreateWithoutMiembros_equipoInput>
    where?: OlimpistasWhereInput
  }

  export type OlimpistasUpdateToOneWithWhereWithoutMiembros_equipoInput = {
    where?: OlimpistasWhereInput
    data: XOR<OlimpistasUpdateWithoutMiembros_equipoInput, OlimpistasUncheckedUpdateWithoutMiembros_equipoInput>
  }

  export type OlimpistasUpdateWithoutMiembros_equipoInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutoresUpdateOneWithoutOlimpistasNestedInput
    participacion?: ParticipacionUpdateManyWithoutOlimpistaNestedInput
  }

  export type OlimpistasUncheckedUpdateWithoutMiembros_equipoInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor_id?: NullableIntFieldUpdateOperationsInput | number | null
    participacion?: ParticipacionUncheckedUpdateManyWithoutOlimpistaNestedInput
  }

  export type ParticipacionCreateWithoutNivelInput = {
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    olimpista: OlimpistasCreateNestedOneWithoutParticipacionInput
    area: AreasCreateNestedOneWithoutParticipacionInput
    evaluaciones?: EvaluacionesCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionUncheckedCreateWithoutNivelInput = {
    id?: number
    olimpista_id: number
    area_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionCreateOrConnectWithoutNivelInput = {
    where: ParticipacionWhereUniqueInput
    create: XOR<ParticipacionCreateWithoutNivelInput, ParticipacionUncheckedCreateWithoutNivelInput>
  }

  export type ParticipacionCreateManyNivelInputEnvelope = {
    data: ParticipacionCreateManyNivelInput | ParticipacionCreateManyNivelInput[]
    skipDuplicates?: boolean
  }

  export type ConfigMedallasCreateWithoutNivelInput = {
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
    area: AreasCreateNestedOneWithoutConfig_medallasInput
  }

  export type ConfigMedallasUncheckedCreateWithoutNivelInput = {
    id?: number
    area_id: number
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
  }

  export type ConfigMedallasCreateOrConnectWithoutNivelInput = {
    where: ConfigMedallasWhereUniqueInput
    create: XOR<ConfigMedallasCreateWithoutNivelInput, ConfigMedallasUncheckedCreateWithoutNivelInput>
  }

  export type ConfigMedallasCreateManyNivelInputEnvelope = {
    data: ConfigMedallasCreateManyNivelInput | ConfigMedallasCreateManyNivelInput[]
    skipDuplicates?: boolean
  }

  export type ParticipacionUpsertWithWhereUniqueWithoutNivelInput = {
    where: ParticipacionWhereUniqueInput
    update: XOR<ParticipacionUpdateWithoutNivelInput, ParticipacionUncheckedUpdateWithoutNivelInput>
    create: XOR<ParticipacionCreateWithoutNivelInput, ParticipacionUncheckedCreateWithoutNivelInput>
  }

  export type ParticipacionUpdateWithWhereUniqueWithoutNivelInput = {
    where: ParticipacionWhereUniqueInput
    data: XOR<ParticipacionUpdateWithoutNivelInput, ParticipacionUncheckedUpdateWithoutNivelInput>
  }

  export type ParticipacionUpdateManyWithWhereWithoutNivelInput = {
    where: ParticipacionScalarWhereInput
    data: XOR<ParticipacionUpdateManyMutationInput, ParticipacionUncheckedUpdateManyWithoutNivelInput>
  }

  export type ConfigMedallasUpsertWithWhereUniqueWithoutNivelInput = {
    where: ConfigMedallasWhereUniqueInput
    update: XOR<ConfigMedallasUpdateWithoutNivelInput, ConfigMedallasUncheckedUpdateWithoutNivelInput>
    create: XOR<ConfigMedallasCreateWithoutNivelInput, ConfigMedallasUncheckedCreateWithoutNivelInput>
  }

  export type ConfigMedallasUpdateWithWhereUniqueWithoutNivelInput = {
    where: ConfigMedallasWhereUniqueInput
    data: XOR<ConfigMedallasUpdateWithoutNivelInput, ConfigMedallasUncheckedUpdateWithoutNivelInput>
  }

  export type ConfigMedallasUpdateManyWithWhereWithoutNivelInput = {
    where: ConfigMedallasScalarWhereInput
    data: XOR<ConfigMedallasUpdateManyMutationInput, ConfigMedallasUncheckedUpdateManyWithoutNivelInput>
  }

  export type TutoresCreateWithoutOlimpistasInput = {
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    telefono?: string | null
    correo?: string | null
    unidad_educativa: string
    profesion?: string | null
    creado_en?: Date | string
  }

  export type TutoresUncheckedCreateWithoutOlimpistasInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    telefono?: string | null
    correo?: string | null
    unidad_educativa: string
    profesion?: string | null
    creado_en?: Date | string
  }

  export type TutoresCreateOrConnectWithoutOlimpistasInput = {
    where: TutoresWhereUniqueInput
    create: XOR<TutoresCreateWithoutOlimpistasInput, TutoresUncheckedCreateWithoutOlimpistasInput>
  }

  export type ParticipacionCreateWithoutOlimpistaInput = {
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    area: AreasCreateNestedOneWithoutParticipacionInput
    nivel: NivelesCreateNestedOneWithoutParticipacionInput
    evaluaciones?: EvaluacionesCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionUncheckedCreateWithoutOlimpistaInput = {
    id?: number
    area_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutParticipacionInput
  }

  export type ParticipacionCreateOrConnectWithoutOlimpistaInput = {
    where: ParticipacionWhereUniqueInput
    create: XOR<ParticipacionCreateWithoutOlimpistaInput, ParticipacionUncheckedCreateWithoutOlimpistaInput>
  }

  export type ParticipacionCreateManyOlimpistaInputEnvelope = {
    data: ParticipacionCreateManyOlimpistaInput | ParticipacionCreateManyOlimpistaInput[]
    skipDuplicates?: boolean
  }

  export type MiembrosEquipoCreateWithoutOlimpistaInput = {
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
  }

  export type MiembrosEquipoUncheckedCreateWithoutOlimpistaInput = {
    id?: number
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
  }

  export type MiembrosEquipoCreateOrConnectWithoutOlimpistaInput = {
    where: MiembrosEquipoWhereUniqueInput
    create: XOR<MiembrosEquipoCreateWithoutOlimpistaInput, MiembrosEquipoUncheckedCreateWithoutOlimpistaInput>
  }

  export type MiembrosEquipoCreateManyOlimpistaInputEnvelope = {
    data: MiembrosEquipoCreateManyOlimpistaInput | MiembrosEquipoCreateManyOlimpistaInput[]
    skipDuplicates?: boolean
  }

  export type TutoresUpsertWithoutOlimpistasInput = {
    update: XOR<TutoresUpdateWithoutOlimpistasInput, TutoresUncheckedUpdateWithoutOlimpistasInput>
    create: XOR<TutoresCreateWithoutOlimpistasInput, TutoresUncheckedCreateWithoutOlimpistasInput>
    where?: TutoresWhereInput
  }

  export type TutoresUpdateToOneWithWhereWithoutOlimpistasInput = {
    where?: TutoresWhereInput
    data: XOR<TutoresUpdateWithoutOlimpistasInput, TutoresUncheckedUpdateWithoutOlimpistasInput>
  }

  export type TutoresUpdateWithoutOlimpistasInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TutoresUncheckedUpdateWithoutOlimpistasInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    correo?: NullableStringFieldUpdateOperationsInput | string | null
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ParticipacionUpsertWithWhereUniqueWithoutOlimpistaInput = {
    where: ParticipacionWhereUniqueInput
    update: XOR<ParticipacionUpdateWithoutOlimpistaInput, ParticipacionUncheckedUpdateWithoutOlimpistaInput>
    create: XOR<ParticipacionCreateWithoutOlimpistaInput, ParticipacionUncheckedCreateWithoutOlimpistaInput>
  }

  export type ParticipacionUpdateWithWhereUniqueWithoutOlimpistaInput = {
    where: ParticipacionWhereUniqueInput
    data: XOR<ParticipacionUpdateWithoutOlimpistaInput, ParticipacionUncheckedUpdateWithoutOlimpistaInput>
  }

  export type ParticipacionUpdateManyWithWhereWithoutOlimpistaInput = {
    where: ParticipacionScalarWhereInput
    data: XOR<ParticipacionUpdateManyMutationInput, ParticipacionUncheckedUpdateManyWithoutOlimpistaInput>
  }

  export type MiembrosEquipoUpsertWithWhereUniqueWithoutOlimpistaInput = {
    where: MiembrosEquipoWhereUniqueInput
    update: XOR<MiembrosEquipoUpdateWithoutOlimpistaInput, MiembrosEquipoUncheckedUpdateWithoutOlimpistaInput>
    create: XOR<MiembrosEquipoCreateWithoutOlimpistaInput, MiembrosEquipoUncheckedCreateWithoutOlimpistaInput>
  }

  export type MiembrosEquipoUpdateWithWhereUniqueWithoutOlimpistaInput = {
    where: MiembrosEquipoWhereUniqueInput
    data: XOR<MiembrosEquipoUpdateWithoutOlimpistaInput, MiembrosEquipoUncheckedUpdateWithoutOlimpistaInput>
  }

  export type MiembrosEquipoUpdateManyWithWhereWithoutOlimpistaInput = {
    where: MiembrosEquipoScalarWhereInput
    data: XOR<MiembrosEquipoUpdateManyMutationInput, MiembrosEquipoUncheckedUpdateManyWithoutOlimpistaInput>
  }

  export type MiembrosEquipoScalarWhereInput = {
    AND?: MiembrosEquipoScalarWhereInput | MiembrosEquipoScalarWhereInput[]
    OR?: MiembrosEquipoScalarWhereInput[]
    NOT?: MiembrosEquipoScalarWhereInput | MiembrosEquipoScalarWhereInput[]
    id?: IntFilter<"MiembrosEquipo"> | number
    olimpista_id?: IntFilter<"MiembrosEquipo"> | number
    nombre_equipo?: StringFilter<"MiembrosEquipo"> | string
    rol_en_equipo?: EnumRolEquipoFilter<"MiembrosEquipo"> | $Enums.RolEquipo
  }

  export type OlimpistasCreateWithoutParticipacionInput = {
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor?: TutoresCreateNestedOneWithoutOlimpistasInput
    miembros_equipo?: MiembrosEquipoCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasUncheckedCreateWithoutParticipacionInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    tutor_id?: number | null
    miembros_equipo?: MiembrosEquipoUncheckedCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasCreateOrConnectWithoutParticipacionInput = {
    where: OlimpistasWhereUniqueInput
    create: XOR<OlimpistasCreateWithoutParticipacionInput, OlimpistasUncheckedCreateWithoutParticipacionInput>
  }

  export type AreasCreateWithoutParticipacionInput = {
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    config_medallas?: ConfigMedallasCreateNestedManyWithoutAreaInput
  }

  export type AreasUncheckedCreateWithoutParticipacionInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    config_medallas?: ConfigMedallasUncheckedCreateNestedManyWithoutAreaInput
  }

  export type AreasCreateOrConnectWithoutParticipacionInput = {
    where: AreasWhereUniqueInput
    create: XOR<AreasCreateWithoutParticipacionInput, AreasUncheckedCreateWithoutParticipacionInput>
  }

  export type NivelesCreateWithoutParticipacionInput = {
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    ConfigMedallas?: ConfigMedallasCreateNestedManyWithoutNivelInput
  }

  export type NivelesUncheckedCreateWithoutParticipacionInput = {
    id?: number
    codigo?: string | null
    nombre: string
    descripcion?: string | null
    estado?: boolean
    ConfigMedallas?: ConfigMedallasUncheckedCreateNestedManyWithoutNivelInput
  }

  export type NivelesCreateOrConnectWithoutParticipacionInput = {
    where: NivelesWhereUniqueInput
    create: XOR<NivelesCreateWithoutParticipacionInput, NivelesUncheckedCreateWithoutParticipacionInput>
  }

  export type EvaluacionesCreateWithoutParticipacionInput = {
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
    evaluador?: UsuariosCreateNestedOneWithoutEvaluacionesInput
    fase?: FasesCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionesUncheckedCreateWithoutParticipacionInput = {
    id?: number
    evaluador_id?: number | null
    fase_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesCreateOrConnectWithoutParticipacionInput = {
    where: EvaluacionesWhereUniqueInput
    create: XOR<EvaluacionesCreateWithoutParticipacionInput, EvaluacionesUncheckedCreateWithoutParticipacionInput>
  }

  export type EvaluacionesCreateManyParticipacionInputEnvelope = {
    data: EvaluacionesCreateManyParticipacionInput | EvaluacionesCreateManyParticipacionInput[]
    skipDuplicates?: boolean
  }

  export type OlimpistasUpsertWithoutParticipacionInput = {
    update: XOR<OlimpistasUpdateWithoutParticipacionInput, OlimpistasUncheckedUpdateWithoutParticipacionInput>
    create: XOR<OlimpistasCreateWithoutParticipacionInput, OlimpistasUncheckedCreateWithoutParticipacionInput>
    where?: OlimpistasWhereInput
  }

  export type OlimpistasUpdateToOneWithWhereWithoutParticipacionInput = {
    where?: OlimpistasWhereInput
    data: XOR<OlimpistasUpdateWithoutParticipacionInput, OlimpistasUncheckedUpdateWithoutParticipacionInput>
  }

  export type OlimpistasUpdateWithoutParticipacionInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor?: TutoresUpdateOneWithoutOlimpistasNestedInput
    miembros_equipo?: MiembrosEquipoUpdateManyWithoutOlimpistaNestedInput
  }

  export type OlimpistasUncheckedUpdateWithoutParticipacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    tutor_id?: NullableIntFieldUpdateOperationsInput | number | null
    miembros_equipo?: MiembrosEquipoUncheckedUpdateManyWithoutOlimpistaNestedInput
  }

  export type AreasUpsertWithoutParticipacionInput = {
    update: XOR<AreasUpdateWithoutParticipacionInput, AreasUncheckedUpdateWithoutParticipacionInput>
    create: XOR<AreasCreateWithoutParticipacionInput, AreasUncheckedCreateWithoutParticipacionInput>
    where?: AreasWhereInput
  }

  export type AreasUpdateToOneWithWhereWithoutParticipacionInput = {
    where?: AreasWhereInput
    data: XOR<AreasUpdateWithoutParticipacionInput, AreasUncheckedUpdateWithoutParticipacionInput>
  }

  export type AreasUpdateWithoutParticipacionInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    config_medallas?: ConfigMedallasUpdateManyWithoutAreaNestedInput
  }

  export type AreasUncheckedUpdateWithoutParticipacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    config_medallas?: ConfigMedallasUncheckedUpdateManyWithoutAreaNestedInput
  }

  export type NivelesUpsertWithoutParticipacionInput = {
    update: XOR<NivelesUpdateWithoutParticipacionInput, NivelesUncheckedUpdateWithoutParticipacionInput>
    create: XOR<NivelesCreateWithoutParticipacionInput, NivelesUncheckedCreateWithoutParticipacionInput>
    where?: NivelesWhereInput
  }

  export type NivelesUpdateToOneWithWhereWithoutParticipacionInput = {
    where?: NivelesWhereInput
    data: XOR<NivelesUpdateWithoutParticipacionInput, NivelesUncheckedUpdateWithoutParticipacionInput>
  }

  export type NivelesUpdateWithoutParticipacionInput = {
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    ConfigMedallas?: ConfigMedallasUpdateManyWithoutNivelNestedInput
  }

  export type NivelesUncheckedUpdateWithoutParticipacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    codigo?: NullableStringFieldUpdateOperationsInput | string | null
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    ConfigMedallas?: ConfigMedallasUncheckedUpdateManyWithoutNivelNestedInput
  }

  export type EvaluacionesUpsertWithWhereUniqueWithoutParticipacionInput = {
    where: EvaluacionesWhereUniqueInput
    update: XOR<EvaluacionesUpdateWithoutParticipacionInput, EvaluacionesUncheckedUpdateWithoutParticipacionInput>
    create: XOR<EvaluacionesCreateWithoutParticipacionInput, EvaluacionesUncheckedCreateWithoutParticipacionInput>
  }

  export type EvaluacionesUpdateWithWhereUniqueWithoutParticipacionInput = {
    where: EvaluacionesWhereUniqueInput
    data: XOR<EvaluacionesUpdateWithoutParticipacionInput, EvaluacionesUncheckedUpdateWithoutParticipacionInput>
  }

  export type EvaluacionesUpdateManyWithWhereWithoutParticipacionInput = {
    where: EvaluacionesScalarWhereInput
    data: XOR<EvaluacionesUpdateManyMutationInput, EvaluacionesUncheckedUpdateManyWithoutParticipacionInput>
  }

  export type UsuariosCreateWithoutReportesInput = {
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesCreateNestedManyWithoutEvaluadorInput
    logs?: LogsCreateNestedManyWithoutUsuarioInput
    usuario_rol?: UsuarioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosUncheckedCreateWithoutReportesInput = {
    id?: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutEvaluadorInput
    logs?: LogsUncheckedCreateNestedManyWithoutUsuarioInput
    usuario_rol?: UsuarioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuariosCreateOrConnectWithoutReportesInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutReportesInput, UsuariosUncheckedCreateWithoutReportesInput>
  }

  export type UsuariosUpsertWithoutReportesInput = {
    update: XOR<UsuariosUpdateWithoutReportesInput, UsuariosUncheckedUpdateWithoutReportesInput>
    create: XOR<UsuariosCreateWithoutReportesInput, UsuariosUncheckedCreateWithoutReportesInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutReportesInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutReportesInput, UsuariosUncheckedUpdateWithoutReportesInput>
  }

  export type UsuariosUpdateWithoutReportesInput = {
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUpdateManyWithoutEvaluadorNestedInput
    logs?: LogsUpdateManyWithoutUsuarioNestedInput
    usuario_rol?: UsuarioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutReportesInput = {
    id?: IntFieldUpdateOperationsInput | number
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutEvaluadorNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUsuarioNestedInput
    usuario_rol?: UsuarioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioRolCreateWithoutRolInput = {
    usuario?: UsuariosCreateNestedOneWithoutUsuario_rolInput
  }

  export type UsuarioRolUncheckedCreateWithoutRolInput = {
    id?: number
    usuario_id?: number | null
  }

  export type UsuarioRolCreateOrConnectWithoutRolInput = {
    where: UsuarioRolWhereUniqueInput
    create: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput>
  }

  export type UsuarioRolCreateManyRolInputEnvelope = {
    data: UsuarioRolCreateManyRolInput | UsuarioRolCreateManyRolInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioRolUpsertWithWhereUniqueWithoutRolInput = {
    where: UsuarioRolWhereUniqueInput
    update: XOR<UsuarioRolUpdateWithoutRolInput, UsuarioRolUncheckedUpdateWithoutRolInput>
    create: XOR<UsuarioRolCreateWithoutRolInput, UsuarioRolUncheckedCreateWithoutRolInput>
  }

  export type UsuarioRolUpdateWithWhereUniqueWithoutRolInput = {
    where: UsuarioRolWhereUniqueInput
    data: XOR<UsuarioRolUpdateWithoutRolInput, UsuarioRolUncheckedUpdateWithoutRolInput>
  }

  export type UsuarioRolUpdateManyWithWhereWithoutRolInput = {
    where: UsuarioRolScalarWhereInput
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyWithoutRolInput>
  }

  export type UsuarioRolScalarWhereInput = {
    AND?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
    OR?: UsuarioRolScalarWhereInput[]
    NOT?: UsuarioRolScalarWhereInput | UsuarioRolScalarWhereInput[]
    id?: IntFilter<"UsuarioRol"> | number
    usuario_id?: IntNullableFilter<"UsuarioRol"> | number | null
    rol_id?: IntNullableFilter<"UsuarioRol"> | number | null
  }

  export type OlimpistasCreateWithoutTutorInput = {
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    participacion?: ParticipacionCreateNestedManyWithoutOlimpistaInput
    miembros_equipo?: MiembrosEquipoCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasUncheckedCreateWithoutTutorInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
    participacion?: ParticipacionUncheckedCreateNestedManyWithoutOlimpistaInput
    miembros_equipo?: MiembrosEquipoUncheckedCreateNestedManyWithoutOlimpistaInput
  }

  export type OlimpistasCreateOrConnectWithoutTutorInput = {
    where: OlimpistasWhereUniqueInput
    create: XOR<OlimpistasCreateWithoutTutorInput, OlimpistasUncheckedCreateWithoutTutorInput>
  }

  export type OlimpistasCreateManyTutorInputEnvelope = {
    data: OlimpistasCreateManyTutorInput | OlimpistasCreateManyTutorInput[]
    skipDuplicates?: boolean
  }

  export type OlimpistasUpsertWithWhereUniqueWithoutTutorInput = {
    where: OlimpistasWhereUniqueInput
    update: XOR<OlimpistasUpdateWithoutTutorInput, OlimpistasUncheckedUpdateWithoutTutorInput>
    create: XOR<OlimpistasCreateWithoutTutorInput, OlimpistasUncheckedCreateWithoutTutorInput>
  }

  export type OlimpistasUpdateWithWhereUniqueWithoutTutorInput = {
    where: OlimpistasWhereUniqueInput
    data: XOR<OlimpistasUpdateWithoutTutorInput, OlimpistasUncheckedUpdateWithoutTutorInput>
  }

  export type OlimpistasUpdateManyWithWhereWithoutTutorInput = {
    where: OlimpistasScalarWhereInput
    data: XOR<OlimpistasUpdateManyMutationInput, OlimpistasUncheckedUpdateManyWithoutTutorInput>
  }

  export type OlimpistasScalarWhereInput = {
    AND?: OlimpistasScalarWhereInput | OlimpistasScalarWhereInput[]
    OR?: OlimpistasScalarWhereInput[]
    NOT?: OlimpistasScalarWhereInput | OlimpistasScalarWhereInput[]
    id?: IntFilter<"Olimpistas"> | number
    nombre?: StringFilter<"Olimpistas"> | string
    ap_paterno?: StringFilter<"Olimpistas"> | string
    ap_materno?: StringNullableFilter<"Olimpistas"> | string | null
    tipo_documento?: EnumTipoDocumentoFilter<"Olimpistas"> | $Enums.TipoDocumento
    numero_documento?: StringFilter<"Olimpistas"> | string
    unidad_educativa?: StringFilter<"Olimpistas"> | string
    departamento?: StringFilter<"Olimpistas"> | string
    grado?: StringNullableFilter<"Olimpistas"> | string | null
    fecha_nacimiento?: DateTimeNullableFilter<"Olimpistas"> | Date | string | null
    sexo?: EnumSexoNullableFilter<"Olimpistas"> | $Enums.Sexo | null
    activo?: BoolFilter<"Olimpistas"> | boolean
    creado_en?: DateTimeFilter<"Olimpistas"> | Date | string
    tutor_id?: IntNullableFilter<"Olimpistas"> | number | null
  }

  export type UsuariosCreateWithoutUsuario_rolInput = {
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesCreateNestedManyWithoutEvaluadorInput
    logs?: LogsCreateNestedManyWithoutUsuarioInput
    reportes?: ReportesCreateNestedManyWithoutGeneradoPorInput
  }

  export type UsuariosUncheckedCreateWithoutUsuario_rolInput = {
    id?: number
    contrasena_hash: string
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    correo: string
    telefono?: string | null
    cargo?: string | null
    profesion?: string | null
    institucion?: string | null
    estado?: boolean
    creado_en?: Date | string
    actualizado_en?: Date | string | null
    evaluaciones?: EvaluacionesUncheckedCreateNestedManyWithoutEvaluadorInput
    logs?: LogsUncheckedCreateNestedManyWithoutUsuarioInput
    reportes?: ReportesUncheckedCreateNestedManyWithoutGeneradoPorInput
  }

  export type UsuariosCreateOrConnectWithoutUsuario_rolInput = {
    where: UsuariosWhereUniqueInput
    create: XOR<UsuariosCreateWithoutUsuario_rolInput, UsuariosUncheckedCreateWithoutUsuario_rolInput>
  }

  export type RolesCreateWithoutUsuario_rolInput = {
    nombre: string
    descripcion?: string | null
  }

  export type RolesUncheckedCreateWithoutUsuario_rolInput = {
    id?: number
    nombre: string
    descripcion?: string | null
  }

  export type RolesCreateOrConnectWithoutUsuario_rolInput = {
    where: RolesWhereUniqueInput
    create: XOR<RolesCreateWithoutUsuario_rolInput, RolesUncheckedCreateWithoutUsuario_rolInput>
  }

  export type UsuariosUpsertWithoutUsuario_rolInput = {
    update: XOR<UsuariosUpdateWithoutUsuario_rolInput, UsuariosUncheckedUpdateWithoutUsuario_rolInput>
    create: XOR<UsuariosCreateWithoutUsuario_rolInput, UsuariosUncheckedCreateWithoutUsuario_rolInput>
    where?: UsuariosWhereInput
  }

  export type UsuariosUpdateToOneWithWhereWithoutUsuario_rolInput = {
    where?: UsuariosWhereInput
    data: XOR<UsuariosUpdateWithoutUsuario_rolInput, UsuariosUncheckedUpdateWithoutUsuario_rolInput>
  }

  export type UsuariosUpdateWithoutUsuario_rolInput = {
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUpdateManyWithoutEvaluadorNestedInput
    logs?: LogsUpdateManyWithoutUsuarioNestedInput
    reportes?: ReportesUpdateManyWithoutGeneradoPorNestedInput
  }

  export type UsuariosUncheckedUpdateWithoutUsuario_rolInput = {
    id?: IntFieldUpdateOperationsInput | number
    contrasena_hash?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    correo?: StringFieldUpdateOperationsInput | string
    telefono?: NullableStringFieldUpdateOperationsInput | string | null
    cargo?: NullableStringFieldUpdateOperationsInput | string | null
    profesion?: NullableStringFieldUpdateOperationsInput | string | null
    institucion?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutEvaluadorNestedInput
    logs?: LogsUncheckedUpdateManyWithoutUsuarioNestedInput
    reportes?: ReportesUncheckedUpdateManyWithoutGeneradoPorNestedInput
  }

  export type RolesUpsertWithoutUsuario_rolInput = {
    update: XOR<RolesUpdateWithoutUsuario_rolInput, RolesUncheckedUpdateWithoutUsuario_rolInput>
    create: XOR<RolesCreateWithoutUsuario_rolInput, RolesUncheckedCreateWithoutUsuario_rolInput>
    where?: RolesWhereInput
  }

  export type RolesUpdateToOneWithWhereWithoutUsuario_rolInput = {
    where?: RolesWhereInput
    data: XOR<RolesUpdateWithoutUsuario_rolInput, RolesUncheckedUpdateWithoutUsuario_rolInput>
  }

  export type RolesUpdateWithoutUsuario_rolInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RolesUncheckedUpdateWithoutUsuario_rolInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EvaluacionesCreateWithoutEvaluadorInput = {
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
    participacion: ParticipacionCreateNestedOneWithoutEvaluacionesInput
    fase?: FasesCreateNestedOneWithoutEvaluacionesInput
  }

  export type EvaluacionesUncheckedCreateWithoutEvaluadorInput = {
    id?: number
    participacion_id: number
    fase_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesCreateOrConnectWithoutEvaluadorInput = {
    where: EvaluacionesWhereUniqueInput
    create: XOR<EvaluacionesCreateWithoutEvaluadorInput, EvaluacionesUncheckedCreateWithoutEvaluadorInput>
  }

  export type EvaluacionesCreateManyEvaluadorInputEnvelope = {
    data: EvaluacionesCreateManyEvaluadorInput | EvaluacionesCreateManyEvaluadorInput[]
    skipDuplicates?: boolean
  }

  export type LogsCreateWithoutUsuarioInput = {
    entidad: string
    entidad_id?: number | null
    campo?: string | null
    valor_anterior?: string | null
    valor_nuevo?: string | null
    fecha_cambio?: Date | string | null
    motivo?: string | null
  }

  export type LogsUncheckedCreateWithoutUsuarioInput = {
    id?: number
    entidad: string
    entidad_id?: number | null
    campo?: string | null
    valor_anterior?: string | null
    valor_nuevo?: string | null
    fecha_cambio?: Date | string | null
    motivo?: string | null
  }

  export type LogsCreateOrConnectWithoutUsuarioInput = {
    where: LogsWhereUniqueInput
    create: XOR<LogsCreateWithoutUsuarioInput, LogsUncheckedCreateWithoutUsuarioInput>
  }

  export type LogsCreateManyUsuarioInputEnvelope = {
    data: LogsCreateManyUsuarioInput | LogsCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ReportesCreateWithoutGeneradoPorInput = {
    tipo: string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: string | null
    generado_en?: Date | string | null
  }

  export type ReportesUncheckedCreateWithoutGeneradoPorInput = {
    id?: number
    tipo: string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: string | null
    generado_en?: Date | string | null
  }

  export type ReportesCreateOrConnectWithoutGeneradoPorInput = {
    where: ReportesWhereUniqueInput
    create: XOR<ReportesCreateWithoutGeneradoPorInput, ReportesUncheckedCreateWithoutGeneradoPorInput>
  }

  export type ReportesCreateManyGeneradoPorInputEnvelope = {
    data: ReportesCreateManyGeneradoPorInput | ReportesCreateManyGeneradoPorInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioRolCreateWithoutUsuarioInput = {
    rol?: RolesCreateNestedOneWithoutUsuario_rolInput
  }

  export type UsuarioRolUncheckedCreateWithoutUsuarioInput = {
    id?: number
    rol_id?: number | null
  }

  export type UsuarioRolCreateOrConnectWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput
    create: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuarioRolCreateManyUsuarioInputEnvelope = {
    data: UsuarioRolCreateManyUsuarioInput | UsuarioRolCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type EvaluacionesUpsertWithWhereUniqueWithoutEvaluadorInput = {
    where: EvaluacionesWhereUniqueInput
    update: XOR<EvaluacionesUpdateWithoutEvaluadorInput, EvaluacionesUncheckedUpdateWithoutEvaluadorInput>
    create: XOR<EvaluacionesCreateWithoutEvaluadorInput, EvaluacionesUncheckedCreateWithoutEvaluadorInput>
  }

  export type EvaluacionesUpdateWithWhereUniqueWithoutEvaluadorInput = {
    where: EvaluacionesWhereUniqueInput
    data: XOR<EvaluacionesUpdateWithoutEvaluadorInput, EvaluacionesUncheckedUpdateWithoutEvaluadorInput>
  }

  export type EvaluacionesUpdateManyWithWhereWithoutEvaluadorInput = {
    where: EvaluacionesScalarWhereInput
    data: XOR<EvaluacionesUpdateManyMutationInput, EvaluacionesUncheckedUpdateManyWithoutEvaluadorInput>
  }

  export type LogsUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: LogsWhereUniqueInput
    update: XOR<LogsUpdateWithoutUsuarioInput, LogsUncheckedUpdateWithoutUsuarioInput>
    create: XOR<LogsCreateWithoutUsuarioInput, LogsUncheckedCreateWithoutUsuarioInput>
  }

  export type LogsUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: LogsWhereUniqueInput
    data: XOR<LogsUpdateWithoutUsuarioInput, LogsUncheckedUpdateWithoutUsuarioInput>
  }

  export type LogsUpdateManyWithWhereWithoutUsuarioInput = {
    where: LogsScalarWhereInput
    data: XOR<LogsUpdateManyMutationInput, LogsUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type LogsScalarWhereInput = {
    AND?: LogsScalarWhereInput | LogsScalarWhereInput[]
    OR?: LogsScalarWhereInput[]
    NOT?: LogsScalarWhereInput | LogsScalarWhereInput[]
    id?: IntFilter<"Logs"> | number
    entidad?: StringFilter<"Logs"> | string
    entidad_id?: IntNullableFilter<"Logs"> | number | null
    campo?: StringNullableFilter<"Logs"> | string | null
    valor_anterior?: StringNullableFilter<"Logs"> | string | null
    valor_nuevo?: StringNullableFilter<"Logs"> | string | null
    usuario_id?: IntFilter<"Logs"> | number
    fecha_cambio?: DateTimeNullableFilter<"Logs"> | Date | string | null
    motivo?: StringNullableFilter<"Logs"> | string | null
  }

  export type ReportesUpsertWithWhereUniqueWithoutGeneradoPorInput = {
    where: ReportesWhereUniqueInput
    update: XOR<ReportesUpdateWithoutGeneradoPorInput, ReportesUncheckedUpdateWithoutGeneradoPorInput>
    create: XOR<ReportesCreateWithoutGeneradoPorInput, ReportesUncheckedCreateWithoutGeneradoPorInput>
  }

  export type ReportesUpdateWithWhereUniqueWithoutGeneradoPorInput = {
    where: ReportesWhereUniqueInput
    data: XOR<ReportesUpdateWithoutGeneradoPorInput, ReportesUncheckedUpdateWithoutGeneradoPorInput>
  }

  export type ReportesUpdateManyWithWhereWithoutGeneradoPorInput = {
    where: ReportesScalarWhereInput
    data: XOR<ReportesUpdateManyMutationInput, ReportesUncheckedUpdateManyWithoutGeneradoPorInput>
  }

  export type ReportesScalarWhereInput = {
    AND?: ReportesScalarWhereInput | ReportesScalarWhereInput[]
    OR?: ReportesScalarWhereInput[]
    NOT?: ReportesScalarWhereInput | ReportesScalarWhereInput[]
    id?: IntFilter<"Reportes"> | number
    tipo?: StringFilter<"Reportes"> | string
    parametros?: JsonNullableFilter<"Reportes">
    archivo?: StringNullableFilter<"Reportes"> | string | null
    generado_por?: IntFilter<"Reportes"> | number
    generado_en?: DateTimeNullableFilter<"Reportes"> | Date | string | null
  }

  export type UsuarioRolUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput
    update: XOR<UsuarioRolUpdateWithoutUsuarioInput, UsuarioRolUncheckedUpdateWithoutUsuarioInput>
    create: XOR<UsuarioRolCreateWithoutUsuarioInput, UsuarioRolUncheckedCreateWithoutUsuarioInput>
  }

  export type UsuarioRolUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: UsuarioRolWhereUniqueInput
    data: XOR<UsuarioRolUpdateWithoutUsuarioInput, UsuarioRolUncheckedUpdateWithoutUsuarioInput>
  }

  export type UsuarioRolUpdateManyWithWhereWithoutUsuarioInput = {
    where: UsuarioRolScalarWhereInput
    data: XOR<UsuarioRolUpdateManyMutationInput, UsuarioRolUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type ConfigMedallasCreateManyAreaInput = {
    id?: number
    nivel_id: number
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
  }

  export type ParticipacionCreateManyAreaInput = {
    id?: number
    olimpista_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
  }

  export type ConfigMedallasUpdateWithoutAreaInput = {
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
    nivel?: NivelesUpdateOneRequiredWithoutConfigMedallasNestedInput
  }

  export type ConfigMedallasUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type ConfigMedallasUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type ParticipacionUpdateWithoutAreaInput = {
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    olimpista?: OlimpistasUpdateOneRequiredWithoutParticipacionNestedInput
    nivel?: NivelesUpdateOneRequiredWithoutParticipacionNestedInput
    evaluaciones?: EvaluacionesUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateManyWithoutAreaInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
  }

  export type EvaluacionesCreateManyFaseInput = {
    id?: number
    participacion_id: number
    evaluador_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesUpdateWithoutFaseInput = {
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participacion?: ParticipacionUpdateOneRequiredWithoutEvaluacionesNestedInput
    evaluador?: UsuariosUpdateOneWithoutEvaluacionesNestedInput
  }

  export type EvaluacionesUncheckedUpdateWithoutFaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    participacion_id?: IntFieldUpdateOperationsInput | number
    evaluador_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluacionesUncheckedUpdateManyWithoutFaseInput = {
    id?: IntFieldUpdateOperationsInput | number
    participacion_id?: IntFieldUpdateOperationsInput | number
    evaluador_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ParticipacionCreateManyNivelInput = {
    id?: number
    olimpista_id: number
    area_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
  }

  export type ConfigMedallasCreateManyNivelInput = {
    id?: number
    area_id: number
    oros?: number
    platas?: number
    bronces?: number
    menciones?: number
  }

  export type ParticipacionUpdateWithoutNivelInput = {
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    olimpista?: OlimpistasUpdateOneRequiredWithoutParticipacionNestedInput
    area?: AreasUpdateOneRequiredWithoutParticipacionNestedInput
    evaluaciones?: EvaluacionesUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateWithoutNivelInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateManyWithoutNivelInput = {
    id?: IntFieldUpdateOperationsInput | number
    olimpista_id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
  }

  export type ConfigMedallasUpdateWithoutNivelInput = {
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
    area?: AreasUpdateOneRequiredWithoutConfig_medallasNestedInput
  }

  export type ConfigMedallasUncheckedUpdateWithoutNivelInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type ConfigMedallasUncheckedUpdateManyWithoutNivelInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    oros?: IntFieldUpdateOperationsInput | number
    platas?: IntFieldUpdateOperationsInput | number
    bronces?: IntFieldUpdateOperationsInput | number
    menciones?: IntFieldUpdateOperationsInput | number
  }

  export type ParticipacionCreateManyOlimpistaInput = {
    id?: number
    area_id: number
    nivel_id: number
    estado?: $Enums.EstadoParticipacion
    tipo: $Enums.TipoParticipacion
  }

  export type MiembrosEquipoCreateManyOlimpistaInput = {
    id?: number
    nombre_equipo: string
    rol_en_equipo: $Enums.RolEquipo
  }

  export type ParticipacionUpdateWithoutOlimpistaInput = {
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    area?: AreasUpdateOneRequiredWithoutParticipacionNestedInput
    nivel?: NivelesUpdateOneRequiredWithoutParticipacionNestedInput
    evaluaciones?: EvaluacionesUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateWithoutOlimpistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
    evaluaciones?: EvaluacionesUncheckedUpdateManyWithoutParticipacionNestedInput
  }

  export type ParticipacionUncheckedUpdateManyWithoutOlimpistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    area_id?: IntFieldUpdateOperationsInput | number
    nivel_id?: IntFieldUpdateOperationsInput | number
    estado?: EnumEstadoParticipacionFieldUpdateOperationsInput | $Enums.EstadoParticipacion
    tipo?: EnumTipoParticipacionFieldUpdateOperationsInput | $Enums.TipoParticipacion
  }

  export type MiembrosEquipoUpdateWithoutOlimpistaInput = {
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
  }

  export type MiembrosEquipoUncheckedUpdateWithoutOlimpistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
  }

  export type MiembrosEquipoUncheckedUpdateManyWithoutOlimpistaInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre_equipo?: StringFieldUpdateOperationsInput | string
    rol_en_equipo?: EnumRolEquipoFieldUpdateOperationsInput | $Enums.RolEquipo
  }

  export type EvaluacionesCreateManyParticipacionInput = {
    id?: number
    evaluador_id?: number | null
    fase_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type EvaluacionesUpdateWithoutParticipacionInput = {
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    evaluador?: UsuariosUpdateOneWithoutEvaluacionesNestedInput
    fase?: FasesUpdateOneWithoutEvaluacionesNestedInput
  }

  export type EvaluacionesUncheckedUpdateWithoutParticipacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluador_id?: NullableIntFieldUpdateOperationsInput | number | null
    fase_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluacionesUncheckedUpdateManyWithoutParticipacionInput = {
    id?: IntFieldUpdateOperationsInput | number
    evaluador_id?: NullableIntFieldUpdateOperationsInput | number | null
    fase_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioRolCreateManyRolInput = {
    id?: number
    usuario_id?: number | null
  }

  export type UsuarioRolUpdateWithoutRolInput = {
    usuario?: UsuariosUpdateOneWithoutUsuario_rolNestedInput
  }

  export type UsuarioRolUncheckedUpdateWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioRolUncheckedUpdateManyWithoutRolInput = {
    id?: IntFieldUpdateOperationsInput | number
    usuario_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type OlimpistasCreateManyTutorInput = {
    id?: number
    nombre: string
    ap_paterno: string
    ap_materno?: string | null
    tipo_documento: $Enums.TipoDocumento
    numero_documento: string
    unidad_educativa: string
    departamento: string
    grado?: string | null
    fecha_nacimiento?: Date | string | null
    sexo?: $Enums.Sexo | null
    activo?: boolean
    creado_en?: Date | string
  }

  export type OlimpistasUpdateWithoutTutorInput = {
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    participacion?: ParticipacionUpdateManyWithoutOlimpistaNestedInput
    miembros_equipo?: MiembrosEquipoUpdateManyWithoutOlimpistaNestedInput
  }

  export type OlimpistasUncheckedUpdateWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    participacion?: ParticipacionUncheckedUpdateManyWithoutOlimpistaNestedInput
    miembros_equipo?: MiembrosEquipoUncheckedUpdateManyWithoutOlimpistaNestedInput
  }

  export type OlimpistasUncheckedUpdateManyWithoutTutorInput = {
    id?: IntFieldUpdateOperationsInput | number
    nombre?: StringFieldUpdateOperationsInput | string
    ap_paterno?: StringFieldUpdateOperationsInput | string
    ap_materno?: NullableStringFieldUpdateOperationsInput | string | null
    tipo_documento?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    numero_documento?: StringFieldUpdateOperationsInput | string
    unidad_educativa?: StringFieldUpdateOperationsInput | string
    departamento?: StringFieldUpdateOperationsInput | string
    grado?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_nacimiento?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sexo?: NullableEnumSexoFieldUpdateOperationsInput | $Enums.Sexo | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EvaluacionesCreateManyEvaluadorInput = {
    id?: number
    participacion_id: number
    fase_id?: number | null
    nota: Decimal | DecimalJsLike | number | string
    comentario?: string | null
    creado_en?: Date | string
    validado?: boolean | null
    ultima_modificacion?: Date | string | null
  }

  export type LogsCreateManyUsuarioInput = {
    id?: number
    entidad: string
    entidad_id?: number | null
    campo?: string | null
    valor_anterior?: string | null
    valor_nuevo?: string | null
    fecha_cambio?: Date | string | null
    motivo?: string | null
  }

  export type ReportesCreateManyGeneradoPorInput = {
    id?: number
    tipo: string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: string | null
    generado_en?: Date | string | null
  }

  export type UsuarioRolCreateManyUsuarioInput = {
    id?: number
    rol_id?: number | null
  }

  export type EvaluacionesUpdateWithoutEvaluadorInput = {
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participacion?: ParticipacionUpdateOneRequiredWithoutEvaluacionesNestedInput
    fase?: FasesUpdateOneWithoutEvaluacionesNestedInput
  }

  export type EvaluacionesUncheckedUpdateWithoutEvaluadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    participacion_id?: IntFieldUpdateOperationsInput | number
    fase_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EvaluacionesUncheckedUpdateManyWithoutEvaluadorInput = {
    id?: IntFieldUpdateOperationsInput | number
    participacion_id?: IntFieldUpdateOperationsInput | number
    fase_id?: NullableIntFieldUpdateOperationsInput | number | null
    nota?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    comentario?: NullableStringFieldUpdateOperationsInput | string | null
    creado_en?: DateTimeFieldUpdateOperationsInput | Date | string
    validado?: NullableBoolFieldUpdateOperationsInput | boolean | null
    ultima_modificacion?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type LogsUpdateWithoutUsuarioInput = {
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogsUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LogsUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    entidad?: StringFieldUpdateOperationsInput | string
    entidad_id?: NullableIntFieldUpdateOperationsInput | number | null
    campo?: NullableStringFieldUpdateOperationsInput | string | null
    valor_anterior?: NullableStringFieldUpdateOperationsInput | string | null
    valor_nuevo?: NullableStringFieldUpdateOperationsInput | string | null
    fecha_cambio?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReportesUpdateWithoutGeneradoPorInput = {
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportesUncheckedUpdateWithoutGeneradoPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ReportesUncheckedUpdateManyWithoutGeneradoPorInput = {
    id?: IntFieldUpdateOperationsInput | number
    tipo?: StringFieldUpdateOperationsInput | string
    parametros?: NullableJsonNullValueInput | InputJsonValue
    archivo?: NullableStringFieldUpdateOperationsInput | string | null
    generado_en?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UsuarioRolUpdateWithoutUsuarioInput = {
    rol?: RolesUpdateOneWithoutUsuario_rolNestedInput
  }

  export type UsuarioRolUncheckedUpdateWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UsuarioRolUncheckedUpdateManyWithoutUsuarioInput = {
    id?: IntFieldUpdateOperationsInput | number
    rol_id?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}